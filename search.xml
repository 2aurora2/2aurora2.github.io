<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>【JavaScript狂补知识第⑤弹】关于JS开发中的一些小知识点</title>
      <link href="/post/76bb88c4.html"/>
      <url>/post/76bb88c4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="深拷贝与浅拷贝"><a href="#深拷贝与浅拷贝" class="headerlink" title="深拷贝与浅拷贝"></a>深拷贝与浅拷贝</h2><p>关于JS的深拷贝和浅拷贝在开发中偶尔会用到，一不小心可能就导致数据渲染结果不尽如人意（没错，就是我总是踩坑……）。</p><p>要说到深拷贝和浅拷贝，我们就要先了解到在JavaScript中，基本数据类型（比如String，Number，Boolean，undefined，null）是通过值传递的，这意味着当你将一个基本类型的值赋给另一个变量时，系统会创建一个新的值拷贝给新的变量。新的变量会有自己的内存空间，并且与原始变量不共享内存。</p><p>但是如果在赋值操作中使用了对象类型（Object，Array，Function等）那么则会导致原数据和新数据共享一个内存空间，一旦我们更改其中一者数据另一个数据也会被更改，显然我们并不希望这样，因此就出现了浅拷贝和深拷贝的概念，可以说，深浅拷贝就是针对引用数据类型的。</p><h3 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h3><p>浅拷贝的概念：如果属性是基本类型，拷贝的就是基本类型的值。如果属性是引用类型，那么拷贝的就是内存地址（新旧对象共享同一块内存），所以如果其中一个对象改变了这个地址，就会影响到另一个对象（只是拷贝了指针，使得两个指针指向同一个地址）。</p><p>关于浅拷贝的实现方式有以下几种，我们可以从下面的例子中更好地理解浅拷贝的机制。</p><h4 id="数组的浅拷贝"><a href="#数组的浅拷贝" class="headerlink" title="数组的浅拷贝"></a>数组的浅拷贝</h4><ol><li><p>Array.prototype.concat</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;func&#x27;</span>, [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="keyword">let</span> new_arr = arr.<span class="title function_">concat</span>()</span><br><span class="line">new_arr[<span class="number">0</span>] = <span class="string">&#x27;na&#x27;</span></span><br><span class="line">new_arr[<span class="number">1</span>] = <span class="string">&#x27;ty&#x27;</span></span><br><span class="line">new_arr[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);   <span class="comment">// [ &#x27;name&#x27;, &#x27;type&#x27;, &#x27;func&#x27;, [ 1, 1 ] ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(new_arr);   <span class="comment">// [ &#x27;na&#x27;, &#x27;ty&#x27;, &#x27;func&#x27;, [ 1, 1 ] ]</span></span><br></pre></td></tr></table></figure><p>可以看出通过Array.prototype.concat方法，如果元素是引用类型（比如上面的Array），我们修改该元素的某个索引值/属性值，拷贝的新数据和原数据都会改变，而基本类型的值则正常拷贝，这就是所谓的浅拷贝。</p></li><li><p>ES6的展开运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;type&#x27;</span>, <span class="string">&#x27;func&#x27;</span>, [<span class="number">0</span>, <span class="number">1</span>]]</span><br><span class="line"><span class="keyword">let</span> new_arr = [...arr]</span><br><span class="line">new_arr[<span class="number">0</span>] = <span class="string">&#x27;na&#x27;</span></span><br><span class="line">new_arr[<span class="number">1</span>] = <span class="string">&#x27;ty&#x27;</span></span><br><span class="line">new_arr[<span class="number">3</span>][<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(arr);   <span class="comment">// [ &#x27;name&#x27;, &#x27;type&#x27;, &#x27;func&#x27;, [ 1, 1 ] ]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(new_arr);   <span class="comment">// [ &#x27;na&#x27;, &#x27;ty&#x27;, &#x27;func&#x27;, [ 1, 1 ] ]</span></span><br></pre></td></tr></table></figure><p>ES6的展开运算符同理也是浅拷贝。</p></li></ol><h4 id="对象的浅拷贝"><a href="#对象的浅拷贝" class="headerlink" title="对象的浅拷贝"></a>对象的浅拷贝</h4><ol><li><p>Object.assign</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;Object&#x27;</span>,</span><br><span class="line">    <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> new_obj = <span class="title class_">Object</span>.<span class="title function_">assign</span>(&#123;&#125;,obj)</span><br><span class="line">new_obj[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;name&#x27;</span></span><br><span class="line">new_obj[<span class="string">&#x27;arr&#x27;</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);   <span class="comment">// &#123; name: &#x27;obj&#x27;, type: &#x27;Object&#x27;, arr: [ 0, 2, 3 ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(new_obj);   <span class="comment">// &#123; name: &#x27;name&#x27;, type: &#x27;Object&#x27;, arr: [ 0, 2, 3 ] &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>ES6的展开运算符</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;Object&#x27;</span>,</span><br><span class="line">    <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> new_obj = &#123;...obj&#125;</span><br><span class="line">new_obj[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;name&#x27;</span></span><br><span class="line">new_obj[<span class="string">&#x27;arr&#x27;</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);   <span class="comment">// &#123; name: &#x27;obj&#x27;, type: &#x27;Object&#x27;, arr: [ 0, 2, 3 ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(new_obj);   <span class="comment">// &#123; name: &#x27;name&#x27;, type: &#x27;Object&#x27;, arr: [ 0, 2, 3 ] &#125;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h3><p>深拷贝是将一个对象从内存中完整的拷贝一份出来，从堆内存中开辟一个新的区域存放新对象（新旧对象不共享同一块内存），且修改新对象不会影响原对象。</p><p>关于深拷贝的实现方式主要有以下几种。</p><h4 id="递归实现"><a href="#递归实现" class="headerlink" title="递归实现"></a>递归实现</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">deepClone</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> newObj = <span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj) ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (obj.<span class="title function_">hasOwnProperty</span>(k)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (obj[k] <span class="keyword">instanceof</span> <span class="title class_">Object</span>)</span><br><span class="line">                newObj[k] = <span class="title function_">deepClone</span>(obj[k]);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                newObj[k] = obj[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上述deepClone递归函数的实现，我们可以测试一下是否实现了深拷贝：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;Object&#x27;</span>,</span><br><span class="line">    <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> new_obj = <span class="title function_">deepClone</span>(obj)</span><br><span class="line">new_obj[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;name&#x27;</span></span><br><span class="line">new_obj[<span class="string">&#x27;arr&#x27;</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);   <span class="comment">// &#123; name: &#x27;obj&#x27;, type: &#x27;Object&#x27;, arr: [ 1, 2, 3 ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(new_obj);   <span class="comment">// &#123; name: &#x27;name&#x27;, type: &#x27;Object&#x27;, arr: [ 0, 2, 3 ] &#125;</span></span><br></pre></td></tr></table></figure><h4 id="JSON-parse-JSON-stringify-obj"><a href="#JSON-parse-JSON-stringify-obj" class="headerlink" title="JSON.parse(JSON.stringify(obj))"></a>JSON.parse(JSON.stringify(obj))</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&#x27;Object&#x27;</span>,</span><br><span class="line">    <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> new_obj = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(<span class="title class_">JSON</span>.<span class="title function_">stringify</span>(obj))</span><br><span class="line">new_obj[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&#x27;name&#x27;</span></span><br><span class="line">new_obj[<span class="string">&#x27;arr&#x27;</span>][<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);   <span class="comment">// &#123; name: &#x27;obj&#x27;, type: &#x27;Object&#x27;, arr: [ 1, 2, 3 ] &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(new_obj);   <span class="comment">// &#123; name: &#x27;name&#x27;, type: &#x27;Object&#x27;, arr: [ 0, 2, 3 ] &#125;</span></span><br></pre></td></tr></table></figure><p>相比而言这种方式稍微简单一点（，当然也有一些第三方库帮我们实现了深拷贝，比如lodash等等。</p><h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><h3 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h3><h3 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h3>]]></content>
      
      
      <categories>
          
          <category> 开发范畴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JavaScript狂补知识第④弹】Node.js</title>
      <link href="/post/7d0b5cae.html"/>
      <url>/post/7d0b5cae.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Node.js这一块内容有点多，所以这篇博客可能不会一次性写完，会随着后面的学习慢慢更新……</p><h3 id="Node-js简介"><a href="#Node-js简介" class="headerlink" title="Node.js简介"></a>Node.js简介</h3><p>Node.js发布于2009年5月，由Ryan Dahl开发，是一个基于Chrome V8引擎的<strong>JavaScript运行环境</strong>，让JavaScript 得以运行服务端。众所周知，JavaScript也可以在浏览器中运行，如果想了解两者的区别可以通过官网的说明来了解<a href="https://nodejs.p2hp.com/learn/differences-between-nodejs-and-the-browser/">Node.js 和浏览器之间的区别 (p2hp.com)</a></p><h3 id="Node-js的用途"><a href="#Node-js的用途" class="headerlink" title="Node.js的用途"></a>Node.js的用途</h3><ol><li>开发服务端应用：类似Java、Go等语言编写应用后端程序</li><li>开发工具类应用：Webpack，VIte，Babel</li><li>开发桌面端应用：Electron（借助Node.js开发出来的桌面应用程序框架）</li></ol><p>Node.js通过使用核心模块和第三方模块来组织代码，下面就对常用的模块来进行学习。</p><h2 id="fs模块"><a href="#fs模块" class="headerlink" title="fs模块"></a>fs模块</h2><p>在Node.js中，文件系统（file system）模块是与文件和目录交互的核心模块之一。它提供了一系列的方法来读取、写入和管理文件，允许我们在服务器上高效地处理文件。Node.js的fs模块提供了两套API——Promise API和Callback API，下面主要讲的是Callback API，想要了解Promise API的可以前往官网<a href="https://nodejs.p2hp.com/api/v19/fs/#promises-api">文件系统 |Node.js v19 API — File system | Node.js v19 API (p2hp.com)</a>查看</p><h3 id="fs-writeFile-file-data-options-callback"><a href="#fs-writeFile-file-data-options-callback" class="headerlink" title="fs.writeFile(file, data[, options], callback)"></a>fs.writeFile(file, data[, options], callback)</h3><p><strong>异步</strong>向文件写入数据。</p><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li>file：文件名，<strong>异步</strong>将数据写入文件，如果文件已存在，则替换该文件，若不存在则创建文件</li><li>data：写入文件的数据，可以为string | Buffer | TypedArray | DataView</li><li>options：配置对象，可配置encoding、mode、flag(‘w’,’a’等)</li><li>callback：回调函数，有一个err参数，如果成功写入err为null</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>)</span><br><span class="line"></span><br><span class="line">fs.<span class="title function_">writeFile</span>(<span class="string">&#x27;./fs-file.txt&#x27;</span>, <span class="string">&#x27;fs module\n&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fs.writeFile success!&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="fs-writeFileSync-file-data-options"><a href="#fs-writeFileSync-file-data-options" class="headerlink" title="fs.writeFileSync(file, data[, options])"></a>fs.writeFileSync(file, data[, options])</h3><p><strong>同步</strong>向文件写入数据。</p><h4 id="参数说明-1"><a href="#参数说明-1" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li>file：文件名，<strong>异步</strong>将数据写入文件，如果文件已存在，则替换该文件，若不存在则创建文件</li><li>data：写入文件的数据，可以为string | Buffer | TypedArray | DataView</li><li>options：配置对象，可配置encoding、mode、flag(‘w’,’a’等)</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">writeFileSync</span>(<span class="string">&#x27;./fs-file.txt&#x27;</span>, <span class="string">&#x27;fs writeFileSync\n&#x27;</span>, &#123;<span class="attr">flag</span>: <span class="string">&#x27;a&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure><p>options对象里面的flag为’a’表示在文件末尾追加。</p><h3 id="fs-appendFile-path-data-options-callback"><a href="#fs-appendFile-path-data-options-callback" class="headerlink" title="fs.appendFile(path, data[, options], callback)"></a>fs.appendFile(path, data[, options], callback)</h3><p><strong>异步</strong>追加文件内容，参数和fs.writeFile一样。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">appendFile</span>(<span class="string">&#x27;./fs-file.txt&#x27;</span>, <span class="string">&#x27;fs appendFile&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;fs.appendFile success!&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="fs-appendFileSync-path-data-options"><a href="#fs-appendFileSync-path-data-options" class="headerlink" title="fs.appendFileSync(path, data[, options])"></a>fs.appendFileSync(path, data[, options])</h3><p><strong>同步</strong>追加文件内容，参数和异步方法api类型大致一样，只是变成<strong>同步</strong>方法，少了回调函数。</p><h3 id="fs-createWriteStream-path-options"><a href="#fs-createWriteStream-path-options" class="headerlink" title="fs.createWriteStream(path[, options])"></a>fs.createWriteStream(path[, options])</h3><p>流式写入api，适用于大文件写入或者频繁写入的场景。</p><h4 id="参数说明-2"><a href="#参数说明-2" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li>path：文件路径</li><li>options：配置对象（写入模式、编码等等）</li></ul><h4 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h4><p>fs.WriteStream对象：</p><ul><li>write方法写入；</li><li>end方法是当可写流中没有更多的数据需要写入时，会触发end事件。这通常意味着所有的数据都已经成功写入，并且流已经准备好进行后续处理或关闭；</li><li>close方法是在文件或流关闭时触发的。它不仅仅是因为没有更多的数据需要写入而触发，而是因为流或文件已经被关闭；</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ws = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;./fs-file.txt&#x27;</span>, &#123;<span class="attr">flags</span>: <span class="string">&#x27;a&#x27;</span>&#125;)</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">write</span>(<span class="string">&#x27;file-createWriteStream\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line">ws.<span class="title function_">close</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="fs-readFile-path-options-callback"><a href="#fs-readFile-path-options-callback" class="headerlink" title="fs.readFile(path[, options], callback)"></a>fs.readFile(path[, options], callback)</h3><p><strong>异步</strong>读取文件。</p><h4 id="参数说明-3"><a href="#参数说明-3" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li>path：文件路径</li><li>options：配置对象</li><li>callback：回调函数，有err和data两个参数，如果读取成功err为null且读取的数据存放在data中为Buffer类型，如果读取失败则err不为null</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readFile</span>(<span class="string">&#x27;./fs-file.txt&#x27;</span>, <span class="function">(<span class="params">err, data</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="fs-readFileSync-path-options"><a href="#fs-readFileSync-path-options" class="headerlink" title="fs.readFileSync(path[, options])"></a>fs.readFileSync(path[, options])</h3><p><strong>同步</strong>读取文件，参数相比于异步方法少了回调函数，对于读取失败可以通过try-catch捕获。</p><h4 id="参数说明-4"><a href="#参数说明-4" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li>path：文件路径</li><li>options：配置对象</li></ul><h4 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h4><p>返回文件内容（Buffer类型）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="keyword">const</span> data = fs.<span class="title function_">readFileSync</span>(<span class="string">&#x27;./fs-file.txt&#x27;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data.<span class="title function_">toString</span>())</span><br><span class="line">&#125;<span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(e)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fs-createReadStream-path-options"><a href="#fs-createReadStream-path-options" class="headerlink" title="fs.createReadStream(path[, options])"></a>fs.createReadStream(path[, options])</h3><p>流式读取api，适用于大文件读取的场景。</p><h4 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h4><p>fs.ReadStream对象：</p><ul><li>绑定data事件，每次从文件读取一块数据就触发回调函数，并把读取内容传给形参（一块数据 === 65536字节/64KB）</li><li>绑定end事件，文件读取完成后触发回调函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> rs = fs.<span class="title function_">createReadStream</span>(<span class="string">&#x27;./music/music.flac&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> ws = fs.<span class="title function_">createWriteStream</span>(<span class="string">&#x27;./music/music-copy.flac&#x27;</span>)</span><br><span class="line"></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">    ws.<span class="title function_">write</span>(chunk)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">rs.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Read End!&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="fs-rename-oldPath-newPath-callback"><a href="#fs-rename-oldPath-newPath-callback" class="headerlink" title="fs.rename(oldPath, newPath, callback)"></a>fs.rename(oldPath, newPath, callback)</h3><p>将 oldPath 中的文件异步重命名为作为 newPath 提供的路径名，如果newPath和oldPath目录层级不一样，则会移动文件，因此可以利用此api实现文件重命名和移动。</p><h4 id="参数说明-5"><a href="#参数说明-5" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li>oldPath：旧文件路径，具体到文件名</li><li>newPath：新文件路径，具体到文件名</li><li>callback：回调函数，只有err一个参数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">rename</span>(<span class="string">&#x27;./music/music.flac&#x27;</span>,<span class="string">&#x27;./music.flac&#x27;</span>,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>此方法是异步方法，同样有对应的同步方法：fs.renameSync(oldPath,newPath)</p></blockquote><h3 id="fs-unlink-path-callback"><a href="#fs-unlink-path-callback" class="headerlink" title="fs.unlink(path, callback)"></a>fs.unlink(path, callback)</h3><p>异步删除文件或符号链接。除了可能的异常之外，不会为完成回调提供任何参数。</p><h4 id="参数说明-6"><a href="#参数说明-6" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li>path：文件路径</li><li>callback：回调函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">unlink</span>(<span class="string">&#x27;./music.flac&#x27;</span>,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;delete success&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>此方法是异步方法，同样有对应的同步方法：fs.unlinkSync(path)</p></blockquote><h3 id="fs-rm-path-options-callback"><a href="#fs-rm-path-options-callback" class="headerlink" title="fs.rm(path[, options], callback)"></a>fs.rm(path[, options], callback)</h3><p>异步删除文件和目录。除了可能的异常之外，不会为完成回调提供任何参数。与unlink不同的是，rm可以用来删除文件夹，并且提供了多种配置选项。</p><h4 id="参数说明-7"><a href="#参数说明-7" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li>path：文件路径或者文件夹路径</li><li>options：配置对象<ul><li>force：如果为true，如果 path 不存在，则将忽略异常。默认值：false。</li><li>maxRetries：如果遇到 EBUSY、EMFILE、ENFILE、ENOTEMPTY 或 EPERM 错误，Node.js将重试该操作，每次尝试时retryDelay毫秒的线性回退等待。此选项表示重试次数。如果递归选项不为 true，则忽略此选项。默认值：0。</li><li>recursive：递归选项，如果为true，则执行递归删除。在递归模式下，如果失败，将重试操作。</li><li>retryDelay：两次重试之间等待的时间量（以毫秒为单位）。</li></ul></li><li>callback：回调函数，参数为err，成功删除则err为null</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">rm</span>(<span class="string">&#x27;./music&#x27;</span>, &#123;<span class="attr">recursive</span>: <span class="literal">true</span>&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;delete success&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>同步方法：fs.rmdirSync(path[, options])</p></blockquote><h3 id="fs-mkdir-path-options-callback"><a href="#fs-mkdir-path-options-callback" class="headerlink" title="fs.mkdir(path[, options], callback)"></a>fs.mkdir(path[, options], callback)</h3><p>异步创建目录，也可递归创建目录（递归创建需要options的recursive为true）</p><h4 id="参数说明-8"><a href="#参数说明-8" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li>path：要创建的目录</li><li>options：配置对象<ul><li>recursive：是否递归创建目录，默认为false</li><li>mode：在Windows下不支持该参数</li></ul></li><li>callback：回调函数，有err和path两个参数，仅当recursive为true时才有path参数，值为递归创建的文件夹路径</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归创建</span></span><br><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&#x27;./a&#x27;</span>, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;success&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 递归创建</span></span><br><span class="line">fs.<span class="title function_">mkdir</span>(<span class="string">&#x27;./a/b/c&#x27;</span>, &#123;<span class="attr">recursive</span>: <span class="literal">true</span>&#125;, <span class="function">(<span class="params">err, path</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(path)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>同步方法：fs.mkdirSync(path[, options])</p></blockquote><h3 id="fs-readdir-path-options-callback"><a href="#fs-readdir-path-options-callback" class="headerlink" title="fs.readdir(path[, options], callback)"></a>fs.readdir(path[, options], callback)</h3><p>读取目录的内容。回调获取两个参数（err、files），其中 files是目录中文件名称的数组.</p><h4 id="参数说明-9"><a href="#参数说明-9" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li>path：文件夹路径</li><li>options：配置对象（encoding、withFileTypes）</li><li>callback：回调函数</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">readdir</span>(<span class="string">&#x27;./&#x27;</span>,&#123;<span class="attr">withFileTypes</span>:<span class="literal">true</span>&#125;,<span class="function">(<span class="params">err, files</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(files)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><blockquote><p>同步方法：fs.readdirSync(path[, options])，返回目录下文件列表</p></blockquote><h3 id="fs-stat-path-options-callback"><a href="#fs-stat-path-options-callback" class="headerlink" title="fs.stat(path[, options], callback)"></a>fs.stat(path[, options], callback)</h3><p>获取对应path的文件/文件夹资源信息。</p><h4 id="参数说明-10"><a href="#参数说明-10" class="headerlink" title="参数说明"></a>参数说明</h4><ul><li>path：文件/文件夹路径</li><li>options：配置对象</li><li>callback：回调函数，err和stats两个参数，err为null时stats表示对应文件/文件夹的资源信息</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">fs.<span class="title function_">stat</span>(<span class="string">&#x27;./fs-file.txt&#x27;</span>,<span class="function">(<span class="params">err, stats</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(err)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(stats)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// Stats &#123;</span></span><br><span class="line"><span class="comment">//     dev: 648906302,</span></span><br><span class="line"><span class="comment">//         mode: 33206,</span></span><br><span class="line"><span class="comment">//         nlink: 1,</span></span><br><span class="line"><span class="comment">//         uid: 0,</span></span><br><span class="line"><span class="comment">//         gid: 0,</span></span><br><span class="line"><span class="comment">//         rdev: 0,</span></span><br><span class="line"><span class="comment">//         blksize: 4096,</span></span><br><span class="line"><span class="comment">//         ino: 4503599627670657,</span></span><br><span class="line"><span class="comment">//         size: 82,</span></span><br><span class="line"><span class="comment">//         blocks: 0,</span></span><br><span class="line"><span class="comment">//         atimeMs: 1723879750451.2693,</span></span><br><span class="line"><span class="comment">//         mtimeMs: 1723878851838.4558,</span></span><br><span class="line"><span class="comment">//         ctimeMs: 1723878851838.4558,</span></span><br><span class="line"><span class="comment">//         birthtimeMs: 1723865499733.0498,</span></span><br><span class="line"><span class="comment">//         atime: 2024-08-17T07:29:10.451Z,  // 最后访问时间</span></span><br><span class="line"><span class="comment">//         mtime: 2024-08-17T07:14:11.838Z,  // 最后修改时间</span></span><br><span class="line"><span class="comment">//         ctime: 2024-08-17T07:14:11.838Z,  // 状态改变时间</span></span><br><span class="line"><span class="comment">//         birthtime: 2024-08-17T03:31:39.733Z  // 文件创建时间</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="path模块"><a href="#path模块" class="headerlink" title="path模块"></a>path模块</h2><p>path 模块提供了用于处理文件和目录路径的实用方法，下表是主要常用的一些方法：</p><table><thead><tr><th align="center">API</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">path.resolve</td><td align="center">拼接规范的绝对路径</td></tr><tr><td align="center">path.sep</td><td align="center">获取当前操作系统的路径分隔符</td></tr><tr><td align="center">path.parse</td><td align="center">解析绝对路径并返回对象</td></tr><tr><td align="center">path.basename</td><td align="center">获取路径的基础名称——路径最内层名称</td></tr><tr><td align="center">ath.dirname</td><td align="center">获取路径的目录名——除去路径最内层名称</td></tr><tr><td align="center">path.extname</td><td align="center">获取路径的扩展名</td></tr></tbody></table><p>对于path模块的使用还要认识以下两个特殊变量：</p><ul><li>__dirname：表示当前执行脚本所在的目录的绝对路径</li><li>__filename：表示当前执行脚本的绝对路径</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(__dirname)  <span class="comment">// D:\desk\Frontend\hand\Node.js</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(__filename) <span class="comment">// D:\desk\Frontend\hand\Node.js\path.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> p1 = path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;index.html&#x27;</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1) <span class="comment">// D:\desk\Frontend\hand\Node.js\index.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sep = path.<span class="property">sep</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(sep)    <span class="comment">// \</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = path.<span class="title function_">parse</span>(p1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj)</span><br><span class="line"></span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//     root: &#x27;D:\\&#x27;,</span></span><br><span class="line"><span class="comment">//     dir: &#x27;D:\\desk\\Frontend\\hand\\Node.js&#x27;,</span></span><br><span class="line"><span class="comment">//     base: &#x27;index.html&#x27;,</span></span><br><span class="line"><span class="comment">//     ext: &#x27;.html&#x27;,</span></span><br><span class="line"><span class="comment">//     name: &#x27;index&#x27;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> basename = path.<span class="title function_">basename</span>(p1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(basename)   <span class="comment">// index.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> dir = path.<span class="title function_">dirname</span>(p1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dir)    <span class="comment">// D:\desk\Frontend\hand\Node.js</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> ext = path.<span class="title function_">extname</span>(p1)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(ext)    <span class="comment">// .html</span></span><br></pre></td></tr></table></figure><h2 id="http模块"><a href="#http模块" class="headerlink" title="http模块"></a>http模块</h2><p>http 模块是 Node.js 官方提供的、用来创建 web 服务器的模块。通过 http 模块提供的http.createServer() 方法，就能方便的把一台普通的电脑，变成一台 Web 服务器，从而对外提供 Web 资源服务。下面演示了http创建web服务器的常用方法。</p><h3 id="创建web服务器"><a href="#创建web服务器" class="headerlink" title="创建web服务器"></a>创建web服务器</h3><ol><li>引入http模块</li><li>http.createServer()创建Server对象</li><li>Server对象监听对应端口的请求</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">&#x27;NodeJS http Module&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server start at : http://127.0.0.1:9000/&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过上述代码我们创建了一个Web服务器用以监听9000端口的请求，一旦我们访问<a href="http://127.0.0.1:9000/%E5%B0%B1%E4%BC%9A%E5%90%91%E8%BF%99%E4%B8%AA%E7%AB%AF%E5%8F%A3%E5%8F%91%E8%B5%B7http%E8%AF%B7%E6%B1%82%EF%BC%8C%E8%BF%9B%E8%80%8C%E8%A7%A6%E5%8F%91server%E7%9A%84%E5%9B%9E%E8%B0%83%EF%BC%8Cweb%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%B0%B1%E4%BC%9A%E8%BF%94%E5%9B%9E%E5%AD%97%E7%AC%A6%E4%B8%B2%60NodeJS">http://127.0.0.1:9000/就会向这个端口发起http请求，进而触发server的回调，web服务器就会返回字符串`NodeJS</a> http Module`。</p><h3 id="获取请求报文内容"><a href="#获取请求报文内容" class="headerlink" title="获取请求报文内容"></a>获取请求报文内容</h3><p>http模块也为我们提供了一些api用来获取请求的相关信息，一些通用的api如下表所示：</p><table><thead><tr><th align="center">API</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">request.method</td><td align="center">获取请求的方法：GET/POST/PUT/DELETE等</td></tr><tr><td align="center">request.url</td><td align="center">获取请求的路径</td></tr><tr><td align="center">request.httpVersion</td><td align="center">获取http协议的版本号</td></tr><tr><td align="center">request.headers</td><td align="center">获取http请求的请求头</td></tr></tbody></table><p>对于POST请求还有请求体，可以通过绑定request的data事件来获取请求体的内容。下面是获取http请求的相关信息api的使用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 获取请求的方法</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">method</span>)</span><br><span class="line">    <span class="comment">// 获取请求的url</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">url</span>)</span><br><span class="line">    <span class="comment">// 获取http协议的版本号</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">httpVersion</span>)</span><br><span class="line">    <span class="comment">// 获取http请求的请求头headers</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(request.<span class="property">headers</span>.<span class="property">host</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取请求体</span></span><br><span class="line">    <span class="keyword">let</span> reqBody = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    request.<span class="title function_">on</span>(<span class="string">&#x27;data&#x27;</span>, <span class="function"><span class="params">chunk</span> =&gt;</span> &#123;</span><br><span class="line">        reqBody += chunk</span><br><span class="line">    &#125;)</span><br><span class="line">    request.<span class="title function_">on</span>(<span class="string">&#x27;end&#x27;</span>,<span class="function">()=&gt;</span>&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(reqBody)</span><br><span class="line">        response.<span class="title function_">end</span>(<span class="string">&#x27;NodeJS HTTP!&#x27;</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server start at : http://127.0.0.1:9000/&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="请求路径参数解析"><a href="#请求路径参数解析" class="headerlink" title="请求路径参数解析"></a>请求路径参数解析</h3><p>对于GET方法的http请求可以在url会携带一些参数，如果想要提取出来，node为我们提供了两种方式，一种是通过node内置的url模块，另一种是通过创建URL对象的方式，前一种方式因为官网说未来可能会弃用，因此下面以第二种方式为例来解析请求路径参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> base = <span class="string">&#x27;http://127.0.0.1&#x27;</span></span><br><span class="line">    <span class="keyword">let</span> _url = <span class="keyword">new</span> <span class="title function_">URL</span>(request.<span class="property">url</span>, base) <span class="comment">// 传入相对路径和根路径</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(_url)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(_url.<span class="property">searchParams</span>.<span class="title function_">get</span>(<span class="string">&#x27;keyword&#x27;</span>))    <span class="comment">// 通过searchParams的get方法获取路径参数</span></span><br><span class="line"></span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">&#x27;NodeJS HTTP!&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server start at : http://127.0.0.1:9000/&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>打印的URL对象如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">URL <span class="punctuation">&#123;</span></span><br><span class="line">  href<span class="punctuation">:</span> &#x27;http<span class="punctuation">:</span><span class="comment">//127.0.0.1/search?keyword=h5&#x27;,</span></span><br><span class="line">  origin<span class="punctuation">:</span> &#x27;http<span class="punctuation">:</span><span class="comment">//127.0.0.1&#x27;,</span></span><br><span class="line">  protocol<span class="punctuation">:</span> &#x27;http<span class="punctuation">:</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">  username<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">  password<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">  host<span class="punctuation">:</span> &#x27;<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">  hostname<span class="punctuation">:</span> &#x27;<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>&#x27;<span class="punctuation">,</span></span><br><span class="line">  port<span class="punctuation">:</span> &#x27;&#x27;<span class="punctuation">,</span></span><br><span class="line">  pathname<span class="punctuation">:</span> &#x27;/search&#x27;<span class="punctuation">,</span></span><br><span class="line">  search<span class="punctuation">:</span> &#x27;?keyword=h5&#x27;<span class="punctuation">,</span></span><br><span class="line">  searchParams<span class="punctuation">:</span> URLSearchParams <span class="punctuation">&#123;</span> &#x27;keyword&#x27; =&gt; &#x27;h5&#x27; <span class="punctuation">&#125;</span><span class="punctuation">,</span><span class="comment">// 路径参数，通过get方法获取</span></span><br><span class="line">  hash<span class="punctuation">:</span> &#x27;&#x27;</span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="设置响应报文内容"><a href="#设置响应报文内容" class="headerlink" title="设置响应报文内容"></a>设置响应报文内容</h3><p>获取请求报文之后，就要对请求做出响应，下表是设置请求报文的相关API。</p><table><thead><tr><th align="center">API</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">response.statusCode</td><td align="center">设置响应状态码</td></tr><tr><td align="center">response.statusMessage</td><td align="center">设置响应信息</td></tr><tr><td align="center">response.setHeader</td><td align="center">设置响应头</td></tr><tr><td align="center">response.write</td><td align="center">传入字符串设置响应体信息，可以有多次调用</td></tr><tr><td align="center">response.end</td><td align="center">在response.write结束后调用，同样可传信息，但是只能调用一次</td></tr></tbody></table><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">request, response</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 设置响应状态码</span></span><br><span class="line">    response.<span class="property">statusCode</span> = <span class="number">200</span>    <span class="comment">// 默认200</span></span><br><span class="line">    <span class="comment">// 设置响应信息</span></span><br><span class="line">    response.<span class="property">statusMessage</span> = <span class="string">&#x27;Response Success!&#x27;</span></span><br><span class="line">    <span class="comment">// 设置响应头</span></span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;Server&#x27;</span>, <span class="string">&#x27;Node.js&#x27;</span>)</span><br><span class="line">    response.<span class="title function_">setHeader</span>(<span class="string">&#x27;test&#x27;</span>, [<span class="string">&#x27;test-01&#x27;</span>, <span class="string">&#x27;test-02&#x27;</span>])   <span class="comment">// 设置同名响应头</span></span><br><span class="line">    <span class="comment">// 设置响应体</span></span><br><span class="line">    response.<span class="title function_">write</span>(<span class="string">&#x27;app&#x27;</span>)</span><br><span class="line">    response.<span class="title function_">end</span>(<span class="string">&#x27;NodeJS HTTP!&#x27;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">9000</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;server start at : http://127.0.0.1:9000/&#x27;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>通过以上步骤可以制作一个简单的web服务器，但是对于一些庞大的后端项目来说就有点捉襟见肘了，后面会专门出一片博客来讲基于Node.js的Web开发应用框架——Express。</p>]]></content>
      
      
      <categories>
          
          <category> 开发范畴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> NodeJS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JavaScript狂补知识第③弹】ES6之Promise异步编程</title>
      <link href="/post/923bbd1b.html"/>
      <url>/post/923bbd1b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>ES6中Promise的提出本质上是为了解决回调地狱的问题，因此我们先来了解什么是回调地狱。</p><h3 id="相关概念"><a href="#相关概念" class="headerlink" title="相关概念"></a>相关概念</h3><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>要了解什么是回调地狱，我们需要先知道回调函数。简单来说，当一个函数作为参数传入另一个函数中，并且它不会立即执行，只有当满足一定条件后该函数才可以执行，这种函数就称为回调函数。</p><p>简单的例子比如JS里面常用的定时器：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这里是回调函数的打印&quot;</span>);</span><br><span class="line">&#125;, <span class="number">2000</span>)</span><br></pre></td></tr></table></figure><p>以上箭头函数我们就可以称为回调函数。</p><h4 id="回调地狱"><a href="#回调地狱" class="headerlink" title="回调地狱"></a>回调地狱</h4><p>一般来说回调函数的使用伴随着异步任务的执行，异步任务不会影响主线程的执行，而是进入异步队列，不会阻塞主线程的执行，并且只有<strong>主线程中的任务全部执行完毕</strong>，才会在任务队列中按顺序取出已完成的异步任务对应的回调函数放入主线程再执行，哪怕异步任务已经到时间了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 尽管是0ms后执行，还是会先执行完主线程的同步任务</span></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这里是异步任务！&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这里是同步任务！&quot;</span>);</span><br><span class="line"><span class="comment">// 输出为：</span></span><br><span class="line"><span class="comment">// 这里是同步任务！</span></span><br><span class="line"><span class="comment">// 这里是异步任务！</span></span><br></pre></td></tr></table></figure><p>但是在我们的开发场景中，可能某一个异步任务的执行需要在另一个异步任务的回调函数执行完后再执行，因此就会出现回调函数的嵌套现象。比如我希望在执行三个异步任务，分别打印“欢迎来到我的博客！”、“今天天气真好！”、“祝您天天开心！”，并且要按照顺序打印，那可能就会出现以下代码：（当然正常开发中不会是这么离谱的例子，这里只是方便说明，可能开发会遇到执行一个ajax请求后，拿到请求结果再根据请求结果发起另一个ajax请求都是有可能的）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;欢迎来到我的博客！&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;今天天气真好！&quot;</span>);</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;祝您天天开心！&quot;</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><p>上面这种回调函数嵌套回调函数的现象就称为回调地狱。为了解决回调地狱，ES6就提出了所谓的Promise异步编程的解决方案。</p><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise 在英文中的意思是承诺。在程序中表示，承诺在一段时间后给出结果。根据Promise官网的说法，可以把Promise看作是一个构造函数，可以由 Promise 产生一个对象，以此用来封装一个异步操作，并且可以获取其成功/失败的最终结果。</p><h3 id="Promise的状态"><a href="#Promise的状态" class="headerlink" title="Promise的状态"></a>Promise的状态</h3><p>对于一个Promise对象来说，其状态会使以下三种状态之一：</p><ol><li>pending：<code>The initial state of a promise.</code>，Promise的初始状态，即还未给出结果的状态。</li><li>fulfilled：<code>The state of a promise representing a successful operation.</code>，成功操作的Promise状态。</li><li>rejected：<code>The state of a promise representing a failed operation.</code>，失败操作的Promise状态。</li></ol><p>一个 Promise的状态只能由 <code>pending</code> 变为 <code>fulfilled</code>，或者变为 <code>rejected</code>，且只能改变一次。</p><h3 id="Promise对象的使用"><a href="#Promise对象的使用" class="headerlink" title="Promise对象的使用"></a>Promise对象的使用</h3><h4 id="Promise构造函数"><a href="#Promise构造函数" class="headerlink" title="Promise构造函数"></a>Promise构造函数</h4><p>我们可以通过<code>new Promise(executor)</code>来创建Promise对象，Promise构造函数接受一个executor执行器函数，这个executor又接受两个参数resolver和reject，分别表示操作成功/失败要使用的一个“工具”。</p><p>我们可以先创建一个Promise实例并通过console.log来初步认识一下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);</span><br></pre></td></tr></table></figure><p>最终打印结果如下图所示：</p><img src="/post/923bbd1b/1.png" class title="Promise实例"><p>从上图可以看出Promise实例的初始状态确实为pending，而一旦我们的异步操作成功后，我们可以调用resolve工具来返回成功操作的结果以及转变Promise的状态，这里假设成功操作返回一个字符串：（reject同理，异步操作失败时调用）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;Success!&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1);</span><br></pre></td></tr></table></figure><img src="/post/923bbd1b/2.png" class title="Promise Resolve"><p>通过上述代码我们可以知道，excutor函数中resolve/reject的调用或者不调用，影响着Promise的状态以及我们的后续使用。</p><h4 id="Promise对象的方法"><a href="#Promise对象的方法" class="headerlink" title="Promise对象的方法"></a>Promise对象的方法</h4><p>有了Promise之后我们可以在excutor中执行异步任务，对于任务成功调用resolve返回任务成功的相关内容，可能是数据等等，reject同理，那么我们怎么拿到这些数据呢？Promise给对象实例提供了一些方法，下面通过代码来演示：</p><ol><li><p>Promise.prototype.then()</p><p>Promise.prototype.then 方法绑定在原型 prototype 上，意味着这是一个实例方法，必须在实例对象上才能使用。返回值是一个Promise对象，具体返回的规则如下：</p><p>如果 then 中的回调函数：</p><ul><li><p>返回了一个值，那么 then 返回的 Promise 将会成为接受状态（fulfilled），并且将返回的值作为接受状态的回调函数的参数值。</p></li><li><p>没有返回任何值，那么 then 返回的 Promise 将会成为接受状态（fulfilled），并且该接受状态的回调函数的参数值为 undefined。</p></li><li><p>抛出一个错误，那么 then 返回的 Promise 将会成为拒绝状态（rejected），并且将抛出的错误作为拒绝状态的回调函数的参数值。</p></li><li><p>返回一个已经是接受状态（fulfilled）的 Promise，那么 then 返回的 Promise 也会成为接受状态，并且将那个 Promise 的接受状态的回调函数的参数值作为该被返回的Promise的接受状态回调函数的参数值。</p></li><li><p>返回一个已经是拒绝状态（rejected）的 Promise，那么 then 返回的 Promise 也会成为拒绝状态，并且将那个 Promise 的拒绝状态的回调函数的参数值作为该被返回的Promise的拒绝状态回调函数的参数值。</p></li><li><p>返回一个未定状态（pending）的 Promise，那么 then 返回 Promise 的状态也是未定的，并且它的终态与那个 Promise 的终态相同；同时，它变为终态时调用的回调函数参数与那个 Promise 变为终态时的回调函数的参数是相同的。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;异步任务执行成功！&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);      <span class="comment">// 异步任务执行成功！</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>当我们异步任务成功后，我们可以通过resolve返回成功的结果，这时会改变p1的状态为fulfilled，然后会自动调用**.then**方法，并把resolve返回的结果作为.then中回调函数的参数data，后续针对data进行相关处理。</p></li><li><p>Promise.prototype.catch()</p><p>那么如果异步任务失败呢？怎么拿到对应的任务失败的信息？下面还是通过代码来演示：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;异步任务执行失败！&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);       <span class="comment">// 异步任务执行失败！</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到如果excutor调用的是reject则会触发**.catch**方法。catch同样返回一个Promise 对象。如果 onRejected抛出一个错误或返回一个本身失败的 Promise，那么 catch()返回的 Promise的状态为rejected；否则，状态为 fulfilled。</p></li></ol><p>因此我们知道<strong>通过在excutor中调用resolve/reject会导致.then或者.catch其中一个被触发</strong>。</p><p>现在回到最开始那个问题，我希望在执行三个异步任务，分别打印“欢迎来到我的博客！”、“今天天气真好！”、“祝您天天开心！”，并且要按照顺序打印，那么通过Promise我们怎么实现呢？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;欢迎来到我的博客！&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;今天天气真好！&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;祝您天天开心！&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);      </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>可以看到我们可以在第一个异步任务执行完后的.then方法中返回一个新的Promise对象，那么.then方法返回值就是一个Promise对象实例，就又可以继续在第二个任务执行成功后触发.then方法。通过Promise这种链式调用的方式避免了之前回调地狱嵌套很多层的情况，并且可读性更强，更趋向于同步的写法了。</p><p>那现在假设我希望对于每一个异步任务都有一个不同的catch，那需要怎么改写呢？其实.then的参数是两个，第一个参数是成功的回调函数onFulfilled，第二个参数是失败的回调函数onRejected，因此我们可以改写为下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;欢迎来到我的博客！&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&#x27;任务2失败的信息！&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;任务1失败了！&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;祝您天天开心！&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;任务2失败了！&#x27;</span>);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;任务3失败了！&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后我们来看一下控制台的输出：</p><img src="/post/923bbd1b/3.png" class title="Promise then"><p>我们可以看到确实提示了任务2失败，但是后面还打印了一个undefined，原因其实是因为reject(‘任务2失败的信息！’)后下一个.then的失败的回调函数没有返回值，这就导致了<strong>then没有返回值，那么.then会返回一个fulfilled状态的Promise，并且该接受状态的回调函数的参数值为 undefined</strong>，而这个fulfilled状态的Promise就会触发下一个then的成功的回调，打印对应的信息，因此就出现了打印undefined的情况。</p><p>解决这种情况的方式很简单，只需要在console.log(‘任务2失败了！’);后面抛出一个错误就可以了。<strong>抛出一个错误，那么 then 返回的 Promise 将会成为拒绝状态（rejected），并且将抛出的错误作为拒绝状态的回调函数的参数值</strong>。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;欢迎来到我的博客！&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">reject</span>(<span class="string">&#x27;任务2失败的信息！&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;任务1失败了！&#x27;</span>));</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;祝您天天开心！&#x27;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 抛出异常下一个then就会走失败的回调函数</span></span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;任务2失败了！&#x27;</span>));</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(data);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;任务3失败了！&#x27;</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="/post/923bbd1b/4.png" class title="Throw Error"><h4 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h4><p>虽然上述写法解决了回调地狱问题，但是如果遇到很多异步任务关联就需要去写一大长串的链式调用不太好看，因此ES7就提出了async/await 这一基于Promise的解决异步的最终方案。</p><p>通过await来获取fulfilled状态Promise的返回值，对于rejected的Promise则通过try-catch来捕获，下面是前文那个例子在async/await中的写法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;欢迎来到我的博客！&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// resolve(&#x27;今天天气真好！&#x27;);</span></span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;任务2失败！&#x27;</span>)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;祝您天天开心！&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">main</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> d1 = <span class="keyword">await</span> p1;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(d1);</span><br><span class="line">        <span class="keyword">const</span> d2 = <span class="keyword">await</span> p2;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(d2);</span><br><span class="line">        <span class="keyword">const</span> d3 = <span class="keyword">await</span> p3;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(d3);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">main</span>()</span><br></pre></td></tr></table></figure><p>控制台输出如下：</p><img src="/post/923bbd1b/5.png" class title="async&#x2F;await"><h3 id="Promise的方法"><a href="#Promise的方法" class="headerlink" title="Promise的方法"></a>Promise的方法</h3><p>之前讲的都是Promise对象的方法，是需要通过Promise实例调用的，Promise还有许多静态方法，下面展示了常见的Promise方法。</p><h4 id="Promise-resolve-value"><a href="#Promise-resolve-value" class="headerlink" title="Promise.resolve(value)"></a>Promise.resolve(value)</h4><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><p>可以是一个值，也可以是一个 Promise 对象，或者是一个 thenable。</p><h5 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h5><ul><li>若给定值为一个字面值或数组等等之类的，则返回一个成功的 Promise</li><li>若参数本身就是一个 Promise 对象，则直接返回这个 Promise 对象。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;任务执行成功！&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">reject</span>(<span class="string">&#x27;任务执行失败！&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="keyword">const</span> p4 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p1)</span><br><span class="line"><span class="keyword">const</span> p5 = <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(p2)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p3);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p4);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p5);</span><br></pre></td></tr></table></figure><img src="/post/923bbd1b/6.png" class title="Promise.resolve()"><h4 id="Promise-reject-reason"><a href="#Promise-reject-reason" class="headerlink" title="Promise.reject(reason)"></a>Promise.reject(reason)</h4><h5 id="参数-1"><a href="#参数-1" class="headerlink" title="参数"></a>参数</h5><p>失败的原因。</p><h5 id="返回值-1"><a href="#返回值-1" class="headerlink" title="返回值"></a>返回值</h5><p>返回一个状态为 rejected 的 Promise 对象。</p><h4 id="Promise-all-iterable"><a href="#Promise-all-iterable" class="headerlink" title="Promise.all(iterable)"></a>Promise.all(iterable)</h4><h5 id="参数-2"><a href="#参数-2" class="headerlink" title="参数"></a>参数</h5><p>多个 promise /值组成的可迭代类型（Array、Map、Set等）。</p><h5 id="返回值-2"><a href="#返回值-2" class="headerlink" title="返回值"></a>返回值</h5><ul><li><p>若传入的参数为空的可迭代对象，例如 Promise.all([])，则返回一个已完成状态（fulfilled）的 Promise</p></li><li><p>若传入的参数不包含任何 promise，则返回一个异步完成（asynchronously resolved）的 Promise。</p></li><li><p>其它情况下返回一个处理中（pending）的 Promise。只有接收的参数的 promise 全部成功，这个返回的 Promise 才会是成功的，只要有一个失败，则返回一个失败的 Promise，且返回的值为第一个失败的值。</p></li><li><p>若所有 promise 都成功，则返回的 Promise 的值为一个包含了多个结果的数组</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;欢迎来到我的博客！&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;今天天气真好！&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p3 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(<span class="string">&#x27;祝您天天开心！&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">all</span>([p1, p2, p3, &#123; <span class="attr">code</span>: <span class="number">200</span>, <span class="attr">message</span>: <span class="string">&#x27;成功！&#x27;</span> &#125;]);</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="/post/923bbd1b/7.png" class title="Promise.all()"><h4 id="Promise-race-iterable"><a href="#Promise-race-iterable" class="headerlink" title="Promise.race(iterable)"></a>Promise.race(iterable)</h4><h5 id="参数-3"><a href="#参数-3" class="headerlink" title="参数"></a>参数</h5><p>可迭代对象，一般为包含多个 promise 的数组</p><h5 id="返回值-3"><a href="#返回值-3" class="headerlink" title="返回值"></a>返回值</h5><p>返回一个 promise，只要给定的可迭代对象中的 promise 有一个<strong>先完成</strong>（成功或失败），就采用它的值作为最终 promise 的值，状态与这个完成的 promise 相同。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;p1 resolve!&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">resolve</span>(<span class="string">&#x27;p2 resolve!&#x27;</span>)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="title class_">Promise</span>.<span class="title function_">race</span>([p1, p2])</span><br><span class="line"></span><br><span class="line">p.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;).<span class="title function_">catch</span>(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(err);<span class="comment">// 结果：打印p2 resolve!</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><p>参考链接：<a href="https://blog.csdn.net/weixin_50539249/article/details/137375144">Promise【一篇搞懂】_promise详解-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发范畴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JavaScript狂补知识第②弹】JS模块化</title>
      <link href="/post/17a6587a.html"/>
      <url>/post/17a6587a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是模块化？"><a href="#什么是模块化？" class="headerlink" title="什么是模块化？"></a>什么是模块化？</h3><ol><li><p>模块化指的是按照一定的规则，将大文件拆分成多个相互依赖的小模块。</p></li><li><p>模块之间都是相互隔离独立的，模块中的数据都是私有的，可以通过导出手段把模块中的数据、函数等导出供其他模块使用，通过导入实现模块间数据、函数的共享。</p></li></ol><h3 id="为什么需要模块化？"><a href="#为什么需要模块化？" class="headerlink" title="为什么需要模块化？"></a>为什么需要模块化？</h3><p>随着编写应用的复杂性越来越高，如果不进行模块化，会逐渐出现全局污染、依赖混乱、数据安全等问题：</p><ol><li>全局污染</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// news.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTodayData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="string">&#x27;N001&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;新闻01&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="string">&#x27;N002&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;新闻02&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="string">&#x27;N003&#x27;</span>, <span class="attr">title</span>: <span class="string">&#x27;新闻03&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// weather.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getTodayData</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="string">&#x27;W001&#x27;</span>, <span class="attr">weather</span>: <span class="string">&#x27;天气01&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="string">&#x27;W002&#x27;</span>, <span class="attr">weather</span>: <span class="string">&#x27;天气02&#x27;</span> &#125;,</span><br><span class="line">        &#123; <span class="attr">id</span>: <span class="string">&#x27;W003&#x27;</span>, <span class="attr">weather</span>: <span class="string">&#x27;天气03&#x27;</span> &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.html</span></span><br><span class="line">&lt;!<span class="variable constant_">DOCTYPE</span> html&gt;</span><br><span class="line">&lt;html lang=&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset=&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</span><br><span class="line">    &lt;title&gt;Document&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;./news.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">    &lt;script type=&quot;text/javascript&quot; src=&quot;./weather.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>通过在F12控制台中调用getTodayData函数我们发现最后返回的是天气的数据，因为weather.js是后引入的，会同名覆盖，这就是所谓的全局污染问题，因为通过这种引入方式我们把对应js文件的函数、数据等都放到了window这个全局对象中去了，导致全局污染问题。</p><ol start="2"><li>依赖混乱</li></ol><p>对于通过<code>&lt;script type=&quot;text/javascript&quot; src=&quot;xxx.js&quot;&gt;&lt;/script&gt;</code>这一引入方式的项目，由于可能项目本身需要很多依赖，而不同依赖可能有依赖另一个依赖，因此如果引入的顺序不同可能就导致了项目本身出现问题，即所谓的依赖混乱。</p><ol start="3"><li>数据安全</li></ol><p>对于通过<code>&lt;script type=&quot;text/javascript&quot; src=&quot;xxx.js&quot;&gt;&lt;/script&gt;</code>这一引入方式的项目，会把对应js所有数据都放在window对象中，因此可能会泄露一些敏感的用户信息，导致出现数据安全问题。</p><h3 id="常见的模块化规范"><a href="#常见的模块化规范" class="headerlink" title="常见的模块化规范"></a>常见的模块化规范</h3><ol><li>CommonJS —— 服务端应用广泛</li><li>AMD</li><li>CMD</li><li>ES6 —— 浏览器端应用广泛</li></ol><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><p>在CommonJS规范中，在一个js文件导出数据、方法有两种方式：</p><ol><li>module.exports = { }</li><li>exports.xxx = xxx</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> username = <span class="string">&#x27;小张&#x27;</span></span><br><span class="line"><span class="keyword">const</span> token = <span class="string">&#x27;&lt;&lt;token&gt;&gt;&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getAge</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出方式一</span></span><br><span class="line"><span class="built_in">exports</span>.<span class="property">username</span> = username</span><br><span class="line"><span class="built_in">exports</span>.<span class="property">getAge</span> = getAge</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导出方式二</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    username,</span><br><span class="line">    getAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述两种方式，打印导出的内容均为<code>&#123; username: &#39;小张&#39;, getAge: [Function: getAge] &#125;</code>。</p><blockquote><p>exports和module.exports的区别：</p><ol><li>谨记一条原则：无论使用 exports 导出成员，或是 module.exports 导出成员，最终导出的结果，都是以 module.exports 所指向的对象为准。</li><li>exports是对module.exports的一个引用变量，两者在最初均指向同一个空对象，exports的写法是为了方便给导出对象添加属性，不能使用exports = value的方式导出数据和方法，因为这样直接改变了exports这个变量的指向，module.exports的内容并没有改变。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> username = <span class="string">&#x27;小张&#x27;</span></span><br><span class="line"><span class="keyword">const</span> token = <span class="string">&#x27;&lt;&lt;token&gt;&gt;&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">getAge</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span> = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="comment">// 最后导出的对象为空</span></span><br></pre></td></tr></table></figure></blockquote><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><p>通过<code>require</code>可以导入对应文件的module.exports对象，可以直接利用一个变量接收，也可以对导入结果进行解构。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入方式一</span></span><br><span class="line"><span class="keyword">const</span> user = <span class="built_in">require</span>(<span class="string">&#x27;./user.js&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入方式二：解构</span></span><br><span class="line"><span class="keyword">const</span> &#123; username, getAge &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./user.js&#x27;</span>)</span><br><span class="line"><span class="comment">// 导入方式三：解构的同时重命名</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="attr">username</span>: name, <span class="attr">getAge</span>: getUserAge &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./user.js&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="扩展理解"><a href="#扩展理解" class="headerlink" title="扩展理解"></a>扩展理解</h3><p>在CommonJS规范中，每个模块在执行时是把js文件所写的内容包裹在一个<strong>内置函数</strong>中执行的，每个模块都有自己的作用域，即所谓的数据隔离，可以通过<code>console.log(arguments.callee.toString())</code>来进行验证：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> (<span class="params"><span class="built_in">exports</span>, <span class="built_in">require</span>, <span class="variable language_">module</span>, __filename, __dirname</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> username = <span class="string">&#x27;小张&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> token = <span class="string">&#x27;&lt;&lt;token&gt;&gt;&#x27;</span></span><br><span class="line">    <span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">getAge</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">return</span> age</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">        username,</span><br><span class="line">        getAge</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>.<span class="property">callee</span>.<span class="title function_">toString</span>())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>CommonJS是适合在服务端的模块化，如果想在浏览器端使用，需要使用Browserify这一工具来预编译使用CommonJS模块化规范编写的JS文件，最后即可将预编译完的JS文件引入html中使用。</p></blockquote><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>ES6是支持在浏览器端和服务端的模块化规范，默认是支持浏览器端，如果想支持服务端有两种方式：</p><ol><li><p>将js文件后缀改为mjs即可</p></li><li><p>在项目根目录下添加package.json文件，内容如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;type&quot;</span><span class="punctuation">:</span> <span class="string">&quot;module&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="导出-1"><a href="#导出-1" class="headerlink" title="导出"></a>导出</h3><ol><li><p>分别导出：在需要导出的数据或者方法前添加export关键字</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> username = <span class="string">&#x27;小张&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> motto = <span class="string">&#x27;相信明天会更好&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>统一导出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> username = <span class="string">&#x27;小张&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line"><span class="keyword">const</span> motto = <span class="string">&#x27;相信明天会更好&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">    username, motto, getAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>默认导出：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> username = <span class="string">&#x27;小张&#x27;</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line"><span class="keyword">const</span> motto = <span class="string">&#x27;相信明天会更好&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getAge</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span>&#123;</span><br><span class="line">    username, motto, getAge</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>对于分别导出、统一导出，最后导出的每一个数据/方法都会作为module的一个属性，而默认导出会使得module多了一个default对象，default对象的内容就是导出的内容，如下图所示：</p><img src="/post/17a6587a/1.png" class title="不同导出方式的结果"><blockquote><p>注意：不同的导出方式可以混合使用</p></blockquote><h3 id="导入-1"><a href="#导入-1" class="headerlink" title="导入"></a>导入</h3><ol><li><p>全部导入：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> user <span class="keyword">from</span> <span class="string">&#x27;./user.js&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>命名导入：通过导入和导出一样的命名这种方式来导入，如果想重命名则需要使用as关键字（针对分别导入、统一导入）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; username <span class="keyword">as</span> name, getAge &#125; <span class="keyword">from</span> <span class="string">&#x27;./user.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">getAge</span>())</span><br></pre></td></tr></table></figure></li><li><p>默认导入：可以用自定义变量名接受默认导出的default对象（针对默认导出）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> user <span class="keyword">from</span> <span class="string">&#x27;./user.js&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(user)</span><br><span class="line"><span class="comment">// &#123; username: &#x27;小张&#x27;, motto: &#x27;相信明天会更好&#x27;, getAge: [Function: getAge] &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>动态导入：导入的结果和全部导入一致，具体的使用可以参考下述例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;module&quot;</span> <span class="attr">src</span>=<span class="string">&quot;./index.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;btn&quot;</span>&gt;</span>导入模块<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">const</span> btn = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;btn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> user = <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">&#x27;./user.js&#x27;</span>)<span class="comment">// import是异步</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(user)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>无绑定导入：如果只是想执行模块中的一些代码，而不需要导入它的任何内容，可以使用无绑定的导入，即import可以不接受任何数据，直接导入一个文件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./log.js&#x27;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="CJS和ES6区别"><a href="#CJS和ES6区别" class="headerlink" title="CJS和ES6区别"></a>CJS和ES6区别</h2><ol><li><p>加载模块方式：CommonJS模块是同步加载的，这意味着在加载模块时，会阻塞代码的执行，直到模块加载完成；ES6模块是异步加载的，这意味着在加载模块时，不会阻塞代码的执行。</p></li><li><p>数据引用：CommonJS导出的是一个值拷贝，会对加载结果进行缓存，一旦内部再修改这个值，不会同步到外部；ES6是导出数据的引用，内部修改可以同步到外部。</p></li><li><p>依赖关系处理：CommonJS对模块依赖的解决是“动态的”而ES6是“静态的”。在这里“动态的”含义是，模块依赖关系的建立发生在代码运行阶段；而“静态”则是模块依赖关系的建立发生在代码编译阶段。</p></li></ol><blockquote><p>ES5和ES6的一些区别可以参考：<a href="https://blog.csdn.net/mxd01848/article/details/131697945">ES5与ES6语法的区别及优缺点分析_es5和es6语法差异-CSDN博客</a></p></blockquote><h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>对于AMD和CMD两种方式现在貌似用的比较少了，这里就不过多叙述（狗头.jpg</p>]]></content>
      
      
      <categories>
          
          <category> 开发范畴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【JavaScript狂补知识第①弹】变量提升</title>
      <link href="/post/9235c133.html"/>
      <url>/post/9235c133.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于本蒟蒻当初学习JS的时候只是了解了一下基础的，之后直接干Vue去了，对JS挺多知识点都不了解，趁着暑假有时间补补知识点（</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>变量提升是当栈内存作用域形成时，JS代码执行前，浏览器会将带有var, function关键字的变量<strong>提前</strong>进行声明 (值默认就是 undefined)，定义 (就是赋值操作)，这种预先处理的机制就叫做变量提升机制也叫预定义。</p><p>在变量提升阶段：带 var 的只声明还没有被定义，带 function 的已经声明和定义。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name)<span class="comment">// 输出undefined</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;煎bingo子&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>()<span class="comment">// 输出Function Scuccess!</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Function Scuccess!&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是：变量提升只发生在当前作用域。比如：在页面开始加载时，只有window全局作用域发生变量提升，这时候的函数中存储的都是代码字符串，并不会把函数里面的局部变量提升到全局作用域。</p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">out</span>()</span><br><span class="line"><span class="keyword">var</span> out = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;out function&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上述代码浏览器会报错，因为out作为匿名函数，其变量提升后初值为undefined，因此会报错TypeError: out is not a function。</p><h2 id="不同作用域下的var"><a href="#不同作用域下的var" class="headerlink" title="不同作用域下的var"></a>不同作用域下的var</h2><ol><li>对于<strong>window全局作用域</strong>下的var声明的变量，会将其作为属性添加到window对象中去（在全局作用域中若某一变量没有用var声明，和此种情况相同效果）</li><li>对于<strong>私有作用域</strong>（函数内部）中仅会对带var声明的变量进行变量提升，其变量声明会提升到其函数的头部。对于不带var的变量<strong>在使用时</strong>会向上级作用域进行查找，直到找到window对象为止，即<strong>JS的作用域链的执行机制</strong></li></ol><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>, b = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> a = b = <span class="number">1</span>  </span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a, b)</span><br></pre></td></tr></table></figure><p>对于上述代码在浏览器控制台输出如下图所示，同时为了验证全局作用域下的声明的变量是作为属性添加到window中还输出了window对象：</p><img src="/post/9235c133/1.png" class title="示例输出"><h3 id="示例4"><a href="#示例4" class="headerlink" title="示例4"></a>示例4</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"></span><br><span class="line">    a = <span class="number">1</span>;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">func</span>()</span><br></pre></td></tr></table></figure><p>对于上述代码，浏览器会抛出ReferenceError: a is not defined的错误，因为func作用域中并没有var声明的变量，也就没有所谓的变量提升，在打印a的时候，会触发JS的作用域链的执行机制，但是一直查找到window对象都没有对应的a值，因此抛出错误。</p><h2 id="条件判断中的变量提升"><a href="#条件判断中的变量提升" class="headerlink" title="条件判断中的变量提升"></a>条件判断中的变量提升</h2><ol><li>对于条件判断语句中的var声明，无论条件是否成立均会进行变量提升，但是赋值操作仍然是需要对应条件成立才可以进行。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b)  <span class="comment">// undefinded</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> b = <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><ol start="2"><li>对于条件判断中判断表达式部分的内容不会进行变量提升，同时条件作用域内部如果有function声明，则变量提升时和作为匿名函数赋值给一个变量情况相同，只有在条件成立时才会进行函数定义（并且是先定义再执行内部的其他语句，可以参考示例6），不成立则为undefinded</li></ol><h3 id="示例5"><a href="#示例5" class="headerlink" title="示例5"></a>示例5</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;test-&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">function</span> <span class="title function_">f</span>(<span class="params"></span>) &#123; &#125;) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> f)</span><br><span class="line"></span><br><span class="line">    a = a + <span class="keyword">typeof</span> f</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">false</span>)&#123;</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">out</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;out function&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">out</span>()</span><br></pre></td></tr></table></figure><p>上述代码的输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">undefined</span><br><span class="line">test-undefined</span><br><span class="line">Uncaught TypeError: out is not a function</span><br></pre></td></tr></table></figure><h3 id="示例6"><a href="#示例6" class="headerlink" title="示例6"></a>示例6</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="title function_">out</span>()</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">out</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Out Function!&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">out</span>()</span><br></pre></td></tr></table></figure><p>上述代码输出如下：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Out Function!</span><br><span class="line">Out Function!</span><br></pre></td></tr></table></figure><h2 id="变量提升的重名问题"><a href="#变量提升的重名问题" class="headerlink" title="变量提升的重名问题"></a>变量提升的重名问题</h2><ol><li>如果对于某一个变量名既有var声明又由function声明，function优先，即该变量会作为function进行变量提升。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a)   <span class="comment">// function</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a)   <span class="comment">// number</span></span><br></pre></td></tr></table></figure><ol start="2"><li>变量重名在变量提升阶段如果有多个会按照顺序重复定义</li></ol><h3 id="示例7"><a href="#示例7" class="headerlink" title="示例7"></a>示例7</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;1&#x27;</span>, <span class="title function_">fn</span>())</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;2&#x27;</span>, <span class="title function_">fn</span>())</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;3&#x27;</span>, <span class="title function_">fn</span>())</span><br><span class="line"><span class="keyword">var</span> fn = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;4&#x27;</span>, <span class="title function_">fn</span>())</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">3</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码的输出如下图所示：</p><img src="/post/9235c133/2.png" class title="示例输出"><h2 id="函数形参的变量提升"><a href="#函数形参的变量提升" class="headerlink" title="函数形参的变量提升"></a>函数形参的变量提升</h2><ol><li><p>函数的形参也会进行一次变量提升。</p></li><li><p>形参阶段声明的变量，即使函数内部还有同名变量也不会再次声明。</p></li></ol><h3 id="示例8"><a href="#示例8" class="headerlink" title="示例8"></a>示例8</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">func</span>(<span class="params">a</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    <span class="keyword">var</span> a</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">func</span>(a)<span class="comment">// 1 1</span></span><br></pre></td></tr></table></figure><p>在函数的形参阶段，会先声明var a = undefined，a = 1，因此第一次打印1，后续出现同名变量a不会再次声明，因此打印还是1。</p><h3 id="示例9"><a href="#示例9" class="headerlink" title="示例9"></a>示例9</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">&#x27;test1&#x27;</span>;</span><br><span class="line">(<span class="keyword">function</span>(<span class="params">f</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    <span class="keyword">var</span> a = f || <span class="string">&#x27;test2&#x27;</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">&#125;)(a)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line"></span><br><span class="line"><span class="comment">//undefined</span></span><br><span class="line"><span class="comment">//test1</span></span><br><span class="line"><span class="comment">//test1</span></span><br></pre></td></tr></table></figure><p>在立即执行的函数表达式（IIFE）的形参阶段，先声明了var f = undefined，f = a（这里的a是全局的），并且变量提升会声明var a = undefined（这里的a是函数私有域的）。因此第一次打印为undefined，后面私有域的a被赋值为f即全局的a的值test1，因此第二次打印结果为test1，最后打印全局的a的值，还是test1。</p><h2 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h2><ol><li>IIFE匿名执行函数和非匿名自执行函数在全局环境下不具备变量提升的机制。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(c);</span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">c</span>(<span class="params"></span>)&#123;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// ReferenceError: c is not defined</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>匿名自执行函数在自己的作用域内存在正常的变量提升。（示例9）</p></li><li><p>非匿名自执行函数的函数名在自己的作用域内变量提升，且修改函数名的值无效。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span>;</span><br><span class="line">(<span class="keyword">function</span> <span class="title function_">a</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a)</span><br><span class="line">    a = <span class="number">20</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a)</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> a);</span><br><span class="line"><span class="comment">// function</span></span><br><span class="line"><span class="comment">// function</span></span><br><span class="line"><span class="comment">// number</span></span><br></pre></td></tr></table></figure><hr><p>参考链接：<a href="https://juejin.cn/post/6933377315573497864#heading-12">彻底解决 JS 变量提升| 一题一图，超详细包教包会😉 - 掘金 (juejin.cn)</a></p>]]></content>
      
      
      <categories>
          
          <category> 开发范畴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vite + Vue3 + TypeScript 项目创建从0到1配置</title>
      <link href="/post/798d154e.html"/>
      <url>/post/798d154e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="VITE构建基础项目模板"><a href="#VITE构建基础项目模板" class="headerlink" title="VITE构建基础项目模板"></a>VITE构建基础项目模板</h2><ol><li>终端执行命令<code>npm init vite@latest</code>新建项目，选择Vue+Typescript</li><li>之后cd进入项目文件夹执行<code>npm install</code>则本步骤完成</li></ol><h2 id="环境变量配置优化"><a href="#环境变量配置优化" class="headerlink" title="环境变量配置优化"></a>环境变量配置优化</h2><ol><li>在项目根目录下新建env文件加存放不同环境需求下的环境变量信息：.env文件、.env.development文件、.env.production文件……对于更大的项目可能还有测试环境下的环境变量文件</li></ol><ul><li>.env公共的环境变量信息</li><li>.env.production生产环境下的环境变量信息</li><li>.env.development开发环境下的环境变量信息</li></ul><blockquote><p>注意：</p><ol><li>因为是新建env文件夹，所以需要在vite.config.ts文件中的config对象中添加envDir: ‘env’</li><li>对于环境变量文件中的环境变量名必须以VITE开头，否则需要额外说明</li></ol></blockquote><ol start="2"><li>在package.json添加命令<code>&quot;dev-prod&quot;: &quot;vite serve --mode production&quot;</code>可用来测试生产环境下的环境变量文件</li></ol><h2 id="优化生产构建后console和debugger关闭"><a href="#优化生产构建后console和debugger关闭" class="headerlink" title="优化生产构建后console和debugger关闭"></a>优化生产构建后console和debugger关闭</h2><ol><li>在vite.config.ts文件中的config对象中添加以下内容</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="comment">// 如果出现npm run build失败可能需要安装一下terser：npm i terser -D</span></span><br><span class="line">    <span class="attr">minify</span>: <span class="string">&quot;terser&quot;</span>,</span><br><span class="line">    <span class="attr">terserOptions</span>: &#123;</span><br><span class="line">        <span class="attr">compress</span>: &#123;</span><br><span class="line">            <span class="attr">drop_console</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">drop_debugger</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果build构建后的用于测试，可能测试环境下需要console等，就参考下面的代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig, loadEnv &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(<span class="function">(<span class="params">&#123; command, mode, ssrBuild &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> env = <span class="title function_">loadEnv</span>(mode, <span class="string">`<span class="subst">$&#123;process.cwd()&#125;</span>/env`</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="comment">// 为什么要这样做，是为了 process.env和mode一致性</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">assign</span>(process.<span class="property">env</span>, env, &#123; <span class="attr">NODE_ENV</span>: mode &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    mode,</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">      <span class="attr">minify</span>: <span class="string">&quot;terser&quot;</span>, <span class="comment">// 必须开启：使用 terserOptions 才有效果</span></span><br><span class="line">  <span class="attr">terserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">compress</span>: &#123;</span><br><span class="line">      <span class="attr">drop_console</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="literal">true</span> : <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">drop_debugger</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="literal">true</span> : <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="优化文件引用路径"><a href="#优化文件引用路径" class="headerlink" title="优化文件引用路径"></a>优化文件引用路径</h2><ol><li>在vite.config.ts文件的config对象添加下列代码</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;resolve&#125; <span class="keyword">from</span> <span class="string">&quot;path&quot;</span>; <span class="comment">// 需要import</span></span><br><span class="line"><span class="comment">// 下面代码加入config对象中</span></span><br><span class="line"><span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&quot;@&quot;</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ol start="2"><li>如果添加上述代码后发现使用@方式引入组件依然报错，则在vite-env.d.ts文件中添加下列代码</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;*.vue&#x27;</span> &#123;</span><br><span class="line">    <span class="keyword">import</span> <span class="keyword">type</span> &#123;<span class="title class_">DefineComponent</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">component</span>: <span class="title class_">DefineComponent</span>&lt;&#123;&#125;, &#123;&#125;, <span class="built_in">any</span>&gt;;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> component;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置CSS全局变量"><a href="#配置CSS全局变量" class="headerlink" title="配置CSS全局变量"></a>配置CSS全局变量</h2><ol><li>使用scss作为css预处理器，先安装相关依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i sass sass-loader --save-dev</span><br></pre></td></tr></table></figure><ol start="2"><li>对于一些全局css变量可以在src下建立全局css文件global.scss，然后在vite.config.js文件中的config对象添加配置</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">css</span>: &#123;</span><br><span class="line"><span class="comment">// css预处理器</span></span><br><span class="line">    <span class="attr">preprocessorOptions</span>: &#123;</span><br><span class="line">      <span class="attr">scss</span>: &#123;</span><br><span class="line">        <span class="attr">additionalData</span>: <span class="string">&#x27;@import &quot;@/assets/style/global.scss&quot;;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由vue-router配置"><a href="#路由vue-router配置" class="headerlink" title="路由vue-router配置"></a>路由vue-router配置</h2><ol><li>安装依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router@4</span><br></pre></td></tr></table></figure><ol start="2"><li>在src文件夹下新建router文件下，并在router文件夹下新建index.ts，内容如下，然后记得在main.ts挂载到app之前添加use(router)</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createRouter, createWebHashHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HomeView</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/HomeView.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">HomeView</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 无匹配页面则跳转到404</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/:pathMatch(.*)*&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;NotFound&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/NotFoundView.vue&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">        <span class="attr">routes</span>: routes,</span><br><span class="line">        <span class="comment">// 在导航栏中，为当前活动路由的菜单项添加类名</span></span><br><span class="line">        <span class="attr">linkActiveClass</span>: <span class="string">&#x27;router-active&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><blockquote><p>说明：在组件内部可以通过 <code>useRouter()</code> 和 <code>useRoute()</code> 来访问路由器实例和当前路由</p></blockquote><ol start="3"><li>在router文件下创建createRouteGuards.ts用作全局路由守卫配置，并在router/index.ts里面export router之前调用createRouteGuards(router)</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Router</span>&#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createRouteGuards</span> = (<span class="params">router: Router</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// @ts-ignore</span></span><br><span class="line">    router.<span class="title function_">beforeEach</span>(<span class="keyword">async</span> (to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态管理库Pinia配置"><a href="#状态管理库Pinia配置" class="headerlink" title="状态管理库Pinia配置"></a>状态管理库Pinia配置</h2><ol><li>老规矩先安装依赖，后面是持久化插件（保证页面刷新的时候缓存不会刷新</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pinia pinia-plugin-persistedstate</span><br></pre></td></tr></table></figure><ol start="2"><li>在src下面新建文件夹store，再新建文件index.ts，代码如下，然后记得在main.ts挂载到app之前添加use(store)</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">import</span> piniaPluginPersistedstate <span class="keyword">from</span> <span class="string">&#x27;pinia-plugin-persistedstate&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createPinia</span>()</span><br><span class="line"><span class="comment">// 使用持久化插件</span></span><br><span class="line">store.<span class="title function_">use</span>(piniaPluginPersistedstate)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><ol start="3"><li>可能状态管理可能会分模块，比如用户认证相关、平台基本信息相关，因此可以在store文件夹下新建modules文件夹，每个不同模块一个单独的ts文件，比如下面的useUserStore.ts(一般以use开头)，具体使用参考<a href="https://pinia.web3doc.top/">Home | Pinia 中文文档 (web3doc.top)</a></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useUserStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;user&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// 推荐使用完整类型推断的箭头函数</span></span><br><span class="line">    <span class="attr">state</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">username</span>: <span class="string">&#x27;2aurora2&#x27;</span>,</span><br><span class="line">            <span class="attr">counter</span>: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 状态的计算值computed, 无法向它们传递任何参数; 但是，可以从 getter 返回一个函数以接受任何参数</span></span><br><span class="line">    <span class="attr">getters</span>: &#123;</span><br><span class="line">        <span class="attr">addCounter</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> state.<span class="property">counter</span> += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 相当于组件的methods</span></span><br><span class="line">    <span class="attr">actions</span>: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 启用插件</span></span><br><span class="line">    <span class="attr">persist</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="网络请求AXIOS配置"><a href="#网络请求AXIOS配置" class="headerlink" title="网络请求AXIOS配置"></a>网络请求AXIOS配置</h2><ol><li>老规矩先安装对应依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><ol start="2"><li>将axios的相关配置和请求方式的封装写在src/utils/http下，新建instance.ts文件和service.ts文件</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instance.ts</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> axiosInstance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">VITE_PROXY_URL</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">10</span> * <span class="number">1000</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">axiosInstance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line"><span class="comment">// 2xx 范围内的状态码都会触发该函数</span></span><br><span class="line">axiosInstance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axiosInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// service.ts</span></span><br><span class="line"><span class="keyword">import</span> axiosInstance <span class="keyword">from</span> <span class="string">&quot;./instance.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">get</span> = (<span class="params">url: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> axiosInstance.<span class="title function_">get</span>(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">post</span> = (<span class="params">url: <span class="built_in">string</span>, data?: <span class="built_in">Object</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> axiosInstance.<span class="title function_">post</span>(url, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    get,</span><br><span class="line">    post</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>所有与后端交互的接口信息在src文件夹下另开一个文件夹api，api文件夹下新建index.ts文件、type.ts文件和不同模块文件夹</li></ol><ul><li>index.ts导出不同模块的相关接口</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> userApi <span class="keyword">from</span> <span class="string">&#x27;./user&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    userApi,     <span class="comment">// 用户相关API</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>type.ts定义一些公共类型，如后端的返回值类型</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">ResponseResult</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="attr">code</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">message</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">data</span>: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分模块文件夹代表一个模块，每个模块文件夹下均为index.ts和type.ts文件</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// api/user/index.ts</span></span><br><span class="line"><span class="keyword">import</span> service <span class="keyword">from</span> <span class="string">&quot;@/utils/http/service.ts&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">ResponseResult</span>&#125; <span class="keyword">from</span> <span class="string">&quot;@/api/type.ts&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">LoginReqType</span>, <span class="title class_">LoginResType</span>&#125; <span class="keyword">from</span> <span class="string">&quot;@/api/user/type.ts&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">login</span> = (<span class="params">data: LoginReqType</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> service.<span class="property">post</span>&lt;<span class="title class_">ResponseResult</span>&lt;<span class="title class_">LoginResType</span>&gt;&gt;(<span class="string">&#x27;/user/login&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;?email=&#x27;</span> + data.<span class="property">email</span> +</span><br><span class="line">        <span class="string">&#x27;&amp;password=&#x27;</span> + data.<span class="property">password</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    login,               <span class="comment">// 用户登录</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// api/user/type.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">LoginReqType</span> = &#123;</span><br><span class="line">    <span class="attr">email</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">password</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">LoginResType</span> = &#123;</span><br><span class="line">    <span class="attr">token</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">expirationTime</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><ol><li>在src下新建types/index.ts用来描述全局自定义类型export type……</li><li>在src下新建const/index.ts用来定义常量，将常量定义在一个对象里面然后导出</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">CONST</span> = &#123;</span><br><span class="line">    <span class="attr">PI</span>: <span class="number">3.14159</span>,</span><br><span class="line">    <span class="attr">GRAVITY</span>: <span class="number">9.81</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>后续如果有其他会继续补充……</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发范畴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vite </tag>
            
            <tag> Vue </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性回归(linear regression)</title>
      <link href="/post/linear_regression.html"/>
      <url>/post/linear_regression.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>在统计学中，线性回归（Linear Regression）是利用称为线性回归方程的最小平方函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。线性回归按自变量的个数分为2种：</p><ul><li>简单线性回归：只有一个自变量</li><li>多元线性回归：自变量的个数大于等于两个</li></ul><h3 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h3><p>在一般情况下，假设有$p$个自变量，$y$为因变量，设：<br>$$<br>y=\beta_0+\beta_1x_1+\cdots+\beta_px_p<br>$$<br>在模型构建过程中，利用 $y$ 与 $x_1, \cdots, x_p$ 的训练数据来估计$\beta_0$与$\beta_1, \cdots, \beta_p$得到：<br>$$<br>\hat{y}=\hat{\beta_0}+\hat{\beta_1}x_1+\cdots+\hat{\beta_p}x_p\<br>$$</p><p>$$<br>\hat{y}=\left[<br>\begin{matrix}<br>1 &amp; x_1 &amp; \cdots &amp; x_p\<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>\hat{\beta_0} \<br>\vdots \<br>\hat{\beta_p}<br>\end{matrix}<br>\right]=X*W(W是列向量)<br>$$</p><h3 id="拟合方程"><a href="#拟合方程" class="headerlink" title="拟合方程"></a>拟合方程</h3><blockquote><p>线性回归的<strong>损失函数</strong>一般由最小二乘法求得</p></blockquote><h4 id="最小二乘法-ordinary-least-squares"><a href="#最小二乘法-ordinary-least-squares" class="headerlink" title="最小二乘法(ordinary least squares)"></a>最小二乘法(ordinary least squares)</h4><p>最小二乘法的主要思想是通过确定未知参数（通常是一个参数矩阵），来使得真实值和预测值的误差（也称残差）平方和最小，其计算公式为：<br>$$<br>E=\sum_{i=1}^n(y_i-\hat{y_i})^2<br>$$<br>其中$y_i$是真实值，$\hat{y_i}$是对应的预测值，图示如下：（橙色线即为误差）</p><img src="/post/linear_regression/1.png" class title="ordinary least squares"><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>由最小二乘法可得线性回归得损失函数为：<br>$$<br>J(W)=\sum_{i=1}^n(y_i-\hat{y_i})^2=\sum_{i=1}^n(y_i-X_i*W)^2<br>$$</p><p>要使得损失函数最小，可以将损失函数作为多元函数处理，下面给出一维特征（自变量仅有一个的情况）的损失函数最小求解：（设线性回归方程为：$\hat{y}=\hat{\beta_0}+\hat{\beta_1}x$）<br>$$<br>\hat{\beta_0}=\frac{\sum_{i=1}^{m}\left(x^{(i)}\right)^{2} \sum_{i=1}^{m} y^{(i)}-\sum_{i=1}^{m} x^{(i)} \sum_{i=1}^{m} x^{(i)} y^{(i)}}{m \sum_{i=1}^{m}\left(x^{(i)}\right)^{2}-\left(\sum_{i=1}^{m} x^{(i)}\right)^{2}}<br>$$</p><p>$$<br>\hat{\beta_1}=\frac{m\sum\limits_{i=1}^{m}x^{(i)}y^{(i)}-\sum\limits_{i=1}^{m}x^{(i)}\sum\limits_{i=1}^{m}y^{(i)}}{m\sum\limits_{i=1}^{m}(x^{(i)})^2-(\sum\limits_{i=1}^{m}x^{(i)})^2}<br>$$</p><h3 id="拟合效果检验"><a href="#拟合效果检验" class="headerlink" title="拟合效果检验"></a>拟合效果检验</h3><p>线性回归一般利用可决系数$R^2$来反映直线的拟合程度，取值范围在[0,1]之间。$R^2\to1$说明回归方程拟合的越好，$R^2\to0$就代表回归方程拟合的越差，其计算公式如下：<br>$$<br>R^2=\frac{\Sigma(\hat y-\overline y)^2}{\Sigma(y-\overline y)^2}<br>$$</p><h3 id="模型练习"><a href="#模型练习" class="headerlink" title="模型练习"></a>模型练习</h3><p><a href="https://www.kaggle.com/code/toaurora/linear-regression/notebook">Linear Regression | Kaggle</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词袋模型 &amp;&amp; 余弦相似度</title>
      <link href="/post/BOW_model.html"/>
      <url>/post/BOW_model.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自然语言处理面临的文本数据往往是非结构化杂乱无章的文本数据，而机器学习算法处理的数据往往是固定长度的输入和输出，因而机器学习并不能直接处理原始的文本数据，必须把文本数据转换成数字，比如向量，这个过程就叫做特征提取或者特征编码。一种流行并且简单的特征提取方法就是词袋模型。</p><h2 id="词袋模型（BOW）"><a href="#词袋模型（BOW）" class="headerlink" title="词袋模型（BOW）"></a>词袋模型（BOW）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>词袋模型(Bag of Words)不考虑文本中词语的顺序，只考虑词表（vocabulary）或者语料库中的词语在这个文本中的出现次数，进而把一个文本转化为向量表示，是比较简单直白的一种特征提取方法。</p><h3 id="模型构建过程"><a href="#模型构建过程" class="headerlink" title="模型构建过程"></a>模型构建过程</h3><p><strong>1. 获取文本数据</strong>（这里以两个文本句子为例）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目的：利用词袋模型得出下列句子的向量表示</span></span><br><span class="line">txts = [<span class="string">&#x27;朋友们喜欢吃饭、睡觉、打豆豆。&#x27;</span>, <span class="string">&#x27;我喜欢吃饭、睡觉。&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>2. 文本分词并构建语料库</strong></p><p>NLP无法处理一整个句子，因此第一步工作往往是分词。中文文本的分词常用的是<strong>jieba分词</strong>，英文文本的分词可以使用NLTK中的<strong>word_tokenize函数</strong>。</p><p>分词后进行语料库的构建，对于语料库的构建要保证语料库里面没有重复的词语或者标点，因而可以使用<strong>set方法</strong>。另外构建语料库后要进行<strong>数字映射</strong>便于后续的向量表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建语料库并进行数字映射</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">construct_word_dict</span>(<span class="params">texts</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param texts: 文本列表</span></span><br><span class="line"><span class="string">    :return: 字典（词语及对应的数字映射）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    words = []</span><br><span class="line">    <span class="keyword">for</span> text <span class="keyword">in</span> texts:</span><br><span class="line">        <span class="comment"># jieba分词</span></span><br><span class="line">        words += jieba.lcut(text)</span><br><span class="line">    <span class="comment"># 去除重复的元素</span></span><br><span class="line">    words = <span class="built_in">set</span>(words)</span><br><span class="line">    <span class="comment"># 建立词与数字的映射</span></span><br><span class="line">    words = <span class="built_in">dict</span>(<span class="built_in">zip</span>(words, <span class="built_in">range</span>(<span class="built_in">len</span>(words))))</span><br><span class="line">    <span class="keyword">return</span> words</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例文本生成的语料库如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;我&#x27;</span>: 0, <span class="string">&#x27;朋友&#x27;</span>: 1, <span class="string">&#x27;打&#x27;</span>: 2, <span class="string">&#x27;豆豆&#x27;</span>: 3, <span class="string">&#x27;吃饭&#x27;</span>: 4, <span class="string">&#x27;。&#x27;</span>: 5, <span class="string">&#x27;们&#x27;</span>: 6, <span class="string">&#x27;、&#x27;</span>: 7, <span class="string">&#x27;喜欢&#x27;</span>: 8, <span class="string">&#x27;睡觉&#x27;</span>: 9&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 建立文本的向量表示</strong></p><p>在这里词袋模型的向量表示是把语料库中单词或标点的出现频数作为其对应的数字表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立文本的向量表示</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vector_rep</span>(<span class="params">text, corpus_dict</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param text: 文本</span></span><br><span class="line"><span class="string">    :param corpus_dict: 语料库</span></span><br><span class="line"><span class="string">    :return: 对应文本的向量表示</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    vec = []</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> corpus_dict.keys():</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> text:</span><br><span class="line">            vec.append((corpus_dict[key], text.count(key)))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            vec.append((corpus_dict[key], <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    vec = <span class="built_in">sorted</span>(vec, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vec</span><br></pre></td></tr></table></figure><p>示例文本对应的向量表示如下：（每一个元组里面第一个值是语料库某个词的数字映射，第二个值是其出现的频数）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#x27;朋友们喜欢吃饭、睡觉、打豆豆。&#x27;的向量表示</span></span><br><span class="line">[(0, 0), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 2), (9, 1)]</span><br><span class="line"><span class="comment"># &#x27;我喜欢吃饭、睡觉。&#x27;的向量表示</span></span><br><span class="line">[(0, 1), (1, 0), (2, 1), (3, 1), (4, 1), (5, 0), (6, 1), (7, 0), (8, 1), (9, 0)]</span><br></pre></td></tr></table></figure><h3 id="模型应用与缺点"><a href="#模型应用与缺点" class="headerlink" title="模型应用与缺点"></a>模型应用与缺点</h3><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>通过词袋模型得到的文本的向量表示可以利用<strong>余弦相似度</strong>的方法来判断句子相似度</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>没有考虑词序以及词之间的联系，容易丢失了重要信息；</li><li>随着语料库的增大，一个文本的向量表示可能是一个非常稀疏的高维向量，严重影响内存和计算资源；</li><li>词袋模型严重缺乏相似词之间的表达，比如对于 ‘ 我喜欢北京 ’ 和 ‘ 我不喜欢北京 ‘这两个句子的是不相似的，但依据词袋模型得到的向量表示利用余弦相似度的方法所求的相似度较高。</li></ol><h2 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h2><p>余弦相似度，也称为余弦距离，是用向量空间中两个向量夹角的余弦值作为衡量两个个体间差异的大小的度量，其计算公式及对应的python实现如下：</p><img src="/post/BOW_model/cos.png" class title="math"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 余弦相似度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">similarity_with_2_txts</span>(<span class="params">vec1, vec2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param vec1: 文本1的向量表示（这里的向量形式是词袋模型所得到的向量表示形式）</span></span><br><span class="line"><span class="string">    :param vec2: 文本2的向量表示</span></span><br><span class="line"><span class="string">    :return: 两个文本的余弦相似度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    inner_product = <span class="number">0</span></span><br><span class="line">    square_length_vec1 = <span class="number">0</span></span><br><span class="line">    square_length_vec2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> tup1, tup2 <span class="keyword">in</span> <span class="built_in">zip</span>(vec1, vec2):</span><br><span class="line">        inner_product += tup1[<span class="number">1</span>] * tup2[<span class="number">1</span>]</span><br><span class="line">        square_length_vec1 += tup1[<span class="number">1</span>] ** <span class="number">2</span></span><br><span class="line">        square_length_vec2 += tup2[<span class="number">1</span>] ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner_product / sqrt(square_length_vec1 * square_length_vec2)</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2023/5/7 20:23</span></span><br><span class="line"><span class="comment"># @Author  : aurora</span></span><br><span class="line"><span class="comment"># @FileName: BOW_Model.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="comment"># @Blog    ：https://2aurora2.github.io/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建语料库并进行数字映射</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">construct_word_dict</span>(<span class="params">texts</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param texts: 文本列表</span></span><br><span class="line"><span class="string">    :return: 字典（词语及对应的数字映射）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    words = []</span><br><span class="line">    <span class="keyword">for</span> text <span class="keyword">in</span> texts:</span><br><span class="line">        <span class="comment"># jieba分词</span></span><br><span class="line">        words += jieba.lcut(text)</span><br><span class="line">    <span class="comment"># 去除重复的元素</span></span><br><span class="line">    words = <span class="built_in">set</span>(words)</span><br><span class="line">    <span class="comment"># 建立词与数字的映射</span></span><br><span class="line">    words = <span class="built_in">dict</span>(<span class="built_in">zip</span>(words, <span class="built_in">range</span>(<span class="built_in">len</span>(words))))</span><br><span class="line">    <span class="keyword">return</span> words</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立文本的向量表示</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vector_rep</span>(<span class="params">text, corpus_dict</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param text: 文本</span></span><br><span class="line"><span class="string">    :param corpus_dict: 语料库</span></span><br><span class="line"><span class="string">    :return: 对应文本的向量表示</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    vec = []</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> corpus_dict.keys():</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> text:</span><br><span class="line">            vec.append((corpus_dict[key], text.count(key)))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            vec.append((corpus_dict[key], <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    vec = <span class="built_in">sorted</span>(vec, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 余弦相似度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">similarity_with_2_txts</span>(<span class="params">vec1, vec2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param vec1: 文本1的向量表示</span></span><br><span class="line"><span class="string">    :param vec2: 文本2的向量表示</span></span><br><span class="line"><span class="string">    :return: 两个文本的余弦相似度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    inner_product = <span class="number">0</span></span><br><span class="line">    square_length_vec1 = <span class="number">0</span></span><br><span class="line">    square_length_vec2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> tup1, tup2 <span class="keyword">in</span> <span class="built_in">zip</span>(vec1, vec2):</span><br><span class="line">        inner_product += tup1[<span class="number">1</span>] * tup2[<span class="number">1</span>]</span><br><span class="line">        square_length_vec1 += tup1[<span class="number">1</span>] ** <span class="number">2</span></span><br><span class="line">        square_length_vec2 += tup2[<span class="number">1</span>] ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner_product / sqrt(square_length_vec1 * square_length_vec2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">txts = [<span class="string">&#x27;我喜欢北京&#x27;</span>, <span class="string">&#x27;我不喜欢北京&#x27;</span>]</span><br><span class="line"></span><br><span class="line">word_dict = &#123;&#125;</span><br><span class="line">text_vec = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 构建语料库</span></span><br><span class="line">    word_dict = construct_word_dict(txts)</span><br><span class="line">    <span class="comment"># 求出文本的向量表示</span></span><br><span class="line">    <span class="keyword">for</span> txt <span class="keyword">in</span> txts:</span><br><span class="line">        text_vec.append(vector_rep(txt, word_dict))</span><br><span class="line">    <span class="comment"># 利用余弦相似度判断文本相似度</span></span><br><span class="line">    <span class="built_in">print</span>(similarity_with_2_txts(text_vec[<span class="number">0</span>], text_vec[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><blockquote><p>参考文章</p></blockquote><ol><li><p><a href="https://www.cnblogs.com/jclian91/p/9888381.html">NLP入门（一）词袋模型及句子相似度 - 山阴少年 - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://blog.csdn.net/Elenstone/article/details/105134863">词向量之词袋模型(BOW)详解_bow词袋模型_Elenstone的博客-CSDN博客</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTex书写伪代码</title>
      <link href="/post/LaTexCode.html"/>
      <url>/post/LaTexCode.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于美赛和校赛两次数模需要用到伪代码算法的展示，笔者又不想每次通过word的表格去展示伪代码，奈何蒟蒻也不会LaTex，于是想着就用本篇博客来记录LaTex书写伪代码算法的模板以供后续直接在模板的基础上修改。话不多说，直接开搞！</p><h3 id="LaTex在线编辑器"><a href="#LaTex在线编辑器" class="headerlink" title="LaTex在线编辑器"></a>LaTex在线编辑器</h3><blockquote><p><a href="https://cn.overleaf.com/">https://cn.overleaf.com/</a></p></blockquote><h3 id="LaTex伪代码书写模板"><a href="#LaTex伪代码书写模板" class="headerlink" title="LaTex伪代码书写模板"></a>LaTex伪代码书写模板</h3><p>（具体见下方代码以及代码注释）</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\def</span><span class="keyword">\SetClass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\documentclass</span>&#123;<span class="keyword">\SetClass</span>&#125;</span><br><span class="line"><span class="comment">% algorithm2e生成伪代码的包：ruled(三线表样式)、linesnumbered(显示行号)</span></span><br><span class="line"><span class="keyword">\usepackage</span>[ruled,linesnumbered]&#123;algorithm2e&#125;</span><br><span class="line"><span class="comment">% xeCJK中文显示包（记得overleaf网页版在左上角Menu中Compiler改为‘XeLaTex’）</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;xeCJK&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;[H]</span><br><span class="line">  <span class="comment">% 显示end</span></span><br><span class="line">  <span class="keyword">\SetAlgoLined</span></span><br><span class="line">  <span class="comment">% 更改算法编号</span></span><br><span class="line">  <span class="keyword">\renewcommand</span>&#123;<span class="keyword">\thealgocf</span>&#125;&#123;3-1&#125;</span><br><span class="line">  <span class="comment">% 更改算法名字</span></span><br><span class="line">  <span class="keyword">\caption</span>&#123; Algorithm-name &#125;</span><br><span class="line">  <span class="comment">% 输入输出</span></span><br><span class="line">  <span class="keyword">\KwIn</span>&#123; 输入数据 &#125;</span><br><span class="line">  <span class="keyword">\KwOut</span>&#123; 输出数据 &#125;</span><br><span class="line">  <span class="comment">% 放一些数据初始化</span></span><br><span class="line">  Data-Initialization<span class="keyword">\;</span></span><br><span class="line">  <span class="comment">% \tcp:注释</span></span><br><span class="line">  <span class="keyword">\tcp</span>&#123;while语句&#125;</span><br><span class="line">  <span class="comment">% \while&#123;条件&#125;&#123;循环体&#125;</span></span><br><span class="line">  <span class="keyword">\While</span>&#123; word is not the end of the list &#125;&#123;</span><br><span class="line">    <span class="comment">% \;行末添加分号并自动换行</span></span><br><span class="line">    print(word) <span class="keyword">\;</span></span><br><span class="line">    <span class="comment">% \eIf&#123;条件&#125;&#123;肯定语句&#125;&#123;否定语句&#125;</span></span><br><span class="line">    <span class="keyword">\eIf</span>&#123; conditions &#125;&#123;</span><br><span class="line">      go to next section<span class="keyword">\;</span></span><br><span class="line">      current section becomes this one<span class="keyword">\;</span></span><br><span class="line">      &#125;&#123;</span><br><span class="line">      go back to the beginning of current section<span class="keyword">\;</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">% \If&#123;条件&#125;&#123;肯定语句&#125;</span></span><br><span class="line">    <span class="keyword">\If</span>&#123; word is equal to &quot;app&quot; &#125;&#123;</span><br><span class="line">      print(&quot;app is in this list!&quot;)<span class="keyword">\;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">% \For&#123;条件&#125;&#123;循环语句&#125;</span></span><br><span class="line">  <span class="keyword">\For</span>&#123; conditions &#125;&#123;</span><br><span class="line">    satisfy conditions behaviours<span class="keyword">\;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">% 返回值按照算法自行修改</span></span><br><span class="line">  return Summary<span class="keyword">\;</span></span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><img src="/post/LaTexCode/1.png" class title="Final_Show">]]></content>
      
      
      <categories>
          
          <category> 数模学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask操作Mysql数据库</title>
      <link href="/post/flask-pymysql.html"/>
      <url>/post/flask-pymysql.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在学习python的web框架Flask，在了解Flask操作数据库的时候，刚开始是想用Flask-SQLAlchemy这个扩展，但是一直由于版本等其他原因操作失败，今天查了以下pymysql这个库也可以用来操作MySql，浅浅试了一下貌似不错，所以就打算写下这篇博客来记录一下在Flask中如何使用pymysql操作数据库MySql</p><h2 id="PyMySql库"><a href="#PyMySql库" class="headerlink" title="PyMySql库"></a>PyMySql库</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>PyMySQL 是从 Python 连接到 MySQL 数据库服务器的接口，点击<a href="https://pymysql.readthedocs.io/en/latest/user/index.html">用户指南 — PyMySQL 0.7.2 文档</a>查看官方文档</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pymysql</span><br></pre></td></tr></table></figure><h3 id="Flask框架中的使用"><a href="#Flask框架中的使用" class="headerlink" title="Flask框架中的使用"></a>Flask框架中的使用</h3><ol><li><p>文件config.py的配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接MySql数据库的配置</span></span><br><span class="line">DB_CONFIG = &#123;</span><br><span class="line">    <span class="string">&quot;host&quot;</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    <span class="string">&quot;port&quot;</span>: <span class="number">3306</span>,</span><br><span class="line">    <span class="string">&quot;user&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;passwd&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    <span class="string">&quot;db&quot;</span>: <span class="string">&quot;flask&quot;</span>,  <span class="comment"># 数据库要连接的数据库名称</span></span><br><span class="line">    <span class="string">&quot;charset&quot;</span>: <span class="string">&quot;utf8&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将对数据库的常用操作封装成一个类来使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SQLManager</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.conn = <span class="literal">None</span>  <span class="comment"># 初始化连接对象为空</span></span><br><span class="line">        self.cursor = <span class="literal">None</span>  <span class="comment"># 初始化游标对象为空</span></span><br><span class="line">        self.connect()  <span class="comment"># 调用自身连接数据库函数connect</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 连接数据库</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">        self.conn = pymysql.connect(</span><br><span class="line">            host=DB_CONFIG[<span class="string">&quot;host&quot;</span>],</span><br><span class="line">            port=DB_CONFIG[<span class="string">&quot;port&quot;</span>],</span><br><span class="line">            user=DB_CONFIG[<span class="string">&quot;user&quot;</span>],</span><br><span class="line">            passwd=DB_CONFIG[<span class="string">&quot;passwd&quot;</span>],</span><br><span class="line">            db=DB_CONFIG[<span class="string">&quot;db&quot;</span>],</span><br><span class="line">            charset=DB_CONFIG[<span class="string">&quot;charset&quot;</span>]</span><br><span class="line">        )</span><br><span class="line">        self.cursor = self.conn.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 以下的sql参数均为MySql语句</span></span><br><span class="line">    <span class="comment"># fetchall()查询所有符合的数据</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_all</span>(<span class="params">self, sql, args=<span class="literal">None</span></span>):</span><br><span class="line">        self.cursor.execute(sql, args)</span><br><span class="line">        result = self.cursor.fetchall()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="comment"># fetchone()查询单条数据</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_one</span>(<span class="params">self, sql, args=<span class="literal">None</span></span>):</span><br><span class="line">        self.cursor.execute(sql, args)</span><br><span class="line">        result = self.cursor.fetchone()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行单条SQL语句并commit提交（多次操作就要多次提交）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">modify</span>(<span class="params">self, sql, args=<span class="literal">None</span></span>):</span><br><span class="line">        self.cursor.execute(sql, args)</span><br><span class="line">        self.conn.commit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用pymysql的executemany()可以执行多条SQL语句一次提交</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multi_modify</span>(<span class="params">self, sql, args=<span class="literal">None</span></span>):</span><br><span class="line">        self.cursor.executemany(sql, args)</span><br><span class="line">        self.conn.commit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭数据库cursor和连接</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        self.cursor.close()</span><br><span class="line">        self.conn.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过使用with语句可以实现缩进结束自动关闭文件句柄</span></span><br><span class="line">    <span class="comment"># 优化数据库连接类SQLManager类，使其支持with语句操作。</span></span><br><span class="line">    <span class="comment"># 进入with语句自动执行</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 退出with语句块自动执行</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        self.close()</span><br></pre></td></tr></table></figure></li><li><p>常用操作实例</p><ul><li><p>创建表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config.from_object(<span class="string">&#x27;config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实例</span></span><br><span class="line">db = SQLManager()</span><br><span class="line">db.modify(sql=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              CREATE TABLE IF NOT EXISTS `users`(</span></span><br><span class="line"><span class="string">              `id` INT UNSIGNED AUTO_INCREMENT NOT NULL ,</span></span><br><span class="line"><span class="string">              `nickName` VARCHAR(100) NOT NULL UNIQUE ,</span></span><br><span class="line"><span class="string">              `gender` INT UNSIGNED NOT NULL,</span></span><br><span class="line"><span class="string">              `telephone` VARCHAR(100) NOT NULL UNIQUE,</span></span><br><span class="line"><span class="string">              `email` VARCHAR(100) NOT NULL UNIQUE,</span></span><br><span class="line"><span class="string">              PRIMARY KEY ( `id` )</span></span><br><span class="line"><span class="string">              )ENGINE=InnoDB DEFAULT CHARSET=utf8mb4</span></span><br><span class="line"><span class="string">              &quot;&quot;&quot;</span>)</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure></li><li><p>插入操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.modify(sql=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              INSERT INTO `users` </span></span><br><span class="line"><span class="string">              (id, nickName, gender, telephone, email)</span></span><br><span class="line"><span class="string">              VALUES</span></span><br><span class="line"><span class="string">              (0, &#x27;Aurora&#x27;, 1, &#x27;12345678910&#x27;, &#x27;1234567890@qq.com&#x27;)</span></span><br><span class="line"><span class="string">              &quot;&quot;&quot;</span>)</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure></li><li><p>查询操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询操作</span></span><br><span class="line">res = db.get_all(sql=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                    SELECT * FROM users;</span></span><br><span class="line"><span class="string">                    &quot;&quot;&quot;</span>)</span><br><span class="line">db.close()</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><p>发现任何错误欢迎在评论区提出~</p><p>ps：可能由于评论系统的问题导致无法及时回应的话请谅解~</p>]]></content>
      
      
      <categories>
          
          <category> 开发范畴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个微信小程序 —— PuppyHome</title>
      <link href="/post/PuppyHome.html"/>
      <url>/post/PuppyHome.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近一直忙着搞学校的icode比赛所以博客的更新就搁置了qwq，这个icode比赛我们是做一个小程序，而我是负责小程序的前端部分，这篇文章也是来记录一下第一次小程序的经历，技术性的东西估计不会讲太多，可能主要讲本项目如何使用腾讯云的COS对象存储以及一些开发中遇到的坑……</p><hr><h2 id="小程序介绍"><a href="#小程序介绍" class="headerlink" title="小程序介绍"></a>小程序介绍</h2><p>这个小程序是一个用来服务于修勾的平台，主要用户功能有发布、收藏、删除领养公告以及领养自己喜欢的修勾，以及本项目的一大亮点——“拍照识修勾”即用户拍照后平台进行分析得出相似度最高的修勾品种，当然这一困难part主要是后端方面的工作（想看后端介绍的友友可以去友链里面勋哥的博客看）,而我就负责前端的部分，具体小程序以及前端代码的github地址会在项目结束后会放在文章的最后……</p><img src="/post/PuppyHome/introduce.jpg" class title="Layout-Introduce"><h2 id="开发实记"><a href="#开发实记" class="headerlink" title="开发实记"></a>开发实记</h2><blockquote><p>var that = this的声明</p></blockquote><p>如若需要修改data里面的值并渲染到页面一般需要使用this.setData()，但是我们项目起初在调用wx.request()这个API时，在wx.request()里面使用this.setData()会报错，经过查询才知道要在wx.request()前面加上一下声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br></pre></td></tr></table></figure><p>而原因和this的作用域有关：</p><ul><li>在Page({})里面，this关键字指代Page({})整个对象，因此可以通过this关键字访问或者重新设置Page({})里data的变量，但是在wx.request()这个API后this的指向就发生改变就无法使用this来获取Page({})对象</li><li>而解决方法就是在wx.request()外面先把this存在某个变量中即上述声明，此时that指代Page({})整个对象，也就能在wx.request()中使用that来访问Page({})对象</li></ul><blockquote><p>腾讯云COS对象存储介绍</p></blockquote><p>在小程序中难免会碰到上传图片之类的操作，我们这个项目主要是在用户头像、公告发布、拍照识别等会用到图片上传，因为我们在数据库中图片是打算用一个字符串来存储（即图片链接），所以最后选择了腾讯云的COS对象存储，再将得到的图片链接传给后端，接下来就讲讲前期的准备工作</p><ol><li><p>进入腾讯云官网（<a href="https://cloud.tencent.com/">https://cloud.tencent.com</a> ），产品栏找到存储中的对象存储，进入之后点击“立即使用”登录，这里我用的是小程序公众号的方式登录，然后就进入对象存储的控制台界面</p><img src="/post/PuppyHome/enterCloud.png" class title="enterCloud"><img src="/post/PuppyHome/controlPage.png" class title="enterCloud"></li><li><p>创建存储桶</p><img src="/post/PuppyHome/step01.png" class title="Create"><img src="/post/PuppyHome/step02.png" class title="Create"><img src="/post/PuppyHome/step03.png" class title="Create"></li><li><p>进入具体的某个存储桶后可以进行文件的上传，也可以创建文件夹对上传的文件进行分类存放，上传后就可以可以得到对应图片的url链接</p></li><li><p>腾讯云对象存储除了提供多种 API 接口，还提供了丰富多样的 SDK 供开发者使用，这个项目用的就是其中的小程序SDK（<a href="https://cloud.tencent.com/document/product/436/31953">https://cloud.tencent.com/document/product/436/31953</a> ）</p></li></ol><blockquote><p>腾讯云COS对象存储的小程序SDK使用</p></blockquote><ol><li><p>首先是安装小程序SDK，我用的是官网中手动安装的方式（具体可查看官网），并将cos-wx-sdk-v5.js放在utils的目录下</p></li><li><p>小程序里请求 COS 需要登录到 <a href="https://mp.weixin.qq.com/">微信公众平台</a>，选择<strong>开发 &gt; 开发设置 &gt; 服务器域名</strong>，配置域名白名单。SDK 使用到了两个接口：</p><ul><li><p>cos.postObject 使用 wx.uploadFile 方法。</p></li><li><p>其他方法使用 wx. request 方法。</p></li></ul><p>需要在对应白名单里，配置 COS 域名，白名单域名格式有两种：</p><ul><li><p>如果是标准请求，可以配置存储桶域名作为白名单域名，例如：<code>https://examplebucket-1250000000.cos.ap-guangzhou.myqcloud.com</code>  （<strong>本项目使用这个</strong>）</p></li><li><p>如果小程序使用的存储桶多，可以选择后缀式请求 COS，只需要在 SDK 实例化时传入<code>ForcePathStyle: true</code>，这种方式需要配置地域域名作为白名单，例如：<code>cos.ap-guangzhou.myqcloud.com</code>。</p></li></ul><img src="/post/PuppyHome/settings.png" class title="settings"></li><li><p>初始化及其配置：官网介绍了四种方式，本项目使用的是比较简便的格式4，在需要使用上传图片的页面js中进行cos的初始化及其配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">COS</span> = <span class="built_in">require</span>(<span class="string">&#x27;../../../utils/cos-wx-sdk-v5.js&#x27;</span>); <span class="comment">//注意路径按照自己的更改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 COS SDK 实例</span></span><br><span class="line"><span class="comment">// SECRETID 和 SECRETKEY 请登录 https://console.cloud.tencent.com/cam/capi 进行查看和管理</span></span><br><span class="line"><span class="keyword">var</span> cos = <span class="keyword">new</span> <span class="title function_">COS</span>(&#123;</span><br><span class="line">  <span class="title class_">SecretId</span>: <span class="string">&#x27;SECRETID&#x27;</span>,</span><br><span class="line">  <span class="title class_">SecretKey</span>: <span class="string">&#x27;SECRETKEY&#x27;</span>,</span><br><span class="line">  <span class="title class_">SimpleUploadMethod</span>: <span class="string">&#x27;putObject&#x27;</span>, <span class="comment">// 强烈建议，高级上传、批量上传内部对小文件做简单上传时使用putObject,sdk版本至少需要v1.3.0</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>上传函数实现</p><ul><li><p><strong>第一种：直接点击按钮上传</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">UpLoadImg</span>()&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 选择图片上传</span></span><br><span class="line">    wx.<span class="title function_">chooseMedia</span>(&#123; <span class="comment">//此API可以查看微信官方文档的具体参数信息</span></span><br><span class="line">      <span class="attr">count</span>: <span class="number">1</span>, <span class="comment">// 上传1张图片</span></span><br><span class="line">      <span class="attr">mediaType</span>: [<span class="string">&#x27;image&#x27;</span>], </span><br><span class="line">      <span class="attr">sourceType</span>: [<span class="string">&#x27;album&#x27;</span>,<span class="string">&#x27;camera&#x27;</span>], <span class="comment">// 拍摄图片或从相册选择图片</span></span><br><span class="line">      <span class="title function_">success</span>(<span class="params">res</span>)&#123;</span><br><span class="line">        <span class="comment">// 拿到本地的临时文件路径filePath，多张图片可以用for循环遍历上传</span></span><br><span class="line">        <span class="keyword">var</span> filePath = res.<span class="property">tempFiles</span>[<span class="number">0</span>].<span class="property">tempFilePath</span>;</span><br><span class="line">        <span class="comment">// 截取filePath最后一个斜杆的后面部分作为cloudPath</span></span><br><span class="line">        <span class="keyword">var</span> cloudPath = filePath.<span class="title function_">substr</span>(filePath.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 使用腾讯云COS对象存储</span></span><br><span class="line">        cos.<span class="title function_">postObject</span>(&#123;</span><br><span class="line">          <span class="title class_">Bucket</span>: <span class="string">&#x27;Bucketname&#x27;</span>, <span class="comment">//对象储存桶的名称</span></span><br><span class="line">          <span class="title class_">Region</span>: <span class="string">&#x27;ap-guangzhou&#x27;</span>, <span class="comment">//所属地域</span></span><br><span class="line">          <span class="title class_">Key</span>: <span class="string">&#x27;dir/&#x27;</span> + cloudPath, <span class="comment">//存储在dir文件夹里面,如果没有区分文件夹就直接填cloudPath</span></span><br><span class="line">          <span class="title class_">FilePath</span>: filePath, <span class="comment">// 本地的临时文件路径</span></span><br><span class="line">          <span class="attr">onProgress</span>: <span class="keyword">function</span> (<span class="params">info</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进度条&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(info));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">          <span class="comment">// 这里用的是回调函数的形式，也可以用promise方式</span></span><br><span class="line">          <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;上传失败&#x27;</span>, err);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 上传成功赋值toIdentifyUrl</span></span><br><span class="line">            that.<span class="title function_">setData</span>(&#123;</span><br><span class="line">              <span class="comment">// 最终的图片地址toIdentifyUrl在data里面有声明</span></span><br><span class="line">              <span class="comment">// app.globalData.cdnHost是图片链接的公共前缀我放在app.js里面了</span></span><br><span class="line">              <span class="attr">toIdentifyUrl</span>: app.<span class="property">globalData</span>.<span class="property">cdnHost</span> + <span class="string">&#x27;dir/&#x27;</span> + cloudPath</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>第二种：结合WeUI的mp-uploader组件进行上传</strong>（mp-uploader自带图片上传的相关参数）</p><p>WeUI的引入这里就不赘述了，首先是wxml的mp-uploader部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- photo是最终存放上传成功图片的列表，一般一开始是空的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mp-uploader</span> <span class="attr">files</span>=<span class="string">&quot;&#123;&#123;photo&#125;&#125;&quot;</span> <span class="attr">max-count</span>=<span class="string">&quot;1&quot;</span> <span class="attr">max-size</span>=<span class="string">&quot;&#123;&#123;10 * 1024 * 1024&#125;&#125;&quot;</span> <span class="attr">title</span>=<span class="string">&quot;照片：&quot;</span> <span class="attr">tips</span>=<span class="string">&quot;最多上传一张图片&quot;</span> <span class="attr">size-type</span>=<span class="string">&quot;&#123;&#123;sizeType&#125;&#125;&quot;</span> <span class="attr">sourceType</span>=<span class="string">&quot;&#123;&#123;sourceType&#125;&#125;&quot;</span> <span class="attr">delete</span>=<span class="string">&quot;&#123;&#123;true&#125;&#125;&quot;</span> <span class="attr">select</span>=<span class="string">&quot;&#123;&#123;selectFile&#125;&#125;&quot;</span> <span class="attr">upload</span>=<span class="string">&quot;&#123;&#123;uplaodFile&#125;&#125;&quot;</span> <span class="attr">binddelete</span>=<span class="string">&quot;delimg&quot;</span> <span class="attr">bindfail</span>=<span class="string">&quot;uploadError&quot;</span> <span class="attr">bindsuccess</span>=<span class="string">&quot;uploadSuccess&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mp-uploader</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后就是涉及到的上传图片的js代码，主要mp-uploader中5个函数的实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">COS</span> = <span class="built_in">require</span>(<span class="string">&#x27;../../../utils/cos-wx-sdk-v5.js&#x27;</span>); <span class="comment">// 图片上传所需接口</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">getApp</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 COS SDK 实例</span></span><br><span class="line"><span class="comment">// SECRETID 和 SECRETKEY 请登录 https://console.cloud.tencent.com/cam/capi 进行查看和管理</span></span><br><span class="line"><span class="keyword">var</span> cos = <span class="keyword">new</span> <span class="title function_">COS</span>(&#123;</span><br><span class="line">  <span class="title class_">SecretId</span>: <span class="string">&#x27;SECRETID&#x27;</span>,</span><br><span class="line">  <span class="title class_">SecretKey</span>: <span class="string">&#x27;SECRETKEY&#x27;</span>,</span><br><span class="line">  <span class="title class_">SimpleUploadMethod</span>: <span class="string">&#x27;putObject&#x27;</span>, <span class="comment">// 强烈建议，高级上传、批量上传内部对小文件做简单上传时使用putObject,sdk版本至少需要v1.3.0</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">photo</span>: [],</span><br><span class="line">    <span class="comment">//mp-uploader</span></span><br><span class="line">    <span class="attr">sizeType</span>: [<span class="string">&#x27;original&#x27;</span>], <span class="comment">//压缩上传,可以是[&#x27;original&#x27;, &#x27;compressed&#x27;]</span></span><br><span class="line">    <span class="attr">sourceType</span>: [<span class="string">&#x27;album&#x27;</span>, <span class="string">&#x27;camera&#x27;</span>], <span class="comment">//相册,或拍照</span></span><br><span class="line">    <span class="attr">maximgs</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">onLoad</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="comment">//通过bind(this)将函数绑定到this上,以后函数内的this就是指全局页面</span></span><br><span class="line">      <span class="comment">//setdata以后,这两个函数就可以传递给mp-uploader了</span></span><br><span class="line">      <span class="attr">selectFile</span>: <span class="variable language_">this</span>.<span class="property">selectFile</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>),</span><br><span class="line">      <span class="attr">uplaodFile</span>: <span class="variable language_">this</span>.<span class="property">uplaodFile</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 图片上传相关函数</span></span><br><span class="line">  <span class="comment">// Func01：uplaodFile，必须返回Promise</span></span><br><span class="line">  <span class="title function_">uplaodFile</span>(<span class="params">files</span>) &#123;</span><br><span class="line">    <span class="comment">//Promise的callback里面必须resolve(&#123;urls&#125;)表示成功，否则表示失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> tempFilePaths = files.<span class="property">tempFilePaths</span>;</span><br><span class="line">      <span class="keyword">const</span> that = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="keyword">let</span> finished = &#123;</span><br><span class="line">        <span class="attr">urls</span>: []</span><br><span class="line">      &#125; <span class="comment">//本次上次成功的URLs存入这个变量,被success方法的e.detail承接</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; tempFilePaths.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> filePath = tempFilePaths[i] <span class="comment">//原名</span></span><br><span class="line">        <span class="keyword">let</span> cloudPath = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() + <span class="string">&#x27;-&#x27;</span> + filePath.<span class="title function_">substr</span>(filePath.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>) <span class="comment">//云存储文件名</span></span><br><span class="line">        cos.<span class="title function_">postObject</span>(&#123;</span><br><span class="line">          <span class="title class_">Bucket</span>: <span class="string">&#x27;BucketName&#x27;</span>, <span class="comment">//对象储存桶的名称</span></span><br><span class="line">          <span class="title class_">Region</span>: <span class="string">&#x27;ap-guangzhou&#x27;</span>, <span class="comment">//所属地域</span></span><br><span class="line">          <span class="title class_">Key</span>: <span class="string">&#x27;dir/&#x27;</span> + cloudPath, <span class="comment">//存储在dir文件夹里面</span></span><br><span class="line">          <span class="title class_">FilePath</span>: filePath,</span><br><span class="line">          <span class="attr">onProgress</span>: <span class="keyword">function</span> (<span class="params">info</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进度条&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(info));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">          <span class="comment">// 这里用的是回调函数的形式，也可以用promise方式</span></span><br><span class="line">          <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;上传失败&#x27;</span>, err);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            finished.<span class="property">urls</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">              <span class="attr">url</span>: app.<span class="property">globalData</span>.<span class="property">cdnHost</span> + <span class="string">&#x27;dogs/&#x27;</span> + cloudPath</span><br><span class="line">            &#125;) <span class="comment">//成功一个存一个到本次上传成功列表</span></span><br><span class="line">            <span class="comment">//如果本次上传的文件都完成 或全局已经存满1张,resolve退出</span></span><br><span class="line">            <span class="keyword">if</span> (finished.<span class="property">urls</span>.<span class="property">length</span> === tempFilePaths.<span class="property">length</span> || that.<span class="property">data</span>.<span class="property">files</span>.<span class="property">length</span> + finished.<span class="property">urls</span>.<span class="property">length</span> == <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">maximgs</span>) &#123;</span><br><span class="line">              <span class="title function_">resolve</span>(finished)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Func02：uploadSuccess，上传成功函数</span></span><br><span class="line">  <span class="title function_">uploadSuccess</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;upload success&#x27;</span>, e.<span class="property">detail</span>)</span><br><span class="line">    <span class="comment">// 将新上传的urls接到目前的photo上</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">photo</span> = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">photo</span>.<span class="title function_">concat</span>(e.<span class="property">detail</span>.<span class="property">urls</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">photo</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">photo</span></span><br><span class="line">    &#125;)</span><br><span class="line">    wx.<span class="title function_">hideLoading</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Func03：delimg删除图片</span></span><br><span class="line">  <span class="comment">// detail为&#123;index, item&#125;，index表示删除的图片的下标，item为图片对象。</span></span><br><span class="line">  <span class="title function_">delimg</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">photo</span>.<span class="title function_">splice</span>(<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">photo</span>.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item == e.<span class="property">detail</span>.<span class="property">item</span>), <span class="number">1</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Func04：uploadError，上传失败函数</span></span><br><span class="line">  <span class="title function_">uploadError</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;upload error&#x27;</span>, e.<span class="property">detail</span>)</span><br><span class="line">    wx.<span class="title function_">hideLoading</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Func05：selectFile，mpuploader选择图片时的过滤函数，返回true表示图片有效</span></span><br><span class="line">  <span class="title function_">selectFile</span>(<span class="params">files</span>) &#123;</span><br><span class="line">    wx.<span class="title function_">showLoading</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="项目源码github地址"><a href="#项目源码github地址" class="headerlink" title="项目源码github地址"></a>项目源码github地址</h2><p>2023-3-21 13:55 项目基本完成，过段时间开源项目前端代码……<br>2023-4-23 8:31  </p><ol><li>前端项目代码github链接：<blockquote><p><a href="https://github.com/2aurora2/PuppyHome_WeChatApp">https://github.com/2aurora2/PuppyHome_WeChatApp</a></p></blockquote></li><li>B站演示视频链接：<blockquote><p><a href="https://www.bilibili.com/video/BV1Fv4y1J7va/?spm_id_from=333.999.0.0&amp;vd_source=4eacc3ec90d2d047330b4cb99502e3a4">https://www.bilibili.com/video/BV1Fv4y1J7va/?spm_id_from=333.999.0.0&amp;vd_source=4eacc3ec90d2d047330b4cb99502e3a4</a></p></blockquote></li></ol><h2 id="实用CSS工具"><a href="#实用CSS工具" class="headerlink" title="实用CSS工具"></a>实用CSS工具</h2><ol><li><a href="https://uiverse.io/all">All elements made with CSS and HTML (uiverse.io)</a></li><li><a href="https://yoksel.github.io/flex-cheatsheet/#section-declaring">Flex Cheatsheet (yoksel.github.io)</a></li><li><a href="https://neumorphism.io/#ffffff">Neumorphism/Soft UI CSS shadow generator</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发范畴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WeChat Mini Program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分析图表的绘制</title>
      <link href="/post/data_analysis.html"/>
      <url>/post/data_analysis.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先祝大家元宵节快乐呀！这篇文章呢主要就是介绍如何绘制常见的数据分析图表，更多地是讲如何利用python的matplotlib库来绘制，也会提及一些现成的工具。</p><hr><p>2023.11.13 参加了几次数模后想着来更新一波内容（主要是美化一下，之前的有点小丑……</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>Python绘制数据分析图表主要用到的是matplotlib这个库，使用前先安装这个库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install matplotlib</span><br></pre></td></tr></table></figure><p>然后导入子模块pyplot</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br></pre></td></tr></table></figure><p>对于图表中可能会出现中文显示不了的问题，一般要在开始前加上以下语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决中文显示问题 </span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><p>折线图（Line Chart）是一种将数据点按照顺序连接起来的图形，也可以看作是将散点图按照X轴坐标顺序链接起来的图形。折线图的主要功能是查看因变量y随着自变量x改变的趋势，最适合用于显示随时间（根据常用比例设置）而改变的连续数据。同时，还可以看出数量的差异，python画折线图主要利用<strong>plot</strong>方法</p><p>实例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Times New Romen&#x27;</span>, <span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># x轴的数据</span></span><br><span class="line">seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># x对应的y值</span></span><br><span class="line">data1 = np.random.randint(<span class="number">50</span>, size=<span class="number">10</span>)</span><br><span class="line">data2 = np.random.randint(<span class="number">50</span>, size=<span class="number">10</span>)</span><br><span class="line">data3 = np.random.randint(<span class="number">50</span>, size=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot绘制折线图</span></span><br><span class="line"><span class="comment"># 1.前两个参数是对应x轴y轴数据，marker是数据点样式，linewidth是线宽，linestyle是线条样式，color是线条颜色</span></span><br><span class="line"><span class="comment"># 2.linestyle常用属性值：</span></span><br><span class="line"><span class="comment">#   &#x27;-&#x27; 实线   &#x27;--&#x27; 虚线   &#x27;-.&#x27; 虚点线   &#x27;:&#x27; 点线</span></span><br><span class="line"><span class="comment"># 3.color常用属性值缩写：（也可使用十六进制颜色表示法）</span></span><br><span class="line"><span class="comment">#   &#x27;b&#x27; 蓝色   &#x27;g&#x27; 绿色   &#x27;r&#x27; 红色   &#x27;c&#x27; 青色   &#x27;m&#x27; 品红   &#x27;y&#x27; 黄色   &#x27;k&#x27; 黑色   &#x27;w&#x27; 白色</span></span><br><span class="line"><span class="comment"># 4.mfc数据点的填充颜色</span></span><br><span class="line"><span class="comment"># 5.ms数据点的大小</span></span><br><span class="line">plt.plot(seq, data1, marker=<span class="string">&#x27;o&#x27;</span>, linewidth=<span class="number">1</span>, linestyle=<span class="string">&#x27;-&#x27;</span>, color=<span class="string">&#x27;#6562FF&#x27;</span>, label=<span class="string">&#x27;数据一&#x27;</span>, mfc=<span class="string">&#x27;white&#x27;</span>, ms=<span class="number">5</span>)</span><br><span class="line">plt.plot(seq, data2, marker=<span class="string">&#x27;o&#x27;</span>, linewidth=<span class="number">1</span>, linestyle=<span class="string">&#x27;-&#x27;</span>, color=<span class="string">&#x27;m&#x27;</span>, label=<span class="string">&#x27;数据二&#x27;</span>, mfc=<span class="string">&#x27;white&#x27;</span>, ms=<span class="number">5</span>)</span><br><span class="line">plt.plot(seq, data3, marker=<span class="string">&#x27;o&#x27;</span>, linewidth=<span class="number">1</span>, linestyle=<span class="string">&#x27;-&#x27;</span>, color=<span class="string">&#x27;g&#x27;</span>, label=<span class="string">&#x27;数据三&#x27;</span>, mfc=<span class="string">&#x27;white&#x27;</span>, ms=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置标题及字体大小</span></span><br><span class="line"><span class="comment"># plt.title(label=&#x27;Test Chart&#x27;, fontsize=18)</span></span><br><span class="line">plt.xlabel(xlabel=<span class="string">&#x27;x轴&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(ylabel=<span class="string">&#x27;y轴&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tick <span class="keyword">in</span> plt.gca().get_yticklabels():</span><br><span class="line">    plt.axhline(y=tick.get_position()[<span class="number">1</span>], color=<span class="string">&#x27;#b8bcbf&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, linewidth=<span class="number">1</span>, zorder=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图例</span></span><br><span class="line"><span class="comment"># 参数loc可以设置图例在图表中的位置</span></span><br><span class="line"><span class="comment">#     &#x27;best&#x27;</span></span><br><span class="line"><span class="comment">#     &#x27;upper right&#x27;:右上角</span></span><br><span class="line"><span class="comment">#     &#x27;upper left&#x27;: 左上角</span></span><br><span class="line"><span class="comment">#     &#x27;lower left&#x27;: 左下角</span></span><br><span class="line"><span class="comment">#     &#x27;lower right&#x27;: 右下角</span></span><br><span class="line"><span class="comment">#     &#x27;center left&#x27;: 左侧中央</span></span><br><span class="line"><span class="comment">#     &#x27;center right&#x27;: 右侧中间</span></span><br><span class="line"><span class="comment">#     &#x27;lower center&#x27;: 底部正中</span></span><br><span class="line"><span class="comment">#     &#x27;upper center&#x27;: 顶部正中</span></span><br><span class="line"><span class="comment"># 将图例放在图表外loc设置为best，通过添加bbox_to_anchor属性设置锚点即图例位置：在图表内，左下角位置为(0,0)，右上角位置为(1,1)</span></span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去掉上边框和有边框</span></span><br><span class="line">plt.gca().spines[<span class="string">&#x27;top&#x27;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">plt.gca().spines[<span class="string">&#x27;right&#x27;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># savefig保存图片</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;test.jpg&#x27;</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)  <span class="comment"># bbox_inches=&#x27;tight&#x27;将图表的多余空间删除</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图：</p><img src="/post/data_analysis/1.jpg" class title="This is an example image"><h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><p>散点图（Scatter Diagram）又称为散点分布图，是以一个特征为横坐标，另一个特征为纵坐标，使用坐标点（散点）的分布形态反映特征间统计关系的一种图形。值时由点在图表中的位置表示，类别是由图表中的不同标记表示 ，通常用于比较跨类别的数据，python画散点图主要利用<strong>scatter</strong>方法</p><p>scatter方法主要参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.scatter(x,y,s=<span class="literal">None</span>,c=<span class="literal">None</span>,marker=<span class="literal">None</span>,alpha=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>scatter方法主要参数说明</p><img src="/post/data_analysis/1.png" class title="This is an example image"><p>实例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># label属性是设置图例名称</span></span><br><span class="line"><span class="comment"># # 绘制一组数据散点图</span></span><br><span class="line"><span class="comment"># x = np.arange(1, 30)</span></span><br><span class="line"><span class="comment"># y = np.sin(x)</span></span><br><span class="line"><span class="comment"># plt.scatter(x,y,c=&#x27;orange&#x27;,s=100,label=&#x27;orange&#x27;,marker=&#x27;o&#x27;,alpha=0.5)</span></span><br><span class="line"><span class="comment"># 绘制多组数据散点图</span></span><br><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]:</span><br><span class="line">    x, y = np.random.randn(<span class="number">2</span>, <span class="number">500</span>)</span><br><span class="line">    plt.scatter(x, y, c=color, label=color, alpha=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置标题和横纵坐标</span></span><br><span class="line">plt.title(<span class="string">&#x27;散点图&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图例</span></span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line"><span class="comment"># savefig保存图片</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;test.jpg&#x27;</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)  <span class="comment"># bbox_inches=&#x27;tight&#x27;将图表的多余空间删除</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图</p><img src="/post/data_analysis/2.jpg" class title="This is an example image"><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><p> 饼图（Pie Graph）用于表示不同分类的占比情况，通过弧度大小来对比各种分类，饼图可以比较清楚的反映出部分与部分、部分与整体之间的比例关系，易于显示每组数据相对于总数的大小，而且显现的方式直观。python画饼图主要利用<strong>pie</strong>方法</p><p>pie方法主要参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.pie(x,explode = <span class="literal">None</span>,labels = <span class="literal">None</span>,color = <span class="literal">None</span>,autopct = <span class="literal">None</span>,</span><br><span class="line">pctdistance = <span class="number">0.6</span>,shadow=false,labeldistance=<span class="number">1.1</span>,startangle=<span class="literal">None</span>,radius=<span class="literal">None</span>,...)</span><br></pre></td></tr></table></figure><p>实例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># x：指定绘图的数据；</span></span><br><span class="line"><span class="comment"># explode：指定饼图某些部分的突出显示，即呈现爆炸式；</span></span><br><span class="line"><span class="comment"># labels：为饼图添加标签说明，类似于图例说明；</span></span><br><span class="line"><span class="comment"># colors：指定饼图的填充色；</span></span><br><span class="line"><span class="comment"># autopct：自动添加百分比显示，可以采用格式化的方法显示；</span></span><br><span class="line"><span class="comment"># pctdistance：设置百分比标签与圆心的距离；</span></span><br><span class="line"><span class="comment"># shadow：是否添加饼图的阴影效果；</span></span><br><span class="line"><span class="comment"># labeldistance：设置各扇形标签（图例）与圆心的距离；</span></span><br><span class="line"><span class="comment"># startangle：设置饼图的初始摆放角度；</span></span><br><span class="line"><span class="comment"># radius：设置饼图的半径大小；</span></span><br><span class="line"><span class="comment"># counterclock：是否让饼图按逆时针顺序呈现；</span></span><br><span class="line"><span class="comment"># wedgeprops：设置饼图内外边界的属性，如边界线的粗细、颜色等；</span></span><br><span class="line"><span class="comment"># textprops：设置饼图中文本的属性，如字体大小、颜色等；</span></span><br><span class="line"><span class="comment"># center：指定饼图的中心点位置，默认为原点</span></span><br><span class="line"><span class="comment"># frame：是否要显示饼图背后的图框，如果设置为True的话，需要同时控制图框x轴、y轴的范围和饼图的中心位置</span></span><br><span class="line">labels = [<span class="string">&#x27;30岁&#x27;</span>, <span class="string">&#x27;40岁&#x27;</span>, <span class="string">&#x27;50岁&#x27;</span>, <span class="string">&#x27;60岁&#x27;</span>]</span><br><span class="line">x = [<span class="number">15</span>, <span class="number">30</span>, <span class="number">45</span>, <span class="number">10</span>]  <span class="comment"># 各个标签的数量</span></span><br><span class="line">explode = (<span class="number">0.05</span>, <span class="number">0.05</span>, <span class="number">0.05</span>, <span class="number">0.05</span>)  <span class="comment"># 每个标签的扇形图距离圆心的距离</span></span><br><span class="line">plt.pie(x=x,</span><br><span class="line">        autopct=<span class="string">&#x27;%.2f%%&#x27;</span>,</span><br><span class="line">        colors=[<span class="string">&#x27;#eab4ad&#x27;</span>, <span class="string">&#x27;#afc6d2&#x27;</span>, <span class="string">&#x27;#b0d1bb&#x27;</span>, <span class="string">&#x27;#87cefa&#x27;</span>],</span><br><span class="line">        labels=labels,</span><br><span class="line">        pctdistance=<span class="number">0.6</span>,</span><br><span class="line">        labeldistance=<span class="number">1.1</span>,</span><br><span class="line">        explode=explode,</span><br><span class="line">        wedgeprops=&#123;<span class="string">&#x27;edgecolor&#x27;</span>: <span class="string">&#x27;r&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;linestyle&#x27;</span>: <span class="string">&#x27;--&#x27;</span>&#125;,</span><br><span class="line">        textprops=&#123;<span class="string">&quot;fontsize&quot;</span>: <span class="number">13</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;black&quot;</span>&#125;,</span><br><span class="line">        shadow=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置标题和横纵坐标</span></span><br><span class="line">plt.title(<span class="string">&#x27;饼状图&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># savefig保存图片</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;test.jpg&#x27;</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图</p><img src="/post/data_analysis/3.jpg" class title="This is an example image"><h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><p>直方图（Histogram）又称质量分布图，是统计报告图的一种，由一系列高度不等的纵向条纹或线段表示数据分布的情况，一般用横轴表示数据所属类别，纵轴表示数量或者占比。用直方图可以比较直观地看出产品质量特性的分布状态，便于判断其总体质量分布情况。直方图可以发现分布表无法发现的数据模式、样本的频率分布和总体的分布。python画饼图主要利用<strong>bar</strong>方法</p><p>bar方法主要参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># x：传递数值序列，指定条形图中x轴上的刻度值。</span></span><br><span class="line"><span class="comment"># height：传递数值序列，指定条形图y轴上的高度。</span></span><br><span class="line"><span class="comment"># width：指定条形图的宽度，默认为0.8。 bottom：用于绘制堆叠条形图。</span></span><br><span class="line"><span class="comment"># color：指定条形图的填充色。</span></span><br><span class="line"><span class="comment"># edgecolor：指定条形图的边框色。</span></span><br><span class="line"><span class="comment"># linewidth：指定条形图边框的宽度，如果指定为0，表示不绘制边框。</span></span><br><span class="line"><span class="comment"># tick_label：指定条形图的刻度标签。</span></span><br><span class="line"><span class="comment"># xerr：如果参数不为None，表示在条形图的基础上添加误差棒。</span></span><br><span class="line"><span class="comment"># yerr：参数含义同xerr。</span></span><br><span class="line"><span class="comment"># label：指定条形图的标签，一般用以添加图例。</span></span><br><span class="line"><span class="comment"># ecolor：指定条形图误差棒的颜色。</span></span><br><span class="line"><span class="comment"># align：指定x轴刻度标签的对齐方式，默认为center，表示刻度标签居中对齐，如果设置为edge，则表示在每个条形的左下角呈现刻度标签。</span></span><br><span class="line"><span class="comment"># log：bool类型参数，是否对坐标轴进行log变换，默认为False。</span></span><br><span class="line"><span class="comment"># **kwargs：关键字参数，用于对条形图进行其他设置，如透明度等。</span></span><br><span class="line">bar(x, height, width=<span class="number">0.8</span>, bottom=<span class="literal">None</span>, color=<span class="literal">None</span>, edgecolor=<span class="literal">None</span>,</span><br><span class="line">   linewidth=<span class="literal">None</span>, tick_label=<span class="literal">None</span>, xerr=<span class="literal">None</span>, yerr=<span class="literal">None</span>,</span><br><span class="line">   label = <span class="literal">None</span>, ecolor=<span class="literal">None</span>, align, log=<span class="literal">False</span>, **kwargs)</span><br></pre></td></tr></table></figure><h4 id="水平交错条形图"><a href="#水平交错条形图" class="headerlink" title="水平交错条形图"></a>水平交错条形图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Microsoft YaHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 设置绘图风格</span></span><br><span class="line">plt.style.use(<span class="string">&#x27;ggplot&#x27;</span>)</span><br><span class="line"><span class="comment"># 城市名称</span></span><br><span class="line">Cities = [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;香港&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>, <span class="string">&#x27;广州&#x27;</span>]</span><br><span class="line"><span class="comment"># 取出2016年各城市亿万资产家庭数</span></span><br><span class="line">Counts2016 = [<span class="number">15600</span>, <span class="number">12700</span>, <span class="number">11300</span>, <span class="number">4270</span>, <span class="number">3820</span>]</span><br><span class="line"><span class="comment"># 取出2017年各城市亿万资产家庭数</span></span><br><span class="line">Counts2017 = [<span class="number">17400</span>, <span class="number">14800</span>, <span class="number">12000</span>, <span class="number">5200</span>, <span class="number">4020</span>]</span><br><span class="line"><span class="comment"># 绘制水平交错条形图</span></span><br><span class="line">bar_width = <span class="number">0.4</span></span><br><span class="line">plt.bar(x=np.arange(<span class="built_in">len</span>(Cities)), height=Counts2016, label=<span class="string">&#x27;2016&#x27;</span>, color=<span class="string">&#x27;steelblue&#x27;</span>, width=bar_width)</span><br><span class="line">plt.bar(x=np.arange(<span class="built_in">len</span>(Cities)) + bar_width, height=Counts2017, label=<span class="string">&#x27;2017&#x27;</span>, color=<span class="string">&#x27;indianred&#x27;</span>, width=bar_width)</span><br><span class="line"><span class="comment"># 添加x轴刻度标签（向右偏移0.225）</span></span><br><span class="line">plt.xticks(np.arange(<span class="number">5</span>) + <span class="number">0.2</span>, Cities)</span><br><span class="line"><span class="comment"># 添加y轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;亿万资产家庭数&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加图形标题</span></span><br><span class="line">plt.title(<span class="string">&#x27;近两年5个城市亿万资产家庭数比较&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加图例</span></span><br><span class="line">plt.legend()</span><br><span class="line"><span class="comment"># 为每个条形图添加数值标签</span></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(Counts2016):</span><br><span class="line">    plt.text(x, y + <span class="number">200</span>, <span class="string">&quot;%s&quot;</span> % <span class="built_in">round</span>(y, <span class="number">1</span>), ha=<span class="string">&#x27;center&#x27;</span>)  <span class="comment"># round(y,1)是将y值四舍五入到一个小数位</span></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(Counts2017):</span><br><span class="line">    plt.text(x + bar_width, y + <span class="number">200</span>, <span class="string">&quot;%s&quot;</span> % <span class="built_in">round</span>(y, <span class="number">1</span>), ha=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"><span class="comment"># 保存图像</span></span><br><span class="line">plt.savefig(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图</p><img src="/post/data_analysis/4.jpg" class title="This is an example image"><h4 id="水平条形图"><a href="#水平条形图" class="headerlink" title="水平条形图"></a>水平条形图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置绘图风格</span></span><br><span class="line">plt.style.use(<span class="string">&#x27;ggplot&#x27;</span>)</span><br><span class="line"><span class="comment"># 处理中文乱码</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Microsoft YaHei&#x27;</span>]</span><br><span class="line"><span class="comment"># 水平条形图一般具有一定顺序</span></span><br><span class="line">Cities = [<span class="string">&#x27;广东&#x27;</span>, <span class="string">&#x27;江苏&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;重庆&#x27;</span>, <span class="string">&#x27;天津&#x27;</span>]</span><br><span class="line">GDP = [<span class="number">9</span>, <span class="number">8.6</span>, <span class="number">3</span>, <span class="number">2.8</span>, <span class="number">2</span>, <span class="number">1.9</span>]</span><br><span class="line"><span class="comment"># 绘制条形图</span></span><br><span class="line">plt.barh(y=<span class="built_in">range</span>(<span class="built_in">len</span>(Cities)),  <span class="comment"># 指定条形图y轴的刻度值</span></span><br><span class="line">         width=GDP,  <span class="comment"># 指定条形图x轴的数值</span></span><br><span class="line">         tick_label=Cities,  <span class="comment"># 指定条形图y轴的刻度标签</span></span><br><span class="line">         color=[<span class="string">&#x27;#da7d61&#x27;</span>, <span class="string">&#x27;#3f3f5c&#x27;</span>, <span class="string">&#x27;#86af9d&#x27;</span>, <span class="string">&#x27;#467b9d&#x27;</span>, <span class="string">&#x27;#f0c986&#x27;</span>]</span><br><span class="line">         )</span><br><span class="line"><span class="comment"># 添加x轴的标签</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;GDP(万亿)&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;2017年度6个省份GDP分布&#x27;</span>)</span><br><span class="line"><span class="comment"># 为每个条形图添加数值标签</span></span><br><span class="line"><span class="keyword">for</span> y, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(GDP):</span><br><span class="line">    plt.text(x + <span class="number">0.1</span>, y, <span class="string">&quot;%s&quot;</span> % <span class="built_in">round</span>(x, <span class="number">1</span>), va=<span class="string">&#x27;center&#x27;</span>)  <span class="comment"># round(y,1)是将y值四舍五入到一个小数位</span></span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图</p><img src="/post/data_analysis/5.jpg" class title="This is an example image"><h4 id="垂直条形图"><a href="#垂直条形图" class="headerlink" title="垂直条形图"></a>垂直条形图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置绘图风格</span></span><br><span class="line">plt.style.use(<span class="string">&#x27;ggplot&#x27;</span>)</span><br><span class="line"><span class="comment"># 处理中文乱码</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Microsoft YaHei&#x27;</span>]</span><br><span class="line">Cities = [<span class="string">&#x27;广东&#x27;</span>, <span class="string">&#x27;江苏&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;重庆&#x27;</span>, <span class="string">&#x27;天津&#x27;</span>]</span><br><span class="line">GDP = [<span class="number">9</span>, <span class="number">8.6</span>, <span class="number">3</span>, <span class="number">2.8</span>, <span class="number">2</span>, <span class="number">1.9</span>]</span><br><span class="line"><span class="comment"># 绘制条形图</span></span><br><span class="line">plt.bar(x=<span class="built_in">range</span>(<span class="built_in">len</span>(Cities)),  <span class="comment"># 指定条形图x轴的刻度值(有的是用left，有的要用x)</span></span><br><span class="line">        height=GDP,  <span class="comment"># 指定条形图y轴的数值（python3.7不能用y，而应该用height）</span></span><br><span class="line">        tick_label=Cities,  <span class="comment"># 指定条形图x轴的刻度标签</span></span><br><span class="line">        color=<span class="string">&#x27;steelblue&#x27;</span>,  <span class="comment"># 指定条形图的填充色</span></span><br><span class="line">        )</span><br><span class="line"><span class="comment"># 添加y轴的标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;GDP(万亿)&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加条形图的标题</span></span><br><span class="line">plt.title(<span class="string">&#x27;2017年度6个省份GDP分布&#x27;</span>)</span><br><span class="line"><span class="comment"># 为每个条形图添加数值标签</span></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(GDP):</span><br><span class="line">    plt.text(x, y + <span class="number">0.1</span>, <span class="string">&quot;%s&quot;</span> % <span class="built_in">round</span>(y, <span class="number">1</span>), ha=<span class="string">&#x27;center&#x27;</span>)  <span class="comment"># round(y,1)是将y值四舍五入到一个小数位</span></span><br><span class="line"><span class="comment"># 保存图片</span></span><br><span class="line">plt.savefig(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图</p><img src="/post/data_analysis/6.jpg" class title="This is an example image"><h3 id="热力图"><a href="#热力图" class="headerlink" title="热力图"></a>热力图</h3><p>利用热力图可以看数据表里多个特征两两的相似度，在python种一般利用seaborn中的heatmap方法</p><p>heatmap方法常用参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seaborn.heatmap(data, vmin=<span class="literal">None</span>, vmax=<span class="literal">None</span>,cmap=<span class="literal">None</span>, center=<span class="literal">None</span>, robust=<span class="literal">False</span>, annot=<span class="literal">None</span>, fmt=’<span class="number">.2</span>g’, annot_kws=<span class="literal">None</span>,linewidths=<span class="number">0</span>, linecolor=’white’, cbar=<span class="literal">True</span>, cbar_kws=<span class="literal">None</span>, cbar_ax=<span class="literal">None</span>,square=<span class="literal">False</span>, xticklabels=’auto’, yticklabels=’auto’, mask=<span class="literal">None</span>, ax=<span class="literal">None</span>,**kwargs)</span><br></pre></td></tr></table></figure><p>实例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Microsoft YaHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">data = np.random.rand(<span class="number">5</span>, <span class="number">5</span>)  <span class="comment"># 指定生成5x5的元素是0-1的二维数组</span></span><br><span class="line">df = pd.DataFrame(data, columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>], index=<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">corr = df.corr()</span><br><span class="line">mask = np.zeros_like(corr)</span><br><span class="line">mask[np.triu_indices_from(mask)] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数解释：</span></span><br><span class="line"><span class="comment"># data:矩阵数据集，可以是numpy的数组（array），也可以是pandas的DataFrame。如果是DataFrame，则df的index/column信息会分别对应到heatmap的columns和rows，即df.index是热力图的行标，df.columns是热力图的列标</span></span><br><span class="line"><span class="comment"># vmax,vmin:分别是热力图的颜色取值最大和最小范围，默认是根据data数据表里的取值确定</span></span><br><span class="line"><span class="comment"># cmap:从数字到色彩空间的映射，取值是matplotlib包里的colormap名称或颜色对象，或者表示颜色的列表；一般有‘YlGnBu’和‘BuPu_r’</span></span><br><span class="line"><span class="comment"># center:数据表取值有差异时，设置热力图的色彩中心对齐值；通过设置center值，可以调整生成的图像颜色的整体深浅；设置center数据时，如果有数据溢出，则手动设置的vmax、vmin会自动改变</span></span><br><span class="line"><span class="comment"># robust:默认取值False；如果是False，且没设定vmin和vmax的值，热力图的颜色映射范围根据具有鲁棒性的分位数设定，而不是用极值设定</span></span><br><span class="line"><span class="comment"># annot(annotate的缩写):默认取值False；如果是True，在热力图每个方格写入数据；如果是矩阵，在热力图每个方格写入该矩阵对应位置数据</span></span><br><span class="line"><span class="comment"># fmt:字符串格式代码，矩阵上标识数字的数据格式，比如保留小数点后几位数字</span></span><br><span class="line"><span class="comment"># annot_kws:默认取值False；如果是True，设置热力图矩阵上数字的大小颜色字体，matplotlib包text类下的字体设置；</span></span><br><span class="line"><span class="comment"># linewidths:定义热力图里“表示两两特征关系的矩阵小块”之间的间隔大小</span></span><br><span class="line"><span class="comment"># linecolor:切分热力图上每个矩阵小块的线的颜色，默认值是’white’</span></span><br><span class="line"><span class="comment"># cbar:是否在热力图侧边绘制颜色刻度条，默认值是True</span></span><br><span class="line"><span class="comment"># cbar_kws:热力图侧边绘制颜色刻度条时，相关字体设置，默认值是None</span></span><br><span class="line"><span class="comment"># cbar_ax:热力图侧边绘制颜色刻度条时，刻度条位置设置，默认值是None</span></span><br><span class="line"><span class="comment"># xticklabels, yticklabels:xticklabels控制每列标签名的输出；yticklabels控制每行标签名的输出。默认值是auto:</span></span><br><span class="line"><span class="comment">#     如果是True，则以DataFrame的列名作为标签名。如果是False，则不添加行标签名。如果是列表，则标签名改为列表中给的内容。如果是整数K，则在图上每隔K个标签进行一次标注。</span></span><br><span class="line"><span class="comment">#     如果是auto，则自动选择标签的标注间距，将标签名不重叠的部分(或全部)输出</span></span><br><span class="line"><span class="comment"># mask:控制某个矩阵块是否显示出来。默认值是None。如果是布尔型的DataFrame，则将DataFrame里True的位置用白色覆盖掉</span></span><br><span class="line"><span class="comment"># ax:设置作图的坐标轴，一般画多个子图时需要修改不同的子图的该值</span></span><br><span class="line">sns.heatmap(corr, vmax=<span class="number">1</span>, vmin=<span class="number">0</span>, cmap=<span class="string">&#x27;RdBu_r&#x27;</span>, annot=<span class="literal">True</span>, fmt=<span class="string">&#x27;.3f&#x27;</span>,</span><br><span class="line">            annot_kws=&#123;<span class="string">&#x27;size&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="string">&#x27;bold&#x27;</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;white&#x27;</span>&#125;, cbar=<span class="literal">True</span>,</span><br><span class="line">            xticklabels=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>], yticklabels=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>], square=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sns.heatmap(corr, vmax=1, vmin=0, cmap=&#x27;RdBu_r&#x27;, annot=True, fmt=&#x27;.3f&#x27;, mask=mask,</span></span><br><span class="line"><span class="comment">#             annot_kws=&#123;&#x27;size&#x27;: 9, &#x27;weight&#x27;: &#x27;bold&#x27;, &#x27;color&#x27;: &#x27;white&#x27;&#125;, cbar=True,</span></span><br><span class="line"><span class="comment">#             xticklabels=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;], yticklabels=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;], square=True)</span></span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图</p><img src="/post/data_analysis/7.jpg" class title="This is an example image"><h3 id="subplot"><a href="#subplot" class="headerlink" title="subplot"></a>subplot</h3><p>有些时候, 我们希望把一组数据分析图表放在一起进行比较,这时候matplotlib 中提供的subplot就可以解决这个问题</p><h4 id="subplot函数的参数"><a href="#subplot函数的参数" class="headerlink" title="subplot函数的参数"></a>subplot函数的参数</h4><p>matplotlib下, 一个 Figure 对象可以包含多个子图(Axes), 可以使用 subplot() 快速绘制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">subplot(numRows,numCols,plotNum)</span><br><span class="line"><span class="comment"># 图表将整个绘图区域分成numRows行和numCols列</span></span><br><span class="line"><span class="comment"># 按从左到右，从上到下的顺序对每个子区域进行编号，左上的子区域编号为1</span></span><br><span class="line"><span class="comment"># plotNum参数指定创建的axes对象所在的区域</span></span><br></pre></td></tr></table></figure><p>实例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消警告的输出</span></span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Microsoft YaHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">plt.figure()  <span class="comment"># 创建一个Figure图表对象</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, facecolor=<span class="string">&#x27;#B0C4DE&#x27;</span>)  <span class="comment"># facecolor设置背景颜色</span></span><br><span class="line">seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">data = np.random.randint(<span class="number">50</span>, size=<span class="number">10</span>)</span><br><span class="line">plt.plot(seq, data, marker=<span class="string">&#x27;o&#x27;</span>, linewidth=<span class="number">1</span>, linestyle=<span class="string">&#x27;:&#x27;</span>, color=<span class="string">&#x27;#6562FF&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, facecolor=<span class="string">&#x27;#B0C4DE&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]:</span><br><span class="line">    x, y = np.random.randn(<span class="number">2</span>, <span class="number">500</span>)</span><br><span class="line">    plt.scatter(x, y, c=color, label=color, alpha=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, facecolor=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">Cities = [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;香港&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>, <span class="string">&#x27;广州&#x27;</span>]</span><br><span class="line">Counts2016 = [<span class="number">15600</span>, <span class="number">12700</span>, <span class="number">11300</span>, <span class="number">4270</span>, <span class="number">3820</span>]</span><br><span class="line">Counts2017 = [<span class="number">17400</span>, <span class="number">14800</span>, <span class="number">12000</span>, <span class="number">5200</span>, <span class="number">4020</span>]</span><br><span class="line">bar_width = <span class="number">0.4</span></span><br><span class="line">plt.bar(x=np.arange(<span class="built_in">len</span>(Cities)), height=Counts2016, label=<span class="string">&#x27;2016&#x27;</span>, color=<span class="string">&#x27;steelblue&#x27;</span>, width=bar_width)</span><br><span class="line">plt.bar(x=np.arange(<span class="built_in">len</span>(Cities)) + bar_width, height=Counts2017, label=<span class="string">&#x27;2017&#x27;</span>, color=<span class="string">&#x27;indianred&#x27;</span>, width=bar_width)</span><br><span class="line"><span class="comment"># 添加x轴刻度标签（向右偏移0.225）</span></span><br><span class="line">plt.xticks(np.arange(<span class="number">5</span>) + <span class="number">0.2</span>, Cities)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;亿万资产家庭数&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(Counts2016):</span><br><span class="line">    plt.text(x, y + <span class="number">200</span>, <span class="string">&quot;%s&quot;</span> % <span class="built_in">round</span>(y, <span class="number">1</span>), ha=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(Counts2017):</span><br><span class="line">    plt.text(x + bar_width, y + <span class="number">200</span>, <span class="string">&quot;%s&quot;</span> % <span class="built_in">round</span>(y, <span class="number">1</span>), ha=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="/post/data_analysis/11.jpg" class title="This is an example image"><h2 id="绘制图表网站"><a href="#绘制图表网站" class="headerlink" title="绘制图表网站"></a>绘制图表网站</h2><p>图表秀：<a href="http://www.tubiaoxiu.com/">http://www.tubiaoxiu.com/</a></p><blockquote><p>参考文章</p></blockquote><p><a href="https://www.jb51.net/article/252383.htm">https://www.jb51.net/article/252383.htm</a></p><p><a href="https://blog.csdn.net/weixin_48615832/article/details/108028198">https://blog.csdn.net/weixin_48615832/article/details/108028198</a></p><p><a href="https://blog.csdn.net/chumingqian/article/details/126063755">https://blog.csdn.net/chumingqian/article/details/126063755</a></p><p><a href="https://blog.csdn.net/weixin_39541558/article/details/79813936">https://blog.csdn.net/weixin_39541558/article/details/79813936</a></p>]]></content>
      
      
      <categories>
          
          <category> 数模学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分和前缀和</title>
      <link href="/post/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C.html"/>
      <url>/post/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于昨天学校OJ平台的一次训练赛中出现了一个前缀和差分的题目，本蒟蒻不太会T_T,所以打算系统学习一下前缀和差分的知识点。在文章的最后笔者也会放上那道题的题目以及AC代码。</p><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><hr><h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><p>前缀和可以简单的理解为某个数组中前n项的和，是一种重要的预处理方式，能大大降低查询的时间复杂度。而一维的前缀和比较简单就不做过多的赘述，直接通过一个例子来了解：</p><blockquote><p>给定一个n个元素的数组，要求计算出q次查询中给定的区间的元素的和</p></blockquote><p>对于这个例子可能刚开始最简单的想法就是遍历每次查询的区间求和，但是这种做法在数组元素、查询次数足够多的情况下其时间复杂度就会很高，因此就要用到前缀和的思想。</p><p>首先先定义一个数组sum[N]，sum[i]表示的是数组索引为0 - i的元素的和，然后假设查询的区间为[L , R]那么该区间和就为sum[R]-sum[L-1]（若L==0则区间和为sum[R]）</p><blockquote><p>sum[i]的值</p></blockquote><p>当i为0时，sum[i]=arr[0]；当i大于0时，sum[i]=sum[i-1]+arr[i]。</p><p>下面是演示代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], sum[N], n, q, l, r;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">sum[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + arr[i];</span><br><span class="line">cin &gt;&gt; q;</span><br><span class="line"><span class="keyword">while</span> (q--)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line"><span class="keyword">if</span> (l == <span class="number">0</span>) cout &lt;&lt; sum[r] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; sum[r] - sum[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><img src="/post/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/1.png" class title="This is an example image"><h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p>对于二维前缀和，其实就是类似求存储在某个二维数组中某个矩阵方块内的数组元素的和，下面以一个二维数组的例子来讲解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样先定义一个二维数组sum，sum[ i ] [ j ]的意义为以(0,0)为左上角，(i , j)为右下角构成的矩阵所包含的元素的和（以例子中的二维数组为例，sum[1] [2]就是元素1、5、6、9、6、7元素的和）；那么假设所要查询的矩阵是以(x<sub>1</sub>,y<sub>1</sub>)、(x<sub>2</sub>,y<sub>2</sub>)分别为左上角的点和右下角的点构成的，设查询的结果为sum{x<sub>1</sub>,y<sub>1</sub>}{x<sub>2</sub>,y<sub>2</sub>}，以下图为例来说，sum{x<sub>1</sub>,y<sub>1</sub>}{x<sub>2</sub>,y<sub>2</sub>}的结果就是sum[ x<sub>2</sub> ] [ y<sub>2</sub> ]的值减去蓝色框内的再减去红色框内的最后加上绿色框内的重合部分即可，用式子来表示即为（下面式子是所查询的矩阵不包含第一行和第一列的情况，若包含同样的利用方块相减的思路）：</p><p>sum[x<sub>2</sub>] [y<sub>2</sub>] - sum[x<sub>2</sub>] [y<sub>1</sub> - 1] - sum[x<sub>1</sub> - 1] [y<sub>2</sub>] + sum[x<sub>1</sub> - 1] [y<sub>1</sub> - 1]</p><img src="/post/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/2.png" class title="This is an example image"><blockquote><p>sum[ i ] [ j ]的值</p></blockquote><ul><li>当i==0且j==0时，sum[ i ] [ j ]=arr[0] [0]</li><li>当i==0且j != 0时，sum[ i ] [ j ]=sum[ i ] [ j-1 ] + arr[ i ] [ j ]</li><li>当i != 0且j==0时，sum[ i ] [ j ]=sum[ i-1 ] [ j ] + arr[ i ] [ j ]</li><li>当i != 0 且j != 0时，sum[ i ] [ j ]=sum[ i ] [ j-1 ]+sum[ i-1 ] [ j ]-sum[ i-1 ] [ j-1 ]+arr[ i ] [ j ]</li></ul><p>下面是演示代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">3</span>, m = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> arr[n][m] = &#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;,</span><br><span class="line">&#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> sum[n][m];</span><br><span class="line"><span class="comment">//sum二维数组的预处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sum[<span class="number">0</span>][<span class="number">0</span>] = arr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="comment">//处理第一列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) sum[i][<span class="number">0</span>] = sum[i - <span class="number">1</span>][<span class="number">0</span>] + arr[i][<span class="number">0</span>];</span><br><span class="line"><span class="comment">//处理第一行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) sum[<span class="number">0</span>][i] = sum[<span class="number">0</span>][i - <span class="number">1</span>] + arr[<span class="number">0</span>][i];</span><br><span class="line"><span class="comment">//处理非第一行且非第一列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; ++j)</span><br><span class="line">sum[i][j] = sum[i][j - <span class="number">1</span>] + sum[i - <span class="number">1</span>][j] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + arr[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到所查询矩阵的元素和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_sum</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x1 &amp;&amp; !y1) <span class="keyword">return</span> sum[x2][y2];</span><br><span class="line"><span class="keyword">if</span> (!x1) <span class="keyword">return</span> sum[x2][y2] - sum[x2][y1 - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (!y1) <span class="keyword">return</span> sum[x2][y2] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line"><span class="keyword">return</span> sum[x2][y2] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">pre_sum</span>();</span><br><span class="line"><span class="comment">//（1，1）和（2，2）构成的矩阵</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">get_sum</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>) &lt;&lt; endl;<span class="comment">//18</span></span><br><span class="line"><span class="comment">//（0，1）和（1，3）构成的矩阵</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">get_sum</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl;<span class="comment">//35</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><hr><h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><p>差分是一种和前缀和相对的策略，可以当作是求和的逆运算。它可以维护多次对序列的一个区间加上一个数，并在最后询问改变后的序列的数。下面以我们学校OJ平台的一道差分模板题来讲述：</p><img src="/post/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/3.png" class title="This is an example image"><p>对于这道题如果直接就是每次遍历区间再进行加数的处理，那时间复杂度是O(mn)看了一下m、n最大可以达到1e5，那最后的结果肯定会TLE（因为那时我刚开始就是那样做的hhh，那次也是第一次接触差分）</p><p>言归正传，用差分的方法来做这道题，首先定义一个数组arr[N]来存储原始数据，然后还要定义一个数组d[N]。对于数组d的元素，当i==0时，d[i]=arr[i]；当i&gt;=0时，d[i]=arr[i]-arr[i-1]；我们可以发现原数组arr其实是数组d的前缀和，这也是为什么说差分是一种和前缀和相对的策略；当想使区间[L,R]上的数都加上x时，只需要d[L]+=x,d[R+1]-=x即可。因为当d[L]+=x后，对于数组d的更新后的前缀和数组即arr来说，索引&gt;=L的元素都会加上x，而d[R+1]-=x的作用是使得arr数组中索引为&gt;=(R+1)的元素都减去x，那么最后的结果就是区间[L,R]的元素都加上x，这样执行区间修改操作的时间复杂度就只有O(m)</p><p>下面是题目的AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line">ll n, m, l, r, x, arr[N], d[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">d[i] = arr[i] - arr[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;</span><br><span class="line">d[l] += x;</span><br><span class="line">d[r + <span class="number">1</span>] -= x;<span class="comment">//一般会把数组开大一点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新后的arr数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = arr[i - <span class="number">1</span>] + d[i];</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p>对于二维差分同样使用二维前缀和的那个例子中的数组来讲述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用二维差分对该数组某个以(x<sub>1</sub>,y<sub>1</sub>)、(x<sub>2</sub>,y<sub>2</sub>)分别为左上角的点和右下角的点构成的矩阵内的元素进行修改，首先定义二维的差分数组d来记录修改（d初始化为0），假设对以(x<sub>1</sub>,y<sub>1</sub>)、(x<sub>2</sub>,y<sub>2</sub>)分别为左上角的点和右下角的点构成的矩阵内的元素同时加上value，那么可以使d[x<sub>1</sub>] [y<sub>1</sub>]+=value，d[x<sub>2</sub>+1] [y<sub>1</sub>]-=value，d[x<sub>1</sub>] [y<sub>2</sub>+1]-=value，d[x<sub>2</sub>+1] [y<sub>2</sub>+1]+=value，然后对二维数组d进行二维前缀和的处理即可得到原数组对应位置元素的改变值，执行d[x<sub>2</sub>+1] [y<sub>2</sub>+1]+=value操作是因为进行前缀和处理时以(x<sub>2</sub>+1,y<sub>2</sub>+1)为左上角顶点的矩阵内的元素被多减去了一个value；结果如下图所示：</p><img src="/post/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/4.png" class title="This is an example image"><p>代码演示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">3</span>, m = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> arr[n][m] = &#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;,</span><br><span class="line">&#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> d[<span class="number">5</span>][<span class="number">5</span>], sum[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">d[x1][y1] += val;</span><br><span class="line">d[x2 + <span class="number">1</span>][y1] -= val;</span><br><span class="line">d[x1][y2 + <span class="number">1</span>] -= val;</span><br><span class="line">d[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sum二维数组的预处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sum[<span class="number">0</span>][<span class="number">0</span>] = d[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="comment">//处理第一列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) sum[i][<span class="number">0</span>] = sum[i - <span class="number">1</span>][<span class="number">0</span>] + d[i][<span class="number">0</span>];</span><br><span class="line"><span class="comment">//处理第一行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) sum[<span class="number">0</span>][i] = sum[<span class="number">0</span>][i - <span class="number">1</span>] + d[<span class="number">0</span>][i];</span><br><span class="line"><span class="comment">//处理非第一行且非第一列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; ++j)</span><br><span class="line">sum[i][j] = sum[i][j - <span class="number">1</span>] + sum[i - <span class="number">1</span>][j] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + d[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将sum数组对应的改变映射会arr数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">arr[i][j] += sum[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">add</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>);<span class="comment">//(0,0),(2,1)形成的矩阵内的元素加3</span></span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-1</span>);<span class="comment">//(1,1),(2,2)形成的矩阵内的元素减1</span></span><br><span class="line"><span class="built_in">pre_sum</span>();</span><br><span class="line"><span class="built_in">result</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OJ例题"><a href="#OJ例题" class="headerlink" title="OJ例题"></a>OJ例题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><img src="/post/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/5.png" class title="This is an example image"><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, q, flag;</span><br><span class="line"><span class="type">int</span> d1[N], d2[N], d[N], sum[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line">cin &gt;&gt; flag &gt;&gt; l &gt;&gt; r;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">d1[l] += <span class="number">1</span>;</span><br><span class="line">d1[r + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">d2[l] += <span class="number">1</span>;</span><br><span class="line">d2[r + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">d1[i] += d1[i - <span class="number">1</span>];</span><br><span class="line">d2[i] += d2[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (d2[i] &gt;= <span class="number">1</span>)</span><br><span class="line">d[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (d1[i] &gt;= <span class="number">1</span>)</span><br><span class="line">d[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">d[i] = <span class="number">1</span>;</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + d[i];</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">cout &lt;&lt; sum[r] - sum[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>对于前缀和和差分还有其他类型以后待更新……</p>]]></content>
      
      
      <categories>
          
          <category> 算法范畴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展欧几里得算法(exgcd)</title>
      <link href="/post/exgcd.html"/>
      <url>/post/exgcd.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前置知识-不涉及证明"><a href="#前置知识-不涉及证明" class="headerlink" title="前置知识(不涉及证明)"></a>前置知识(不涉及证明)</h2><hr><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>欧几里得算法又称为辗转相除法，用于计算两个非负整数的最大公约数。对于非负整数a，b，当b不为0时，其最大公约数与非负整数b，a%b的最大公约数相同；当b为0时，a与b的最大公约数为a</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="裴蜀定理-贝祖定理"><a href="#裴蜀定理-贝祖定理" class="headerlink" title="裴蜀定理/贝祖定理"></a>裴蜀定理/贝祖定理</h3><p>对于任意整数a、b和它们的最大公约数d，关于未知数x和y的线性不定方程（称为<strong>裴蜀等式</strong>）：若a，b是整数，且gcd(a,b)=d，那么对于任意的整数x，y而言ax+by都一定是d的倍数，特别地一定存在整数x，y使得ax+by=d成立</p><blockquote><p>重要推论：a，b互质的充分必要条件是存在整数x，y使得ax+by=1</p></blockquote><h2 id="扩展欧几里得算法（exgcd）"><a href="#扩展欧几里得算法（exgcd）" class="headerlink" title="扩展欧几里得算法（exgcd）"></a>扩展欧几里得算法（exgcd）</h2><hr><ul><li><p>扩展欧几里德算法是用来在已知a，b 求解一组x，y ，使它们满足裴蜀（贝祖）等式：ax + by = gcd ⁡(a , b) = d</p></li><li><p>证明过程：</p><ul><li>当b = 0时，ax + by = a因此x = 1，y = 0</li><li>当b != 0时，经过以下推导       </li></ul><img src="/post/exgcd/1.png" class title="This is an example image"></li></ul><p>​        因此可以利用递归算法每次先求出下一层的x’和y’然后利用上述公式回代</p><ul><li>递归方式模板</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  ll d = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">  ll t = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = t - (a / b) * y;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li><p>用于求解ax + by = gcd(a , b)的解（即上述情况）</p></li><li><p>用于求解ax + by = c的解</p><ul><li><p>当c % gcd(a , b) != 0时，无解（依据裴蜀定理）</p></li><li><p>当c % gcd(a , b) = 0时，先利用exgcd求出ax + by = gcd(a , b)的解x<sub>0</sub>、y<sub>0</sub>，则可得到特解x’ = x<sub>0</sub> * c / gcd(a , b)，y’ = y<sub>0</sub> * c / gcd(a , b)，而通解 = 特解 + 齐次解（ax + by = 0的解），故通解为x = x’ + k * b / gcd(a , b)，y = y’ + k * a / gcd(a,b) (k为整数)</p></li></ul></li><li><p>求解一次同余方程:</p><img src="/post/exgcd/2.png" class title="This is an example image"><p>上述方程价于</p><img src="/post/exgcd/3.png" class title="This is an example image"><p>再利用应用2中的方法求解即可</p></li><li><p>求解ax + by = c的最小正整数解x模板</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a,LL b,LL &amp;x,LL &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="built_in">e_gcd</span>(b,a%b,x,y);</span><br><span class="line">    LL temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">cal</span><span class="params">(LL a,LL b,LL c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL x,y;</span><br><span class="line">    LL gcd=<span class="built_in">exgcd</span>(a,b,x,y);</span><br><span class="line">    <span class="keyword">if</span>(c%gcd!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    x*=c/gcd;<span class="comment">//转化为a*x+b*y=c的解</span></span><br><span class="line">    b/=gcd;<span class="comment">//约去c后原来b就变为了b/gcd;</span></span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">0</span>) b=-b;<span class="comment">//如果b为负数就去绝对值</span></span><br><span class="line">    LL ans=x%b;</span><br><span class="line">    <span class="keyword">if</span>(ans&lt;=<span class="number">0</span>) ans+=b;<span class="comment">//求最小正整数解</span></span><br><span class="line">    <span class="keyword">return</span> ans;<span class="comment">//返回的就是最小正整数解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考文章</p><p><a href="http://t.csdn.cn/SAzQN">http://t.csdn.cn/SAzQN</a></p><p><a href="http://t.csdn.cn/ZhE6r">http://t.csdn.cn/ZhE6r</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法范畴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++学习】STL基础</title>
      <link href="/post/C++%E4%B9%8BSTL.html"/>
      <url>/post/C++%E4%B9%8BSTL.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><h3 id="1-1-简要介绍"><a href="#1-1-简要介绍" class="headerlink" title="1.1 简要介绍"></a>1.1 简要介绍</h3><p>STL（Standard Template Library，标准模板库）广义上分为三类：algorithm（算法）、container（容器）和iterator（迭代器），几乎所有的代码都采用了模板类和模板函数的方式，提供了更好的代码重用机会</p><h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h3><ul><li>高可重用性</li><li>高性能</li><li>高移植性</li><li>跨平台</li></ul><h2 id="2-容器"><a href="#2-容器" class="headerlink" title="2.容器"></a>2.容器</h2><h3 id="2-1-容器的分类"><a href="#2-1-容器的分类" class="headerlink" title="2.1 容器的分类"></a>2.1 容器的分类</h3><ol><li><strong>序列式容器</strong><ul><li>每个元素都有固定位置——取决于插入时机和地点，和元素值无关</li><li>vector、deque、list、stack、queue</li></ul></li><li><strong>关联式容器</strong><ul><li>元素位置取决于特定的排序准则，和插入顺序无关</li><li>set、multiset、map、multimap</li></ul></li></ol><h3 id="2-2-vector"><a href="#2-2-vector" class="headerlink" title="2.2 vector"></a>2.2 vector</h3><h4 id="2-2-1-vector容器简介"><a href="#2-2-1-vector容器简介" class="headerlink" title="2.2.1 vector容器简介"></a>2.2.1 vector容器简介</h4><ul><li>vector是将元素置于一个动态数组中加以管理的容器</li><li>vector可以随机存取元素</li><li>vector尾部添加或移出元素非常快速，但是在中部或者头部插入或移出元素比较费时</li></ul><h4 id="2-2-2-vector对象的默认构造"><a href="#2-2-2-vector对象的默认构造" class="headerlink" title="2.2.2 vector对象的默认构造"></a>2.2.2 vector对象的默认构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; VecInt;<span class="comment">//一个存放int类型数据的vector容器</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; VecDou;<span class="comment">//一个存放double类型数据的vector容器</span></span><br><span class="line">vector&lt;string&gt; VecStr;<span class="comment">//一个存放string类型数据的vector容器</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CA</span>&#123;&#125;;</span><br><span class="line">vector&lt;CA*&gt; VecCA;<span class="comment">//一个存放CA对象指针的vector容器</span></span><br><span class="line">vector&lt;CA&gt; VecCA;<span class="comment">//一个存放CA对象的vector容器</span></span><br></pre></td></tr></table></figure><h4 id="2-2-3-vector对象的带参数构造"><a href="#2-2-3-vector对象的带参数构造" class="headerlink" title="2.2.3 vector对象的带参数构造"></a>2.2.3 vector对象的带参数构造</h4><ul><li>vector(beg,end);//构造函数将[beg,end)区间中的元素拷贝给本身（左闭右开区间）</li><li>vector(n,elem);//构造函数将n个elem拷贝给本身</li><li>vector(const vector &amp;vec);//拷贝构造函数</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(arr, arr + <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(v1)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">cout &lt;&lt; v3[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 2 3 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-4-vector对象的赋值"><a href="#2-2-4-vector对象的赋值" class="headerlink" title="2.2.4 vector对象的赋值"></a>2.2.4 vector对象的赋值</h4><ul><li>vector.assign(beg,end);//将[beg,end)区间中的数据拷贝赋值给本身（左闭右开区间）</li><li>vector.assign(n,elem);//将n个elem拷贝赋值给本身</li><li>vector&amp; operator=(const vector &amp;vec);//重载等号操作符</li><li>vector.swap(vec);//将vec与本身的元素互换</li></ul><blockquote><p>注：assign方法会将原来vector对象的元素清空再拷贝</p></blockquote><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1, v2, v3;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v1.<span class="built_in">assign</span>(arr, arr + <span class="number">5</span>);</span><br><span class="line">v2.<span class="built_in">assign</span>(<span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line">v3 = v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 2 3 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v2.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//10 10 10</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">swap</span>(v2);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//10 10 10</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v2.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 2 3 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-5-vector的大小"><a href="#2-2-5-vector的大小" class="headerlink" title="2.2.5 vector的大小"></a>2.2.5 vector的大小</h4><ul><li>vector.size();//返回容器中元素的个数</li><li>vector.empty();//判断vector对象是否为空</li><li>vector.resize(num);//重新制定容器的长度为num：若容器变长则以默认值0填充新位置；若容器变短则末尾超出容器长度的元素将被删除</li><li>vector.resize(num,elem);//重新制定容器的长度为num：若容器变长则以elem值填充新位置；若容器变短则末尾超出容器长度的元素将被删除</li></ul><h4 id="2-2-6-vector元素的访问方式"><a href="#2-2-6-vector元素的访问方式" class="headerlink" title="2.2.6 vector元素的访问方式"></a>2.2.6 vector元素的访问方式</h4><ul><li>vector[index]：返回索引index所指的数据（若下标越界<strong>可能</strong>会导致程序异常终止）</li><li>vector.at(index)：返回索引index所指的数据（若index越界则抛出out_of_range异常）</li></ul><h4 id="2-2-7-vector的插入删除"><a href="#2-2-7-vector的插入删除" class="headerlink" title="2.2.7 vector的插入删除"></a>2.2.7 vector的插入删除</h4><ul><li>vector.insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置</li><li>vector.insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值</li><li>vector.insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值</li><li>vector.push_back(elem);//在vector对象末尾插入元素elem</li><li>vector.pop_back();//把vector对象末尾元素删除</li><li>vector.clear();//清空vector容器中元素</li><li>vector.erase(pos);//删除在pos位置的元素，返回新数据的位置</li><li>vector.erase(beg,end);//删除[beg,end)区间内的元素</li></ul><blockquote><p>注：pos为vector::iterator</p></blockquote><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v1.<span class="built_in">assign</span>(arr, arr + <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 2 3</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 2 3 10</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 2 3</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 10 2 3</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 10 10 10 10 2 3</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>() + <span class="number">1</span>, arr + <span class="number">3</span>, arr + <span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 4 5 10 10 10 10 2 3</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>() + <span class="number">3</span>, v1.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">clear</span>();</span><br><span class="line">cout &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">//0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-8-vector容器的iterator类型"><a href="#2-2-8-vector容器的iterator类型" class="headerlink" title="2.2.8 vector容器的iterator类型"></a>2.2.8 vector容器的iterator类型</h4><ul><li>vector&lt; int &gt;::iterator iter;//变量名为iter，类型为正向迭代器，反向迭代器改为reverse_iterator</li><li>vector容器的迭代器属于随机访问迭代器：迭代器一次可以移动多个位置</li><li>成员函数：<ul><li>begin()：返回指向容器中第一个元素的正向迭代器</li><li>end()：返回指向容器中最后一个元素之后一个位置的正向迭代器</li><li>rbegin()：返回指向最后一个元素的反向迭代器</li><li>rend()：返回指向第一个元素前一个位置的反向迭代器</li><li>cbegin()：和begin()功能类似，只不过其返回的迭代器类型是常量正向迭代器，不能用于修改元素</li><li>cend()：和end()功能类似，只不过其返回的迭代器类型是常量正向迭代器，不能用于修改元素</li><li>crbegin()：和rbegin()功能类似，只不过其返回的迭代器类型是常量反向迭代器，不能用于修改元素</li><li>crend()：和rend()功能类似，只不过其返回的迭代器类型是常量反向迭代器，不能用于修改元素</li></ul></li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator idx = v1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (; idx != v1.<span class="built_in">end</span>(); ++idx)</span><br><span class="line">cout &lt;&lt; *idx &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//5 6 7 8 9</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v1.<span class="built_in">rbegin</span>(); it!= v1.<span class="built_in">rend</span>(); ++it)</span><br><span class="line"><span class="comment">//it依旧是递增</span></span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//9 8 7 6 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-9-vector容器的迭代器失效"><a href="#2-2-9-vector容器的迭代器失效" class="headerlink" title="2.2.9 vector容器的迭代器失效"></a>2.2.9 vector容器的迭代器失效</h4><ol><li>插入元素导致迭代器失效</li></ol><blockquote><p>问题演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = v1.<span class="built_in">begin</span>() + <span class="number">3</span>;</span><br><span class="line">v1.<span class="built_in">insert</span>(it, <span class="number">8</span>);</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;<span class="comment">//在VS中运行无结果，返回错误代码，视不同编译器</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原因</p></blockquote><p>因为在insert时，vector可能需要扩容，而扩容的本质是new一块新的空间，再将数据迁移过去；而在插入后若vector扩容，则原有的数据被释放，指向原有数据的迭代器就成了野指针，所以迭代器失效了 </p><blockquote><p>解决</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = v1.<span class="built_in">begin</span>() + <span class="number">3</span>;</span><br><span class="line">it = v1.<span class="built_in">insert</span>(it, <span class="number">8</span>);<span class="comment">//insert会返回一个新的有效的迭代器</span></span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;<span class="comment">//8</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>删除元素导致迭代器失效</li></ol><blockquote><p>问题演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = v1.<span class="built_in">begin</span>(); i != v1.<span class="built_in">end</span>(); ++i)</span><br><span class="line"><span class="keyword">if</span> (*i == <span class="number">3</span>)</span><br><span class="line">v1.<span class="built_in">erase</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//VS编译器无输出，返回错误代码</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原因</p></blockquote><p>对于序列式容器（如vector，deque），序列式容器就是数组式容器，删除当前元素的iterator会使得后面所有元素的iterator都失效。这是因为vector，deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置，所以不能使用erase(i++)的方式。</p><blockquote><p>解决</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = v1.<span class="built_in">begin</span>(); it != v1.<span class="built_in">end</span>();)</span><br><span class="line"><span class="keyword">if</span> (*it == <span class="number">3</span>)</span><br><span class="line">it = v1.<span class="built_in">erase</span>(it);<span class="comment">//erase返回删除后的一个有效的迭代器</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">it++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//1 2 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-deque"><a href="#2-3-deque" class="headerlink" title="2.3 deque"></a>2.3 deque</h3><h4 id="2-3-1-deque容器简介"><a href="#2-3-1-deque容器简介" class="headerlink" title="2.3.1 deque容器简介"></a>2.3.1 deque容器简介</h4><ul><li>deque是“double-ended queue”的缩写</li><li>deque是双端数组（可以向两端扩容）而vector是单端的</li><li>deque在接口上和vector非常相似，在许多操作的地方可以直接替换</li><li>deque可以随机存取元素（支持索引值直接存取，用[ ]操作符或at( )方法）</li><li>deque头部和尾部添加或移出元素都非常快速，但是在中部安插元素或移出元素比较费时</li><li>deque并非连续空间存储，它是分段连续的</li><li>使用需包含头文件&lt; deque &gt;</li></ul><h4 id="2-3-2-deque容器的操作"><a href="#2-3-2-deque容器的操作" class="headerlink" title="2.3.2 deque容器的操作"></a>2.3.2 deque容器的操作</h4><ul><li>deque与vector在操作上几乎一样，deque多两个函数：<ul><li>deque.push_front(elem);//在容器头部插入一个数据</li><li>deque.pop_front();//删除容器第一个数据</li></ul></li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; deq = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">deq.<span class="built_in">push_front</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; deq.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; deq[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//10 1 2 3 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">deq.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; deq.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; deq[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 2 3 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-list"><a href="#2-4-list" class="headerlink" title="2.4 list"></a>2.4 list</h3><h4 id="2-4-1-list容器简介"><a href="#2-4-1-list容器简介" class="headerlink" title="2.4.1 list容器简介"></a>2.4.1 list容器简介</h4><ul><li>list是一个双向链表容器，可以高效进行插入删除元素</li><li>list不可以随机存取元素，所以不支持at(pos)函数与[]操作符</li><li>list的迭代器支持自增、自减运算符，但<strong>不支持一个迭代器加上某个数字</strong></li><li>使用需要包含头文件&lt; list &gt; </li></ul><h4 id="2-4-2-list对象的默认构造"><a href="#2-4-2-list对象的默认构造" class="headerlink" title="2.4.2 list对象的默认构造"></a>2.4.2 list对象的默认构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstInt;<span class="comment">//定义一个存放int的list容器</span></span><br><span class="line">list&lt;string&gt; lstStr;<span class="comment">//定义一个存放string的list容器</span></span><br></pre></td></tr></table></figure><h4 id="2-4-3-list头尾的添加移除操作"><a href="#2-4-3-list头尾的添加移除操作" class="headerlink" title="2.4.3 list头尾的添加移除操作"></a>2.4.3 list头尾的添加移除操作</h4><ul><li>list.push_back(elem);//在容器尾部加入一个元素</li><li>list.pop_back();//删除容器中最后一个元素</li><li>list.push_front(elem);//在容器开头插入一个元素</li><li>list.pop_front();//从容器开头移除第一个元素</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lst;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">lst.<span class="built_in">push_back</span>(i);</span><br><span class="line">lst.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//100 5 6 7 8 9 10</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">lst.<span class="built_in">pop_back</span>();</span><br><span class="line">lst.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//5 6 7 8 9</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-4-list数据的存取"><a href="#2-4-4-list数据的存取" class="headerlink" title="2.4.4 list数据的存取"></a>2.4.4 list数据的存取</h4><ul><li>list.front();//返回list容器的第一个结点的值</li><li>list.back();//返回list容器的最后一个结点的值</li></ul><blockquote><p>注：可以通过list.front()=elem对第一个结点的值进行更改为elem；list.back()也同样可以</p></blockquote><h4 id="2-4-5-list与迭代器"><a href="#2-4-5-list与迭代器" class="headerlink" title="2.4.5 list与迭代器"></a>2.4.5 list与迭代器</h4><p>list容器的迭代器是“双向迭代器”：双向迭代器从两个方向读写容器，除了提供前向迭代器的全部操作之外，双向迭代器还提供前置和后置的自减运算</p><ul><li>list.begin();//返回容器中第一个元素的迭代器</li><li>list.end();//返回容器中最后一个元素之后的迭代器</li><li>list.rbegin();//返回容器中倒数第一个元素的迭代器</li><li>list.rend();//返回容器中倒数最后一个元素的后面的迭代器</li></ul><h4 id="2-4-6-list对象的带参数构造"><a href="#2-4-6-list对象的带参数构造" class="headerlink" title="2.4.6 list对象的带参数构造"></a>2.4.6 list对象的带参数构造</h4><ul><li>list(n,elem);//构造函数将n个elem拷贝给本身</li><li>list(beg,end);//构造函数将[beg,end)区间中的元素拷贝给本身</li><li>list(const list&amp; lst);//拷贝构造函数</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst1</span><span class="params">(vec.begin(),vec.begin()+<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst2</span><span class="params">(<span class="number">5</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst3</span><span class="params">(lst2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst1.<span class="built_in">begin</span>(); i != lst1.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 2 3</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst2.<span class="built_in">begin</span>(); i != lst2.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//100 100 100 100 100</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst3.<span class="built_in">begin</span>(); i != lst3.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//100 100 100 100 100</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-7-list对象的赋值"><a href="#2-4-7-list对象的赋值" class="headerlink" title="2.4.7 list对象的赋值"></a>2.4.7 list对象的赋值</h4><ul><li>list.assign(beg,end);//将[beg,end)区间中的数据拷贝赋值给本身（左闭右开区间）</li><li>list.assign(n,elem);//将n个elem拷贝赋值给本身</li><li>list&amp; operator=(const vector &amp;vec);//重载等号操作符</li><li>list.swap(vec);//将vec与本身的元素互换</li></ul><h4 id="2-4-8-list对象的大小"><a href="#2-4-8-list对象的大小" class="headerlink" title="2.4.8 list对象的大小"></a>2.4.8 list对象的大小</h4><ul><li>list.size();//返回容器中元素的个数</li><li>list.empty();//判断vector对象是否为空</li><li>list.resize(num);//重新制定容器的长度为num：若容器变长则以默认值0填充新位置；若容器变短则末尾超出容器长度的元素将被删除</li><li>list.resize(num,elem);//重新制定容器的长度为num：若容器变长则以elem值填充新位置；若容器变短则末尾超出容器长度的元素将被删除</li></ul><h4 id="2-4-9-list容器的插入"><a href="#2-4-9-list容器的插入" class="headerlink" title="2.4.9 list容器的插入"></a>2.4.9 list容器的插入</h4><ul><li>list.insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置</li><li>list.insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值</li><li>list.insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值</li></ul><blockquote><p>注：list.insert不会使得迭代器失效，因为插入结点后原结点没有释放以及位置没有改变</p></blockquote><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst</span><span class="params">(<span class="number">5</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it = lst.<span class="built_in">begin</span>();</span><br><span class="line">++it;</span><br><span class="line">lst.<span class="built_in">insert</span>(it, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//100 50 100 100 100 100</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"><span class="comment">//100</span></span><br><span class="line">lst.<span class="built_in">insert</span>(it, <span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//100 50 10 10 10 100 100 100 100</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-10-list容器的删除"><a href="#2-4-10-list容器的删除" class="headerlink" title="2.4.10 list容器的删除"></a>2.4.10 list容器的删除</h4><ul><li>list.clear();//移除容器中的所有元素</li><li>list.erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置</li><li>list.erase(pos);//删除pos位置的数据，返回下一个数据的位置</li><li>list.remove(elem);//删除容器中所有与elem值匹配的元素</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lst&#123;<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span>,<span class="number">56</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">23</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">lst.<span class="built_in">erase</span>(lst.<span class="built_in">begin</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//23 34 45 56 56 3 3 3 3 3 23</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it1, it2;</span><br><span class="line">it1 = it2 = lst.<span class="built_in">begin</span>();</span><br><span class="line">++it1;<span class="comment">//指向34</span></span><br><span class="line">++it2;</span><br><span class="line">++it2;</span><br><span class="line">++it2;<span class="comment">//指向56</span></span><br><span class="line"><span class="comment">//it1接受erase返回的位置</span></span><br><span class="line">it1 = lst.<span class="built_in">erase</span>(it1, it2);</span><br><span class="line">cout &lt;&lt; *it1 &lt;&lt; endl;<span class="comment">//56</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//23 56 56 3 3 3 3 3 23</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">lst.<span class="built_in">remove</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//23 56 56 23</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-11-list容器的反转"><a href="#2-4-11-list容器的反转" class="headerlink" title="2.4.11 list容器的反转"></a>2.4.11 list容器的反转</h4><ul><li>list.reserve();</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst&#123; <span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span> &#125;;</span><br><span class="line">lst.<span class="built_in">reverse</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//56 45 34 23 12</span></span><br></pre></td></tr></table></figure><h4 id="2-4-12-list容器的迭代器失效"><a href="#2-4-12-list容器的迭代器失效" class="headerlink" title="2.4.12 list容器的迭代器失效"></a>2.4.12 list容器的迭代器失效</h4><ul><li>删除结点导致迭代器失效</li></ul><blockquote><p>问题代码</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst&#123; <span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span> &#125;;</span><br><span class="line"><span class="comment">//报错：结点删除后，无法得到删除结点的next元素，重载后的++运算符无法进行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); ++i)</span><br><span class="line"><span class="keyword">if</span> (*i == <span class="number">34</span>)</span><br><span class="line">lst.<span class="built_in">erase</span>(i);</span><br></pre></td></tr></table></figure><blockquote><p>问题解决</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst&#123; <span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>();)</span><br><span class="line"><span class="keyword">if</span> (*i == <span class="number">34</span>)</span><br><span class="line">i = lst.<span class="built_in">erase</span>(i);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">++i;</span><br></pre></td></tr></table></figure><h3 id="2-5-stack"><a href="#2-5-stack" class="headerlink" title="2.5 stack"></a>2.5 stack</h3><h4 id="2-5-1-stack容器简介"><a href="#2-5-1-stack容器简介" class="headerlink" title="2.5.1 stack容器简介"></a>2.5.1 stack容器简介</h4><ul><li>stack是堆栈容器，是一种“先进后出”的容器</li><li>stack没有迭代器，因为该数据结构不允许遍历</li><li>使用需包含头文件&lt; stack &gt;</li></ul><h4 id="2-5-2-stack对象的默认构造"><a href="#2-5-2-stack对象的默认构造" class="headerlink" title="2.5.2 stack对象的默认构造"></a>2.5.2 stack对象的默认构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; stkint;<span class="comment">//一个存放int的stack容器</span></span><br><span class="line">stack&lt;<span class="type">float</span>&gt; stkfloat;<span class="comment">//一个存放float的stack容器</span></span><br><span class="line">stack&lt;string&gt; stkstr;<span class="comment">//一个存放string的stack容器</span></span><br></pre></td></tr></table></figure><h4 id="2-5-3-stack插入删除相关接口"><a href="#2-5-3-stack插入删除相关接口" class="headerlink" title="2.5.3 stack插入删除相关接口"></a>2.5.3 stack插入删除相关接口</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack.<span class="built_in">push</span>(elem);<span class="comment">//往栈顶添加元素</span></span><br><span class="line">stack.<span class="built_in">pop</span>();<span class="comment">//从栈顶移出第一个元素，不返回值</span></span><br><span class="line">stack.<span class="built_in">top</span>();<span class="comment">//访问栈顶元素并返回，可作为表达式的左值</span></span><br><span class="line">stack.<span class="built_in">empty</span>();<span class="comment">//判断stack容器是否为空</span></span><br></pre></td></tr></table></figure><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; stkint;</span><br><span class="line">stkint.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkint.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">stkint.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">stkint.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line"><span class="comment">//7 5 3 1</span></span><br><span class="line"><span class="keyword">while</span> (!stkint.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; stkint.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">stkint.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-4-stack拷贝构造与赋值"><a href="#2-5-4-stack拷贝构造与赋值" class="headerlink" title="2.5.4 stack拷贝构造与赋值"></a>2.5.4 stack拷贝构造与赋值</h4><ul><li>stack(const stack&amp; stk);//拷贝构造函数</li><li>stack&amp; operator=(const stack&amp; stk);//重载等号操作符</li></ul><h4 id="2-5-6-stack的大小"><a href="#2-5-6-stack的大小" class="headerlink" title="2.5.6 stack的大小"></a>2.5.6 stack的大小</h4><ul><li>stack.empty();//判断堆栈是否为空</li><li>stack.size();//返回堆栈的大小</li></ul><blockquote><p>注：stack没有提供resize方法</p></blockquote><h3 id="2-6-queue"><a href="#2-6-queue" class="headerlink" title="2.6 queue"></a>2.6 queue</h3><h4 id="2-6-1-queue容器简介"><a href="#2-6-1-queue容器简介" class="headerlink" title="2.6.1 queue容器简介"></a>2.6.1 queue容器简介</h4><ul><li>queue是队列容器，是一种“先进先出”的容器</li><li>queue没有迭代器</li><li>使用需包含&lt; queue &gt;头文件</li></ul><h4 id="2-6-2-queue对象的默认构造"><a href="#2-6-2-queue对象的默认构造" class="headerlink" title="2.6.2 queue对象的默认构造"></a>2.6.2 queue对象的默认构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; queint;<span class="comment">//一个存放int数据的queue容器</span></span><br><span class="line">queue&lt;string&gt; questr;<span class="comment">//一个存放string数据的queue容器</span></span><br></pre></td></tr></table></figure><h4 id="2-6-3-queue插入删除相关接口"><a href="#2-6-3-queue插入删除相关接口" class="headerlink" title="2.6.3 queue插入删除相关接口"></a>2.6.3 queue插入删除相关接口</h4><ul><li>queue.push(elem);//往队尾添加元素</li><li>queue.pop();//从队头移除第一个元素</li><li>queue.front();//返回队头元素，可作为表达式的左值</li><li>queue.back();//返回队尾元素，可作为表达式的左值</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">q1.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">q1.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">q1.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">q1.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line"><span class="comment">//1 3 5 7</span></span><br><span class="line"><span class="keyword">while</span> (!q1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; q1.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">q1.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-4-queue拷贝构造与赋值"><a href="#2-6-4-queue拷贝构造与赋值" class="headerlink" title="2.6.4 queue拷贝构造与赋值"></a>2.6.4 queue拷贝构造与赋值</h4><ul><li>queue(const queue&amp; que);//拷贝构造函数</li><li>queue&amp; operator=(const queue&amp; que);//重载等号操作符</li></ul><h4 id="2-6-5-queue的大小"><a href="#2-6-5-queue的大小" class="headerlink" title="2.6.5 queue的大小"></a>2.6.5 queue的大小</h4><ul><li>queue.empty();//判断队列是否为空</li><li>queue.size();//返回队列中元素个数</li></ul><h3 id="2-7-set"><a href="#2-7-set" class="headerlink" title="2.7 set"></a>2.7 set</h3><h4 id="2-7-1-set-multiset容器简介"><a href="#2-7-1-set-multiset容器简介" class="headerlink" title="2.7.1 set/multiset容器简介"></a>2.7.1 set/multiset容器简介</h4><ul><li>set是一个集合容器，其中所包含的元素是<strong>唯一</strong>的（去重），<strong>集合中的元素按一定的顺序排列</strong>。元素插入过程是按排序规则插入，所以不能插入指定位置</li><li>set采用<strong>红黑树</strong>变体的数据结构，红黑树属于平衡二叉树，在插入和删除操作上比vector快</li><li>set不可以直接存取元素（不可以使用at.(pos)与[]操作符）</li><li>multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中同一个值可以出现多次</li><li>不可以直接修改set或multiset容器中的元素值，因为该类容器时自动排序的；如果希望修改一个元素值，必须先删除原有元素，再插入新的元素</li><li>使用需包含&lt; set &gt;头文件</li></ul><h4 id="2-7-2-set-multiset对象默认构造"><a href="#2-7-2-set-multiset对象默认构造" class="headerlink" title="2.7.2 set/multiset对象默认构造"></a>2.7.2 set/multiset对象默认构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; setint;<span class="comment">//一个存放int的set容器</span></span><br><span class="line">set&lt;string&gt; setstr;<span class="comment">//一个存放string的set容器</span></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; mulsetint;<span class="comment">//一个存放int的multiset容器</span></span><br></pre></td></tr></table></figure><h4 id="2-7-3-set容器的插入和迭代器"><a href="#2-7-3-set容器的插入和迭代器" class="headerlink" title="2.7.3 set容器的插入和迭代器"></a>2.7.3 set容器的插入和迭代器</h4><ul><li>set.insert(elem);//在容器中插入元素</li><li>set.insert(beg,end);//插入范围[beg,end)内的元素</li><li>set.begin();//返回容器中第一个数据的迭代器</li><li>set.end();//返回容器中最后一个数据之后的迭代器</li><li>set.rbegin();//返回容器中倒数第一个元素的迭代器</li><li>set.rend();//返回容器中倒数最后一个元素的后面的迭代器</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line"><span class="comment">//1 3 5 7</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = s1.<span class="built_in">begin</span>(); i != s1.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//7 5 3 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = s1.<span class="built_in">rbegin</span>(); i != s1.<span class="built_in">rend</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="2-7-4-set容器的拷贝构造和赋值"><a href="#2-7-4-set容器的拷贝构造和赋值" class="headerlink" title="2.7.4 set容器的拷贝构造和赋值"></a>2.7.4 set容器的拷贝构造和赋值</h4><ul><li>set(const set&amp; st);//拷贝构造函数</li><li>set&amp; operator=(const set&amp; st);</li><li>set.swap(st);//交换两个集合容器</li></ul><h4 id="2-7-5-set的大小"><a href="#2-7-5-set的大小" class="headerlink" title="2.7.5 set的大小"></a>2.7.5 set的大小</h4><ul><li>set.size();//返回容器中元素的个数</li><li>set.empty();//判断容器是否为空</li></ul><h4 id="2-7-6-set容器的删除"><a href="#2-7-6-set容器的删除" class="headerlink" title="2.7.6 set容器的删除"></a>2.7.6 set容器的删除</h4><ul><li>set.clear();//清楚所有元素</li><li>set.erase(pos);//删除迭代器pos（不可以为反向迭代器）所指的元素，返回下一个元素的迭代器</li><li>set.erase(beg,end);//删除区间[beg,end)的所有元素</li><li>set.erase(elem);//删除容器中值为elem的元素；元素存在返回true，否则返回false</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">s1.<span class="built_in">erase</span>(s1.<span class="built_in">begin</span>());</span><br><span class="line"><span class="comment">//3 5 7</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = s1.<span class="built_in">begin</span>(); i != s1.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">s1.<span class="built_in">erase</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//3 7</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = s1.<span class="built_in">begin</span>(); i != s1.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="2-7-8-set容器的元素排序"><a href="#2-7-8-set容器的元素排序" class="headerlink" title="2.7.8 set容器的元素排序"></a>2.7.8 set容器的元素排序</h4><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>,less&lt;<span class="type">int</span>&gt;&gt; setintA;<span class="comment">//该容器是按照升序方式排列元素</span></span><br><span class="line">set&lt;<span class="type">int</span>,greater&lt;<span class="type">int</span>&gt;&gt; setintB;<span class="comment">//该容器是按降序方式排列元素</span></span><br></pre></td></tr></table></figure><ul><li>默认情况是升序</li><li>less&lt; int &gt;与greater&lt; int &gt;中的int可以更改，要与set容纳的数据类型一致</li></ul><h4 id="2-7-9-set容器的查找"><a href="#2-7-9-set容器的查找" class="headerlink" title="2.7.9 set容器的查找"></a>2.7.9 set容器的查找</h4><ul><li>set.find(elem);//查找elem元素，返回指向elem元素的迭代器</li><li>set.count(elem);//返回容器中值为elem的元素个数：对set来说，要么是0，要么是1；对multiset来说，值可能大于1</li><li>set.lower_bound(elem);//返回第一个&gt;=elem元素的迭代器</li><li>set.upper_bound(elem);//返回第一个&gt;elem元素的迭代器</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">12</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">43</span>);</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">if</span> (s1.<span class="built_in">find</span>(<span class="number">43</span>) != s1.<span class="built_in">end</span>())<span class="comment">//找不到返回set.end()</span></span><br><span class="line">&#123;</span><br><span class="line">it = s1.<span class="built_in">find</span>(<span class="number">43</span>);</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;<span class="comment">//43</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">count</span>(<span class="number">12</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s1.<span class="built_in">count</span>(<span class="number">100</span>);<span class="comment">//1 0</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *s1.<span class="built_in">lower_bound</span>(<span class="number">12</span>) &lt;&lt; endl;<span class="comment">//12</span></span><br><span class="line">cout &lt;&lt; *s1.<span class="built_in">upper_bound</span>(<span class="number">12</span>) &lt;&lt; endl;<span class="comment">//43</span></span><br></pre></td></tr></table></figure><h4 id="2-7-10-set容器set-equal-range-elem"><a href="#2-7-10-set容器set-equal-range-elem" class="headerlink" title="2.7.10 set容器set.equal_range(elem)"></a>2.7.10 set容器set.equal_range(elem)</h4><ul><li>返回容器中与elem相等的上下限的两个迭代器，上限是闭区间，下限是开区间即[beg,end)；相当于返回set.lower_bound(elem)与set.upper_bound(elem)两个迭代器</li><li>函数返回的迭代器被封装到pair中<ul><li>pair是对组，可以将两个值视为一个单元</li><li>pair&lt;T1,T2&gt;存放的两个值的类型，可以不一样，亦可以为自定义类型</li><li>pair.first是pair里面的第一个值，为T1类型</li><li>pair.second是pair里面的第二个值，为T2类型</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;set&lt;<span class="type">int</span>&gt;::iterator,set&lt;<span class="type">int</span>&gt;::iterator&gt; pairIt=set.<span class="built_in">equal_range</span>(elem)</span><br></pre></td></tr></table></figure><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">12</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">43</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, set&lt;<span class="type">int</span>&gt;::iterator &gt; it;</span><br><span class="line">it = s1.<span class="built_in">equal_range</span>(<span class="number">7</span>);</span><br><span class="line"><span class="keyword">if</span> (it.first != s1.<span class="built_in">end</span>() &amp;&amp; it.second != s1.<span class="built_in">end</span>())</span><br><span class="line"><span class="comment">//上下限都存在的情况下</span></span><br><span class="line"><span class="comment">//7 10</span></span><br><span class="line">cout &lt;&lt; *(it.first) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *(it.second) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;no find&quot;</span> &lt;&lt; endl;</span><br><span class="line">it = s1.<span class="built_in">equal_range</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (it.first != s1.<span class="built_in">end</span>() &amp;&amp; it.second != s1.<span class="built_in">end</span>())</span><br><span class="line"><span class="comment">//上下限都存在的情况下</span></span><br><span class="line">cout &lt;&lt; *(it.first) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *(it.second) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//no find</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;no find&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="2-8-map"><a href="#2-8-map" class="headerlink" title="2.8 map"></a>2.8 map</h3><h4 id="2-8-1-map-multimap容器简介"><a href="#2-8-1-map-multimap容器简介" class="headerlink" title="2.8.1 map/multimap容器简介"></a>2.8.1 map/multimap容器简介</h4><ul><li><p>map的特性是，所有的元素会根据元素的键值自动排序</p></li><li><p>map的所有的元素都是pair：</p><ul><li>pair的第一元素被视为键值key，第二元素被视为实值value；</li><li>map不允许两个元素有相同的键值</li></ul></li><li><p>不能通过迭代器改变map的键值，但是可以任意修改实值</p></li><li><p>multimap键值可以重复</p></li><li><p>map和multimap都是以<strong>红黑树</strong>作为底层实现机制</p></li></ul><h4 id="2-8-2-map-multimap容器对象的默认构造"><a href="#2-8-2-map-multimap容器对象的默认构造" class="headerlink" title="2.8.2 map/multimap容器对象的默认构造"></a>2.8.2 map/multimap容器对象的默认构造</h4><ul><li>map/multimap采用模板类实现，默认构造形式：<ul><li>map&lt;T1,T2&gt; mapTT;</li><li>multimap&lt;T1,T2&gt; multimapTT;</li></ul></li><li>T1,T2还可以是各种指针类型或自定义类型</li></ul><h4 id="2-8-3-map容器的插入"><a href="#2-8-3-map容器的插入" class="headerlink" title="2.8.3 map容器的插入"></a>2.8.3 map容器的插入</h4><ul><li>通过pair的方式插入对象：map.insert(pair&lt;T1,T2&gt;(key,value));（推荐使用）</li><li>通过value_type的方式插入对象：map.insert(map&lt;T1,T2&gt;::value_type(key,value));（推荐使用）</li><li>通过数组的形式插入值：map[key]=value;//如果key不再map内会被放在map内先获得默认值</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">STU</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">STU</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">STU</span>(<span class="type">int</span> id, string name) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;ID = id;</span><br><span class="line"><span class="keyword">this</span>-&gt;Name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> ID;</span><br><span class="line">string Name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, STU&gt; students;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">STU <span class="title">s1</span><span class="params">(i, <span class="string">&quot;Lucy&quot;</span> + to_string(i))</span></span>;</span><br><span class="line">students.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,STU&gt;(i, s1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = students.<span class="built_in">begin</span>(); i != students.<span class="built_in">end</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;<span class="type">int</span>, STU&gt; it = *i;</span><br><span class="line">cout &lt;&lt; it.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it.second.Name &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//不构建pair对组的方式：</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; i-&gt;first &lt;&lt; &quot;: &quot; &lt;&lt; i-&gt;second.Name &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//0: Lucy0</span></span><br><span class="line"><span class="comment">//1: Lucy1</span></span><br><span class="line"><span class="comment">//2: Lucy2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：第三种方法存在一个性能问题：如果key存在的话就要执行修改，而修改是先删除该pair再添加新的pair</p></blockquote><blockquote><p>注：insert方法在key存在时不会覆盖原来的键值对，而数组的方式在key存在时会覆盖原来的键值对</p></blockquote><h4 id="2-8-4-map容器对象获取键对应的值"><a href="#2-8-4-map容器对象获取键对应的值" class="headerlink" title="2.8.4 map容器对象获取键对应的值"></a>2.8.4 map容器对象获取键对应的值</h4><ul><li>使用[]，但是当key不存在时会将其插入，value为默认值</li><li>使用find函数：成功返回对应的迭代器，失败返回map.end()（推荐使用）</li><li>使用at()函数，如果键值对不存在会抛出”out_of_range”异常</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">STU</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">STU</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">STU</span>(<span class="type">int</span> id, string name) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;ID = id;</span><br><span class="line"><span class="keyword">this</span>-&gt;Name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> ID;</span><br><span class="line">string Name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, STU&gt; students;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">STU <span class="title">s1</span><span class="params">(i, <span class="string">&quot;Lucy&quot;</span> + to_string(i))</span></span>;</span><br><span class="line">students.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,STU&gt;(i, s1));</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; students[<span class="number">1</span>].Name &lt;&lt; endl;<span class="comment">//Lucy1</span></span><br><span class="line"><span class="keyword">if</span> (students.<span class="built_in">find</span>(<span class="number">2</span>) != students.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> it = students.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; it-&gt;second.Name &lt;&lt; endl;<span class="comment">//Lucy2</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No Find!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; students.<span class="built_in">at</span>(<span class="number">3</span>).Name &lt;&lt; endl;<span class="comment">//报错</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-算法"><a href="#3-算法" class="headerlink" title="3.算法"></a>3.算法</h2><h3 id="3-1-函数对象"><a href="#3-1-函数对象" class="headerlink" title="3.1 函数对象"></a>3.1 函数对象</h3><p>重载函数调用操作符的类，其对象常称为函数对象(function object)，即它们是行为类似函数的对象，也叫仿函数(functor)，其实就是重载”()”运算符，使得类对象可以像函数那样调用</p><blockquote><p>注意</p></blockquote><ul><li>函数对象（仿函数）是一个类，不是一个函数</li><li>函数对象（仿函数）重载了”()”操作符，使得它可以像函数一样调用</li></ul><blockquote><p>分类</p></blockquote><ul><li>如果函数对象有一个参数叫：一元函数对象</li><li>如果函数对象有两个参数叫：二元函数对象</li><li>如果函数对象有三个参数叫：三元函数对象</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line">Print op;<span class="comment">//op为一元函数对象</span></span><br><span class="line"><span class="built_in">op</span>(<span class="string">&quot;Hello world!&quot;</span>);<span class="comment">//Hello world!</span></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="built_in">Print</span>()(<span class="string">&quot;Hello world!&quot;</span>);<span class="comment">//Hello world!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结</p></blockquote><ul><li><p>函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题</p></li><li><p>函数对象超出普通函数的概念，函数对象可以有自己的状态</p></li><li><p>函数对象可内联编译，性能好，用函数指针几乎不可能</p></li><li><p>模板函数对象使函数对象具有通用性</p></li></ul><h3 id="3-2-谓词"><a href="#3-2-谓词" class="headerlink" title="3.2 谓词"></a>3.2 谓词</h3><p>返回值为bool类型的普通函数或仿函数都叫谓词：</p><ul><li>如果谓词有一个参数叫：一元谓词</li><li>如果谓词有两个参数叫：二元谓词</li></ul><h4 id="3-2-1-一元谓词"><a href="#3-2-1-一元谓词" class="headerlink" title="3.2.1 一元谓词"></a>3.2.1 一元谓词</h4><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greaterthan30</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &gt; <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greaterthan30</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &gt; <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">v1.<span class="built_in">push_back</span>(i * <span class="number">10</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="comment">//find_if条件查找:find_if会将容器区间对应的“元素”传给第三个参数</span></span><br><span class="line"><span class="comment">//普通函数方式</span></span><br><span class="line"><span class="comment">/*it = find_if(v1.begin(), v1.end(), greaterthan30);*/</span></span><br><span class="line"><span class="comment">//仿函数方式</span></span><br><span class="line">it = <span class="built_in">find_if</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">Greaterthan30</span>());</span><br><span class="line"><span class="keyword">if</span> (it != v1.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;<span class="comment">//40</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-二元谓词"><a href="#3-2-2-二元谓词" class="headerlink" title="3.2.2 二元谓词"></a>3.2.2 二元谓词</h4><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-内建函数对象"><a href="#3-3-内建函数对象" class="headerlink" title="3.3 内建函数对象"></a>3.3 内建函数对象</h3><p>STL内建了一些函数对象，分为以下三种：算术类函数对象、关系运算符类函数对象、逻辑运算符类函数对象。这些仿函数所产生的对象用法和一般函数完全相同，当然也可以产生无名的临时对象来履行函数功能</p><ul><li> 算术类函数对象，除了negate是一元运算，其他都是二元运算</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T plus&lt;T&gt;<span class="comment">//加法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T minus&lt;T&gt;<span class="comment">//减法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T multiplies&lt;T&gt;<span class="comment">//乘法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T divides&lt;T&gt;<span class="comment">//除法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T modules&lt;T&gt;<span class="comment">//取模仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T negate&lt;T&gt;<span class="comment">//取反仿函数</span></span><br></pre></td></tr></table></figure><ul><li>关系运算类函数对象，每一种都是二元运算</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">bool</span> equal_to&lt;T&gt;<span class="comment">//等于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">bool</span> not_equal_to&lt;T&gt;<span class="comment">//不等于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">bool</span> greater&lt;T&gt;<span class="comment">//大于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">bool</span> greater_equal&lt;T&gt;<span class="comment">//大于等于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">bool</span> less&lt;T&gt;<span class="comment">//小于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">bool</span> less_equal&lt;T&gt;<span class="comment">//小于等于</span></span><br></pre></td></tr></table></figure><ul><li>逻辑运算类运算函数，not为一元运算，其余为二元运算</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">bool</span> logical_and&lt;T&gt;<span class="comment">//逻辑与</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">bool</span> logical_or&lt;T&gt;<span class="comment">//逻辑或</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">bool</span> logical_not&lt;T&gt;<span class="comment">//逻辑非</span></span><br></pre></td></tr></table></figure><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//30 20 10 5</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-适配器"><a href="#3-4-适配器" class="headerlink" title="3.4 适配器"></a>3.4 适配器</h3><ul><li>适配器为算法提供接口</li><li>使用需包含头文件&lt; functional &gt;</li></ul><h4 id="3-4-1-函数对象适配器"><a href="#3-4-1-函数对象适配器" class="headerlink" title="3.4.1 函数对象适配器"></a>3.4.1 函数对象适配器</h4><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span><span class="comment">//提供适配器</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//第二步：公共继承binary_function参数萃取</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintInt</span>:<span class="keyword">public</span> binary_function&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">void</span>&gt;<span class="comment">//形参类型+返回值类型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//第三步：const修饰operator()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> tmp)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">cout &lt;&lt; val + tmp &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//第一步：bind2nd或bind1st绑定参数，因为for_each只有3个参数</span></span><br><span class="line"><span class="comment">//bind2nd和bind1st区别主要是将100这个实参绑定到哪个形参位置</span></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">PrintInt</span>(), <span class="number">100</span>));</span><br><span class="line">    <span class="comment">//120 110 130 105</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-2-函数指针适配器ptr-fun"><a href="#3-4-2-函数指针适配器ptr-fun" class="headerlink" title="3.4.2 函数指针适配器ptr_fun"></a>3.4.2 函数指针适配器ptr_fun</h4><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span><span class="comment">//提供适配器</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrintInt</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> temp)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; val + temp &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">ptr_fun</span>(myPrintInt), <span class="number">100</span>));</span><br><span class="line">    <span class="comment">//120 110 130 105</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明</p></blockquote><ul><li>上述例子中for_each最后一个参数是需要传递函数入口地址，但是C++中函数名代表不了函数入口地址，在C++编译器里会通过函数名和形参类型共同决定函数入口地址，所以就要使用函数指针的宏<strong>ptr_fun</strong>让底层把ptr_fun(FunctionName)换成这个函数的入口地址</li><li>使用ptr_fun同样需包含头文件&lt; functional &gt;</li><li>ptr_fun将普通函数适配为一个仿函数</li></ul><h4 id="3-4-3-成员函数适配器mem-fun-ref"><a href="#3-4-3-成员函数适配器mem-fun-ref" class="headerlink" title="3.4.3 成员函数适配器mem_fun_ref"></a>3.4.3 成员函数适配器mem_fun_ref</h4><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span><span class="comment">//提供适配器</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Data</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Data</span>(<span class="type">int</span> val) &#123; data = val; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintInt</span><span class="params">(<span class="type">int</span> tmp)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; data + tmp &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Data&gt; v;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="built_in">Data</span>(<span class="number">10</span>));</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="built_in">Data</span>(<span class="number">20</span>));</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="built_in">Data</span>(<span class="number">30</span>));</span><br><span class="line">    <span class="comment">//成员函数必须是容器存放对象的成员函数</span></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">mem_fun_ref</span>(&amp;Data::PrintInt), <span class="number">100</span>));</span><br><span class="line"><span class="comment">//110 120 130</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明</p></blockquote><ul><li><p>mem_fun_ref是一种适配器，该函数能将类的成员函数包装成仿函数使用，于是成员函数可以搭配各种泛型算法完成所谓的多态调用</p></li><li><p>使用需包含头文件&lt; functional &gt;</p></li><li><p>mem_fun_ref和mem_fun的作用和用法一样，唯一不同的就是当容器中存放的是对象实体时用mem_fun_ref，当容器中存放的时对象的指针时用mem_fun</p></li></ul><h4 id="3-4-4-取反适配器"><a href="#3-4-4-取反适配器" class="headerlink" title="3.4.4 取反适配器"></a>3.4.4 取反适配器</h4><ul><li>一元取反</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span><span class="comment">//提供适配器</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">8</span>)));</span><br><span class="line"><span class="keyword">if</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;<span class="comment">//5</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二元取反</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span><span class="comment">//提供适配器</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [=](<span class="type">int</span> val) &#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//10 5 30 20</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not2</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()));</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [=](<span class="type">int</span> val) &#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//5 10 20 30</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>lambda表达式（C++11才支持）</p></blockquote><ul><li>[  ]：里面什么都不写，lambda不能识别外部数据</li><li>[=]：lambda能对外部数据进行读操作</li><li>[&amp;]：lambda能对外部数据进行读写操作</li></ul><h3 id="3-5-常用遍历算法"><a href="#3-5-常用遍历算法" class="headerlink" title="3.5 常用遍历算法"></a>3.5 常用遍历算法</h3><h4 id="3-5-1-for-each遍历算法"><a href="#3-5-1-for-each遍历算法" class="headerlink" title="3.5.1 for_each遍历算法"></a>3.5.1 for_each遍历算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">遍历算法 遍历容器元素</span></span><br><span class="line"><span class="comment">@param beg 开始迭代器</span></span><br><span class="line"><span class="comment">@param end 结束迭代器</span></span><br><span class="line"><span class="comment">@param _callback 函数回调或者函数对象</span></span><br><span class="line"><span class="comment">@return 函数对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">for_each(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure><h4 id="3-5-2-transform算法"><a href="#3-5-2-transform算法" class="headerlink" title="3.5.2 transform算法"></a>3.5.2 transform算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">transform算法 将指定容器区间元素搬运到另一容器中</span></span><br><span class="line"><span class="comment">注意： transform不会给目标容器分配内存，需要提前分配好内存</span></span><br><span class="line"><span class="comment">@param beg1 源容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end1 源容器结束迭代器</span></span><br><span class="line"><span class="comment">@param beg2 目标容器开始迭代器</span></span><br><span class="line"><span class="comment">@param _callback 函数回调或者函数对象</span></span><br><span class="line"><span class="comment">@return 返回目标容器迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">transform</span>(iterator beg1, iterator end1, iterator beg2, _callback);</span><br></pre></td></tr></table></figure><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myTransform</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">v2.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">transform</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(),myTransform);</span><br><span class="line">for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), [=](<span class="type">int</span> v) &#123;</span><br><span class="line">cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//10 5 30 20</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-常用查找算法"><a href="#3-6-常用查找算法" class="headerlink" title="3.6 常用查找算法"></a>3.6 常用查找算法</h3><h4 id="3-6-1-find算法"><a href="#3-6-1-find算法" class="headerlink" title="3.6.1 find算法"></a>3.6.1 find算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">find算法 查找元素</span></span><br><span class="line"><span class="comment">@prama beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@prama end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@prama value 查找的元素</span></span><br><span class="line"><span class="comment">@return 返回查找元素的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">find</span>(iterator beg, iterator end, value);</span><br></pre></td></tr></table></figure><h4 id="3-6-2-find-if算法"><a href="#3-6-2-find-if算法" class="headerlink" title="3.6.2 find_if算法"></a>3.6.2 find_if算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">find_if算法 条件查找</span></span><br><span class="line"><span class="comment">@prama beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@prama end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@prama _callback 回调函数或谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">@return 返回指定位置迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">find_if</span>(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure><h4 id="3-6-3-adjacent-find算法"><a href="#3-6-3-adjacent-find算法" class="headerlink" title="3.6.3 adjacent_find算法"></a>3.6.3 adjacent_find算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">adjacent_find算法 查找相邻重复元素</span></span><br><span class="line"><span class="comment">@prama beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@prama end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@prama _callback 回调函数或谓词(返回bool类型的函数对象)一般没有就空着</span></span><br><span class="line"><span class="comment">@return 返回相邻元素的第一个位置的代码，无则返回end迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">adjacent_find</span>(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure><h4 id="3-6-4-binary-search算法"><a href="#3-6-4-binary-search算法" class="headerlink" title="3.6.4 binary_search算法"></a>3.6.4 binary_search算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">binary_search算法 二分查找法</span></span><br><span class="line"><span class="comment">注意：在无序序列中不可用</span></span><br><span class="line"><span class="comment">@prama beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@prama end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@prama value 查找的元素</span></span><br><span class="line"><span class="comment">@return bool 查找成功返回true否则false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binary_search</span><span class="params">(iterator beg, iterator end, value)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-6-5-count算法"><a href="#3-6-5-count算法" class="headerlink" title="3.6.5 count算法"></a>3.6.5 count算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">count算法 统计元素出现次数</span></span><br><span class="line"><span class="comment">@prama beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@prama end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@prama value 查找的元素</span></span><br><span class="line"><span class="comment">@return 元素出现的次数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">count</span>(iterator beg, iterator end, value);</span><br></pre></td></tr></table></figure><h4 id="3-6-6-count-if算法"><a href="#3-6-6-count-if算法" class="headerlink" title="3.6.6 count_if算法"></a>3.6.6 count_if算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">count_if算法 按条件统计元素出现次数</span></span><br><span class="line"><span class="comment">@prama beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@prama end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@prama _callback 回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">@return 元素出现的次数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">count_if</span>(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">count_if</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">15</span>));<span class="comment">//2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-常用排序算法"><a href="#3-7-常用排序算法" class="headerlink" title="3.7 常用排序算法"></a>3.7 常用排序算法</h3><h4 id="3-7-1-merge算法"><a href="#3-7-1-merge算法" class="headerlink" title="3.7.1 merge算法"></a>3.7.1 merge算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">merge算法 容器元素合并，并存储到另一容器中</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">* 两个源容器必须是有序的</span></span><br><span class="line"><span class="comment">* 不会给目标容器分配内存，需要提前分配好内存</span></span><br><span class="line"><span class="comment">@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">@param dest 目标容器开始迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">merge</span>(iterator beg1, iterator end1,iterator beg2, iterator end2,iterator dest);</span><br></pre></td></tr></table></figure><h4 id="3-7-2-sort算法"><a href="#3-7-2-sort算法" class="headerlink" title="3.7.2 sort算法"></a>3.7.2 sort算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sort算法 容器元素排序</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param _callback 回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">sort</span>(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure><h4 id="3-7-3-random-shuffle算法"><a href="#3-7-3-random-shuffle算法" class="headerlink" title="3.7.3 random_shuffle算法"></a>3.7.3 random_shuffle算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">random_shuffle算法 对指定范围内的元素随机调整次序</span></span><br><span class="line"><span class="comment">注意：可以使用随机数种子srand(time(NULL))保证每次随机不同</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">random_shuffle</span>(iterator beg, iterator end);</span><br></pre></td></tr></table></figure><h4 id="3-7-4-reverse算法"><a href="#3-7-4-reverse算法" class="headerlink" title="3.7.4 reverse算法"></a>3.7.4 reverse算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reverse算法 反转指定范围的元素</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">reverse</span>(iterator beg,iterator end);</span><br></pre></td></tr></table></figure><h3 id="3-8-常用拷贝替换算法"><a href="#3-8-常用拷贝替换算法" class="headerlink" title="3.8 常用拷贝替换算法"></a>3.8 常用拷贝替换算法</h3><h4 id="3-8-1-copy算法"><a href="#3-8-1-copy算法" class="headerlink" title="3.8.1 copy算法"></a>3.8.1 copy算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">copy算法 将容器内指定范围的元素拷贝到另一容器中</span></span><br><span class="line"><span class="comment">注意： copy不会给目标容器分配内存，需要提前分配好内存</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param dest 目标起始迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">copy</span>(iterator beg, iterator end, iterator dest);</span><br></pre></td></tr></table></figure><blockquote><p>实例演示（打印容器元素的新方法）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span><span class="comment">//提供终端迭代器</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">//10 5 30 20</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-8-2-replace算法"><a href="#3-8-2-replace算法" class="headerlink" title="3.8.2 replace算法"></a>3.8.2 replace算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">replace算法 将容器内指定范围内的旧元素修改为新元素</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param oldval 旧元素</span></span><br><span class="line"><span class="comment">@param newval 新元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">replace</span>(iterator beg, iterator end, oldval, newval);</span><br></pre></td></tr></table></figure><h4 id="3-8-3-replace-if算法"><a href="#3-8-3-replace-if算法" class="headerlink" title="3.8.3 replace_if算法"></a>3.8.3 replace_if算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">replace_if算法 将容器内指定范围内的满足条件的元素修改为新元素</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param _callback 函数回调或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">@param newval 新元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">replace_if</span>(iterator beg, iterator end, _callback, newval);</span><br></pre></td></tr></table></figure><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span><span class="comment">//提供终端迭代器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LessThan15</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &lt;= <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">replace_if</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), LessThan15, <span class="number">15</span>);</span><br><span class="line"><span class="built_in">replace_if</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">15</span>), <span class="number">100</span>);</span><br><span class="line"><span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">//100 15 15 100</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-8-4-swap算法"><a href="#3-8-4-swap算法" class="headerlink" title="3.8.4 swap算法"></a>3.8.4 swap算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">swap算法 互换两个容器的元素</span></span><br><span class="line"><span class="comment">@param c1 容器1</span></span><br><span class="line"><span class="comment">@param c2 容器2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">swap</span>(container c1,container c2);</span><br></pre></td></tr></table></figure><h3 id="3-9-常用算术生成算法"><a href="#3-9-常用算术生成算法" class="headerlink" title="3.9 常用算术生成算法"></a>3.9 常用算术生成算法</h3><h4 id="3-9-1-accumulate算法"><a href="#3-9-1-accumulate算法" class="headerlink" title="3.9.1 accumulate算法"></a>3.9.1 accumulate算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">accmulate算法 计算容器累计总和</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param value 累加值</span></span><br><span class="line"><span class="comment">@return 最终返回值是总和加上value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">accmulate</span>(iterator beg,iterator end,value);</span><br></pre></td></tr></table></figure><h4 id="3-9-2-fill算法"><a href="#3-9-2-fill算法" class="headerlink" title="3.9.2 fill算法"></a>3.9.2 fill算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*fill算法 对容器某个区间进行填充</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param value 填充值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">fill</span>(iterator beg,iterator end,value);</span><br></pre></td></tr></table></figure><h3 id="3-10-常用集合算法"><a href="#3-10-常用集合算法" class="headerlink" title="3.10 常用集合算法"></a>3.10 常用集合算法</h3><h4 id="3-10-1-set-intersection算法"><a href="#3-10-1-set-intersection算法" class="headerlink" title="3.10.1 set_intersection算法"></a>3.10.1 set_intersection算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">set_intersection算法 求两个集合的交集</span></span><br><span class="line"><span class="comment">注意：两个集合必须是有序序列</span></span><br><span class="line"><span class="comment">@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">@param dest 目标容器开始迭代器</span></span><br><span class="line"><span class="comment">@return 目标容器的最后一个元素之后的迭代器地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">set_intersection</span>(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);</span><br></pre></td></tr></table></figure><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span><span class="comment">//提供终端迭代器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123; <span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2&#123; <span class="number">23</span>,<span class="number">34</span>,<span class="number">78</span>,<span class="number">90</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;<span class="comment">//存交集</span></span><br><span class="line">v.<span class="built_in">resize</span>(<span class="built_in">min</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">it = <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">copy</span>(v.<span class="built_in">begin</span>(), it, <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">//23 34</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-10-2-set-union算法"><a href="#3-10-2-set-union算法" class="headerlink" title="3.10.2  set_union算法"></a>3.10.2  set_union算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">set_union算法 求两个集合的并集</span></span><br><span class="line"><span class="comment">注意：两个集合必须是有序序列</span></span><br><span class="line"><span class="comment">@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">@param dest 目标容器开始迭代器</span></span><br><span class="line"><span class="comment">@return 目标容器的最后一个元素之后的迭代器地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">set_union</span>(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);</span><br></pre></td></tr></table></figure><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span><span class="comment">//提供终端迭代器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123; <span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2&#123; <span class="number">23</span>,<span class="number">34</span>,<span class="number">78</span>,<span class="number">90</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;<span class="comment">//存并集</span></span><br><span class="line">v.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">it = <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">copy</span>(v.<span class="built_in">begin</span>(), it, <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">//12 23 34 45 56 78 90</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-10-3-set-difference算法"><a href="#3-10-3-set-difference算法" class="headerlink" title="3.10.3 set_difference算法"></a>3.10.3 set_difference算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">set_difference算法 求两个集合的差集(某个集合和交集相差的部分)</span></span><br><span class="line"><span class="comment">注意：两个集合必须是有序序列</span></span><br><span class="line"><span class="comment">@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">@param dest 目标容器开始迭代器</span></span><br><span class="line"><span class="comment">@return 目标容器的最后一个元素之后的迭代器地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">set_difference</span>(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);</span><br></pre></td></tr></table></figure><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span><span class="comment">//提供终端迭代器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123; <span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2&#123; <span class="number">23</span>,<span class="number">34</span>,<span class="number">78</span>,<span class="number">90</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;<span class="comment">//存v1对v2的差集</span></span><br><span class="line">v.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">it = <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">copy</span>(v.<span class="built_in">begin</span>(), it, <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">//12 45 56</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客介绍</title>
      <link href="/post/%E5%8D%9A%E5%AE%A2%E4%BB%8B%E7%BB%8D.html"/>
      <url>/post/%E5%8D%9A%E5%AE%A2%E4%BB%8B%E7%BB%8D.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="博客简介"><a href="#博客简介" class="headerlink" title="博客简介"></a>博客简介</h2><p>​    Hello，欢迎来到我的个人博客！这是我博客的第一篇文章，这里简要介绍一下我建立博客的初衷以及博客的技术栈吧！</p><h3 id="建立博客的初衷"><a href="#建立博客的初衷" class="headerlink" title="建立博客的初衷"></a>建立博客的初衷</h3><p>​    起初想的是有一个博客来发一些自己所学的一些东西或者记录自己学习遇到的一些问题方便自己查看，但是后面了解到前端、服务器等等这些东西后觉得做个人网站对目前的我来说太遥远了；后来多亏了伟大的大数据在B站给我推了Hexo个人博客框架部署在Github的视频，然后就一直在收藏夹吃灰T_T，刚好前段时间一个朋友给我看了他做的博客，于是心血来潮在这两天断断续续借助<strong>B站视频</strong>和Hexo的<strong>Butterfly主题文档</strong>逐步建立起这个博客。（以下是具体链接）</p><blockquote><p>B站视频：<a href="https://www.bilibili.com/video/BV1aV411p7Bc/?share_source=copy_web">https://www.bilibili.com/video/BV1aV411p7Bc/?share_source=copy_web</a></p><p>Butterfly主题文档：<a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p></blockquote><h2 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h2><p>​    emmm接下来就简单的一个自我介绍，本人是一名22级的大一计科专业的学生，接触过C/C++，html，css、js、vue（不过都只是学到一些皮毛），然后参加过CTF比赛、数模，不过目前所参加过比赛大多数都是本着了解的目的去的，然后就是说说未来在博客会写的一些内容：</p><ul><li>首先就是记录学习开发、算法、数模、CTF还有其他一些杂七杂八的东西</li><li>然后记录自己的一些学习成果（开发的东西之类的</li><li>最后就是可能也许偶尔会写点随笔</li></ul><hr><p>​    本人第一次做博客，可能有所不足，如果以后写的文章有什么错误或者问题可以通过以下联系方式告知（添加请注明来意噢）：</p><div style="width: 50%;margin: auto"><img src="/post/%E5%8D%9A%E5%AE%A2%E4%BB%8B%E7%BB%8D/wechat.jpg" class title="author" alt="s WeChat"></div>]]></content>
      
      
      <categories>
          
          <category> 其他范畴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
