<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vite + Vue3 + TypeScript 项目创建从0到1配置</title>
      <link href="/post/798d154e.html"/>
      <url>/post/798d154e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="VITE构建基础项目模板"><a href="#VITE构建基础项目模板" class="headerlink" title="VITE构建基础项目模板"></a>VITE构建基础项目模板</h2><ol><li>终端执行命令<code>npm init vite@latest</code>新建项目，选择Vue+Typescript</li><li>之后cd进入项目文件夹执行<code>npm install</code>则本步骤完成</li></ol><h2 id="环境变量配置优化"><a href="#环境变量配置优化" class="headerlink" title="环境变量配置优化"></a>环境变量配置优化</h2><ol><li>在项目根目录下新建env文件加存放不同环境需求下的环境变量信息：.env文件、.env.development文件、.env.production文件……对于更大的项目可能还有测试环境下的环境变量文件</li></ol><ul><li>.env公共的环境变量信息</li><li>.env.production生产环境下的环境变量信息</li><li>.env.development开发环境下的环境变量信息</li></ul><blockquote><p>注意：</p><ol><li>因为是新建env文件夹，所以需要在vite.config.ts文件中的config对象中添加envDir: ‘env’</li><li>对于环境变量文件中的环境变量名必须以VITE开头，否则需要额外说明</li></ol></blockquote><ol start="2"><li>在package.json添加命令<code>&quot;dev-prod&quot;: &quot;vite serve --mode production&quot;</code>可用来测试生产环境下的环境变量文件</li></ol><h2 id="优化生产构建后console和debugger关闭"><a href="#优化生产构建后console和debugger关闭" class="headerlink" title="优化生产构建后console和debugger关闭"></a>优化生产构建后console和debugger关闭</h2><ol><li>在vite.config.ts文件中的config对象中添加以下内容</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build</span>: &#123;</span><br><span class="line">    <span class="comment">// 如果出现npm run build失败可能需要安装一下terser：npm i terser -D</span></span><br><span class="line">    <span class="attr">minify</span>: <span class="string">&quot;terser&quot;</span>,</span><br><span class="line">    <span class="attr">terserOptions</span>: &#123;</span><br><span class="line">        <span class="attr">compress</span>: &#123;</span><br><span class="line">            <span class="attr">drop_console</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">drop_debugger</span>: <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：如果build构建后的用于测试，可能测试环境下需要console等，就参考下面的代码</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineConfig, loadEnv &#125; <span class="keyword">from</span> <span class="string">&#x27;vite&#x27;</span></span><br><span class="line"><span class="comment">// https://vitejs.dev/config/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">defineConfig</span>(<span class="function">(<span class="params">&#123; command, mode, ssrBuild &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> env = <span class="title function_">loadEnv</span>(mode, <span class="string">`<span class="subst">$&#123;process.cwd()&#125;</span>/env`</span>, <span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  <span class="comment">// 为什么要这样做，是为了 process.env和mode一致性</span></span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">assign</span>(process.<span class="property">env</span>, env, &#123; <span class="attr">NODE_ENV</span>: mode &#125;)</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    mode,</span><br><span class="line">  ...</span><br><span class="line">  <span class="attr">build</span>: &#123;</span><br><span class="line">      <span class="attr">minify</span>: <span class="string">&quot;terser&quot;</span>, <span class="comment">// 必须开启：使用 terserOptions 才有效果</span></span><br><span class="line">  <span class="attr">terserOptions</span>: &#123;</span><br><span class="line">    <span class="attr">compress</span>: &#123;</span><br><span class="line">      <span class="attr">drop_console</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="literal">true</span> : <span class="literal">false</span>,</span><br><span class="line">          <span class="attr">drop_debugger</span>: process.<span class="property">env</span>.<span class="property">NODE_ENV</span> === <span class="string">&#x27;production&#x27;</span> ? <span class="literal">true</span> : <span class="literal">false</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">     &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></blockquote><h2 id="优化文件引用路径"><a href="#优化文件引用路径" class="headerlink" title="优化文件引用路径"></a>优化文件引用路径</h2><ol><li>在vite.config.ts文件的config对象添加下列代码</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;resolve&#125; <span class="keyword">from</span> <span class="string">&quot;path&quot;</span>; <span class="comment">// 需要import</span></span><br><span class="line"><span class="comment">// 下面代码加入config对象中</span></span><br><span class="line"><span class="attr">resolve</span>: &#123;</span><br><span class="line">    <span class="attr">alias</span>: &#123;</span><br><span class="line">      <span class="string">&quot;@&quot;</span>: <span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><ol start="2"><li>如果添加上述代码后发现使用@方式引入组件依然报错，则在vite-env.d.ts文件中添加下列代码</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">declare</span> <span class="variable language_">module</span> <span class="string">&#x27;*.vue&#x27;</span> &#123;</span><br><span class="line">    <span class="keyword">import</span> <span class="keyword">type</span> &#123;<span class="title class_">DefineComponent</span>&#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="attr">component</span>: <span class="title class_">DefineComponent</span>&lt;&#123;&#125;, &#123;&#125;, <span class="built_in">any</span>&gt;;</span><br><span class="line">    <span class="keyword">export</span> <span class="keyword">default</span> component;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置CSS全局变量"><a href="#配置CSS全局变量" class="headerlink" title="配置CSS全局变量"></a>配置CSS全局变量</h2><ol><li>使用scss作为css预处理器，先安装相关依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i sass sass-loader --save-dev</span><br></pre></td></tr></table></figure><ol start="2"><li>对于一些全局css变量可以在src下建立全局css文件global.scss，然后在vite.config.js文件中的config对象添加配置</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">css</span>: &#123;</span><br><span class="line"><span class="comment">// css预处理器</span></span><br><span class="line">    <span class="attr">preprocessorOptions</span>: &#123;</span><br><span class="line">      <span class="attr">scss</span>: &#123;</span><br><span class="line">        <span class="attr">additionalData</span>: <span class="string">&#x27;@import &quot;@/assets/style/global.scss&quot;;&#x27;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="路由vue-router配置"><a href="#路由vue-router配置" class="headerlink" title="路由vue-router配置"></a>路由vue-router配置</h2><ol><li>安装依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install vue-router@4</span><br></pre></td></tr></table></figure><ol start="2"><li>在src文件夹下新建router文件下，并在router文件夹下新建index.ts，内容如下，然后记得在main.ts挂载到app之前添加use(router)</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;createRouter, createWebHashHistory&#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">HomeView</span> <span class="keyword">from</span> <span class="string">&#x27;@/views/HomeView.vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;Home&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="title class_">HomeView</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 无匹配页面则跳转到404</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">path</span>: <span class="string">&#x27;/:pathMatch(.*)*&#x27;</span>,</span><br><span class="line">        <span class="attr">name</span>: <span class="string">&#x27;NotFound&#x27;</span>,</span><br><span class="line">        <span class="attr">component</span>: <span class="function">() =&gt;</span> <span class="keyword">import</span>(<span class="string">&#x27;@/views/NotFoundView.vue&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> router = <span class="title function_">createRouter</span>(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">history</span>: <span class="title function_">createWebHashHistory</span>(),</span><br><span class="line">        <span class="attr">routes</span>: routes,</span><br><span class="line">        <span class="comment">// 在导航栏中，为当前活动路由的菜单项添加类名</span></span><br><span class="line">        <span class="attr">linkActiveClass</span>: <span class="string">&#x27;router-active&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure><blockquote><p>说明：在组件内部可以通过 <code>useRouter()</code> 和 <code>useRoute()</code> 来访问路由器实例和当前路由</p></blockquote><ol start="3"><li>在router文件下创建createRouteGuards.ts用作全局路由守卫配置，并在router/index.ts里面export router之前调用createRouteGuards(router)</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">Router</span>&#125; <span class="keyword">from</span> <span class="string">&quot;vue-router&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="title function_">createRouteGuards</span> = (<span class="params">router: Router</span>) =&gt; &#123;</span><br><span class="line">    <span class="comment">// @ts-ignore</span></span><br><span class="line">    router.<span class="title function_">beforeEach</span>(<span class="keyword">async</span> (to, <span class="keyword">from</span>, next) =&gt; &#123;</span><br><span class="line">        <span class="title function_">next</span>()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态管理库Pinia配置"><a href="#状态管理库Pinia配置" class="headerlink" title="状态管理库Pinia配置"></a>状态管理库Pinia配置</h2><ol><li>老规矩先安装依赖，后面是持久化插件（保证页面刷新的时候缓存不会刷新</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install pinia pinia-plugin-persistedstate</span><br></pre></td></tr></table></figure><ol start="2"><li>在src下面新建文件夹store，再新建文件index.ts，代码如下，然后记得在main.ts挂载到app之前添加use(store)</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createPinia &#125; <span class="keyword">from</span> <span class="string">&#x27;pinia&#x27;</span></span><br><span class="line"><span class="keyword">import</span> piniaPluginPersistedstate <span class="keyword">from</span> <span class="string">&#x27;pinia-plugin-persistedstate&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createPinia</span>()</span><br><span class="line"><span class="comment">// 使用持久化插件</span></span><br><span class="line">store.<span class="title function_">use</span>(piniaPluginPersistedstate)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure><ol start="3"><li>可能状态管理可能会分模块，比如用户认证相关、平台基本信息相关，因此可以在store文件夹下新建modules文件夹，每个不同模块一个单独的ts文件，比如下面的useUserStore.ts(一般以use开头)，具体使用参考<a href="https://pinia.web3doc.top/">Home | Pinia 中文文档 (web3doc.top)</a></li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; defineStore &#125; <span class="keyword">from</span> <span class="string">&quot;pinia&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useUserStore = <span class="title function_">defineStore</span>(<span class="string">&#x27;user&#x27;</span>, &#123;</span><br><span class="line">    <span class="comment">// 推荐使用完整类型推断的箭头函数</span></span><br><span class="line">    <span class="attr">state</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="attr">username</span>: <span class="string">&#x27;2aurora2&#x27;</span>,</span><br><span class="line">            <span class="attr">counter</span>: <span class="number">0</span>,</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 状态的计算值computed, 无法向它们传递任何参数; 但是，可以从 getter 返回一个函数以接受任何参数</span></span><br><span class="line">    <span class="attr">getters</span>: &#123;</span><br><span class="line">        <span class="attr">addCounter</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> state.<span class="property">counter</span> += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 相当于组件的methods</span></span><br><span class="line">    <span class="attr">actions</span>: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 启用插件</span></span><br><span class="line">    <span class="attr">persist</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="网络请求AXIOS配置"><a href="#网络请求AXIOS配置" class="headerlink" title="网络请求AXIOS配置"></a>网络请求AXIOS配置</h2><ol><li>老规矩先安装对应依赖</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install axios</span><br></pre></td></tr></table></figure><ol start="2"><li>将axios的相关配置和请求方式的封装写在src/utils/http下，新建instance.ts文件和service.ts文件</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// instance.ts</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> axiosInstance = axios.<span class="title function_">create</span>(&#123;</span><br><span class="line">    <span class="attr">baseURL</span>: <span class="keyword">import</span>.<span class="property">meta</span>.<span class="property">env</span>.<span class="property">VITE_PROXY_URL</span>,</span><br><span class="line">    <span class="attr">timeout</span>: <span class="number">10</span> * <span class="number">1000</span>,</span><br><span class="line">    <span class="attr">headers</span>: &#123;</span><br><span class="line">        <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;application/json&#x27;</span>,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求拦截器</span></span><br><span class="line">axiosInstance.<span class="property">interceptors</span>.<span class="property">request</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function">(<span class="params">config</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> config;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应拦截器</span></span><br><span class="line"><span class="comment">// 2xx 范围内的状态码都会触发该函数</span></span><br><span class="line">axiosInstance.<span class="property">interceptors</span>.<span class="property">response</span>.<span class="title function_">use</span>(</span><br><span class="line">    <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> response;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function">(<span class="params">err</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err);</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> axiosInstance;</span><br><span class="line"></span><br><span class="line"><span class="comment">// service.ts</span></span><br><span class="line"><span class="keyword">import</span> axiosInstance <span class="keyword">from</span> <span class="string">&quot;./instance.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">get</span> = (<span class="params">url: <span class="built_in">string</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> axiosInstance.<span class="title function_">get</span>(url);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">post</span> = (<span class="params">url: <span class="built_in">string</span>, data?: <span class="built_in">Object</span></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> axiosInstance.<span class="title function_">post</span>(url, data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    get,</span><br><span class="line">    post</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>所有与后端交互的接口信息在src文件夹下另开一个文件夹api，api文件夹下新建index.ts文件、type.ts文件和不同模块文件夹</li></ol><ul><li>index.ts导出不同模块的相关接口</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> userApi <span class="keyword">from</span> <span class="string">&#x27;./user&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    userApi,     <span class="comment">// 用户相关API</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>type.ts定义一些公共类型，如后端的返回值类型</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">ResponseResult</span>&lt;T&gt; = &#123;</span><br><span class="line">    <span class="attr">code</span>: <span class="built_in">number</span>;</span><br><span class="line">    <span class="attr">message</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">data</span>: T;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>分模块文件夹代表一个模块，每个模块文件夹下均为index.ts和type.ts文件</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// api/user/index.ts</span></span><br><span class="line"><span class="keyword">import</span> service <span class="keyword">from</span> <span class="string">&quot;@/utils/http/service.ts&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">ResponseResult</span>&#125; <span class="keyword">from</span> <span class="string">&quot;@/api/type.ts&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;<span class="title class_">LoginReqType</span>, <span class="title class_">LoginResType</span>&#125; <span class="keyword">from</span> <span class="string">&quot;@/api/user/type.ts&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">login</span> = (<span class="params">data: LoginReqType</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> service.<span class="property">post</span>&lt;<span class="title class_">ResponseResult</span>&lt;<span class="title class_">LoginResType</span>&gt;&gt;(<span class="string">&#x27;/user/login&#x27;</span> +</span><br><span class="line">        <span class="string">&#x27;?email=&#x27;</span> + data.<span class="property">email</span> +</span><br><span class="line">        <span class="string">&#x27;&amp;password=&#x27;</span> + data.<span class="property">password</span>, data)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">    login,               <span class="comment">// 用户登录</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// api/user/type.ts</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">LoginReqType</span> = &#123;</span><br><span class="line">    <span class="attr">email</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">password</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">type</span> <span class="title class_">LoginResType</span> = &#123;</span><br><span class="line">    <span class="attr">token</span>: <span class="built_in">string</span>;</span><br><span class="line">    <span class="attr">expirationTime</span>: <span class="built_in">string</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><ol><li>在src下新建types/index.ts用来描述全局自定义类型export type……</li><li>在src下新建const/index.ts用来定义常量，将常量定义在一个对象里面然后导出</li></ol><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> <span class="variable constant_">CONST</span> = &#123;</span><br><span class="line">    <span class="attr">PI</span>: <span class="number">3.14159</span>,</span><br><span class="line">    <span class="attr">GRAVITY</span>: <span class="number">9.81</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>后续如果有其他会继续补充……</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 开发范畴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vite </tag>
            
            <tag> Vue </tag>
            
            <tag> Typescript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Express开发学习</title>
      <link href="/post/Express_1.html"/>
      <url>/post/Express_1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近想学习一下如何node和Express框架进行后端开发，所以打算搞一个Express的专题学习，后面可能会不定期更新对Express框架的学习（ps：最近忙着期末考，然后暑假还挺多事情的，所以这个专题可能是一个比较长期的工作）</p><hr><h2 id="Express介绍"><a href="#Express介绍" class="headerlink" title="Express介绍"></a>Express介绍</h2><blockquote><p>英文文档：<a href="https://expressjs.com/">https://expressjs.com/</a></p><p>中文文档：<a href="https://www.expressjs.com.cn/">https://www.expressjs.com.cn/</a></p></blockquote><ol><li><p>讲Express之前先简单提及一下Node：</p><p><strong>Node</strong>（正式名称 Node.js）是一个开源的、跨平台的运行时环境，有了它，开发人员可以使用<strong>JavaScript</strong>创建各种服务器端工具和应用程序。此运行时主要用于浏览器上下文之外（即可以直接运行于计算机或服务器操作系统上）。据此，该环境省略了一些浏览器专用的 JavaScript API，同时添加了对更传统的 OS API（比如 HTTP 库和文件系统库）的支持。</p></li><li><p>Express 是最流行的 Node 框架，是许多其他流行Node 框架的底层库。它提供了以下机制：</p></li></ol><ul><li>为不同 URL 路径中使用不同 HTTP 动词的请求（路由）编写处理程序</li><li>集成了“视图”渲染引擎，以便通过将数据插入模板来生成响应</li><li>设置常见 web 应用设置，比如用于连接的端口，以及渲染响应模板的位置</li><li>在请求处理管道的任何位置添加额外的请求处理“中间件”</li></ul><ol start="3"><li><p>Express项目的一般文件结构：（前后端分离）</p><blockquote><p>bin: 存放启动项目的脚本文件</p><p>node_modules: 存放所有的项目依赖库</p><p>public: 静态文件（css，js，img）</p><p>routes: 路由文件（MVC中 的controller）</p><p>db: 数据库相关</p><p>package.json: 项目依赖配置及开发者信息</p><p>app.js: 应用核心配置文件</p></blockquote></li></ol><h2 id="Express基础项目创建"><a href="#Express基础项目创建" class="headerlink" title="Express基础项目创建"></a>Express基础项目创建</h2><ol><li><p>新建项目文件夹</p></li><li><p>在文件夹根目录下执行以下命令：</p><ul><li><p>安装express</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install express</span><br></pre></td></tr></table></figure></li><li><p>安装cors（解决跨域问题）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install cors</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在文件夹根目录下新建app.js文件这样一个最简单的express项目就创建好了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入相关依赖</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用express得到一个http服务器对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="comment">// 使用cors模块解决跨域问题</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>());</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 监听对应的路径请求，使用对应的函数处理</span></span><br><span class="line"><span class="comment">// 处理简单的get请求，向客户端返回“hello world!”</span></span><br><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;客户端访问根路径/, 返回hello world!&quot;</span>)</span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;Hello world!&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Server runs on http://localhost:3000.&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Press Ctrl+C to quit.&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li><p>在终端运行node app.js即可访问本地3000端口看到hello world! 字样</p></li></ol><h2 id="nodemon工具"><a href="#nodemon工具" class="headerlink" title="nodemon工具"></a>nodemon工具</h2><p>我们在进行node开发的过程要经常性的更改文件，每次更改文件都要重启程序有点麻烦，<strong>nodemon</strong> 是一种工具，可在检测到目录中的文件更改时通过自动重新启动 node 应用程序来帮助开发基于 node.js 的应用程序</p><h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3><h4 id="全局安装"><a href="#全局安装" class="headerlink" title="全局安装"></a>全局安装</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g nodemon</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodemon app.js</span><br></pre></td></tr></table></figure><h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在Express 中，路由指的是客户端的请求与服务器处理函数之间的映射关系。简单来说，在Express中，路由分3部分组成：请求的类型、请求的URL地址、处理函数（也叫<strong>中间件函数</strong>，后续介绍）（格式如下）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/user/login&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">body</span>);</span><br><span class="line">    res.<span class="title function_">json</span>(req.<span class="property">body</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><p>通过以上介绍我们不难看出路由其实可以看做一个个接口，而在一个项目当中接口的数量是相当多的，我们不可能全都写在app.js里面，这不利于代码的可读性也不利于代码维护，通常的做法是在项目的根目录下新建<strong>routes</strong>文件夹，而由于接口也分为很多类型，所以也会在routes目录下建立多个目录进行分类存放，然后通过routes目录下新建一个index.js文件讲所有接口一次性暴露出去（目录结构如下图，可能和Express脚手架创建项目的目录结构有所不同）</p><img src="/post/Express_1/1.png" class title="project_tree"><h4 id="书写接口过程（以书写一个简单的登录接口为例）"><a href="#书写接口过程（以书写一个简单的登录接口为例）" class="headerlink" title="书写接口过程（以书写一个简单的登录接口为例）"></a>书写接口过程（以书写一个简单的登录接口为例）</h4><ol><li><p>在user文件夹下创建login.js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./routes/user/login.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> login = express.<span class="title class_">Router</span>() <span class="comment">// 引入路由中间件</span></span><br><span class="line"></span><br><span class="line">login.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">login.<span class="title function_">use</span>(express.<span class="title function_">json</span>())</span><br><span class="line"></span><br><span class="line">login.<span class="title function_">post</span>(<span class="string">&#x27;/user/login&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;login success!&quot;</span>);</span><br><span class="line">    res.<span class="title function_">json</span>(&#123;</span><br><span class="line">        <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="comment">// 关于请求参数的获取后续单独讲</span></span><br><span class="line">        <span class="attr">username</span>: req.<span class="property">body</span>.<span class="property">username</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将login接口暴露出去</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = login</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将login接口暴露出去</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = login</span><br></pre></td></tr></table></figure><p><strong>express.urlencoded( )：</strong></p><p>express.urlencoded( )函数是Express中的内置中间件函数。它基于body-parser解析带有urlencoded有效负载的传入请求并传给req.body。该中间件有一个extended参数，用于控制解析数据是选择qs模块还是querystring模块extended=true 时采用qs模块，该模块的特点是可以解析嵌套数据。</p><p><strong>express.json( ):</strong></p><p>express.json() 用于解析客户端发送的 JSON 格式的请求体数据，将其转换为 JavaScript 对象，并将其赋值给 req.body。</p></li><li><p>在routes文件夹下新建index.js管理所有接口</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ./routes/index.js</span></span><br><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> login = <span class="built_in">require</span>(<span class="string">&#x27;./user/login&#x27;</span>) <span class="comment">// 引入登录接口</span></span><br><span class="line"><span class="keyword">let</span> router = express.<span class="title class_">Router</span>()</span><br><span class="line"></span><br><span class="line">router.<span class="title function_">use</span>(login) <span class="comment">// 向router路由对象挂载具体的路由</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将router路由对象暴露出去</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = router</span><br></pre></td></tr></table></figure></li><li><p>在app.js里面挂载路由模块</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 引入相关依赖</span></span><br><span class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">const</span> cors = <span class="built_in">require</span>(<span class="string">&#x27;cors&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> router = <span class="built_in">require</span>(<span class="string">&#x27;./routes/index&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用express得到一个http服务器对象</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">express</span>()</span><br><span class="line"><span class="comment">// 使用cors模块解决跨域问题</span></span><br><span class="line">app.<span class="title function_">use</span>(<span class="title function_">cors</span>()).<span class="title function_">use</span>(router)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务器</span></span><br><span class="line">app.<span class="title function_">listen</span>(<span class="number">3000</span>, <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Server runs on http://localhost:3000.&quot;</span>)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;Press Ctrl+C to quit.&quot;</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>使用apipost工具测试login接口</p><img src="/post/Express_1/2.png" class title="test"><h2 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h2><p>中间件我们前面也有提到，中间件本质上是一个函数/方法，有三个形参：</p><blockquote><p>req: 客户端的请求</p><p>res: 服务端的响应</p><p>next: 如果使用该参数，中间件会把请求交给下一个中间件去处理，如果不调用next，请求到这一个中间就结束了，不会把请求传递给其他中间件</p></blockquote><h3 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>)</span><br><span class="line"><span class="keyword">let</span> login = express.<span class="title class_">Router</span>() <span class="comment">// 引入路由中间件</span></span><br><span class="line"></span><br><span class="line">login.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">true</span> &#125;))</span><br><span class="line">login.<span class="title function_">use</span>(express.<span class="title function_">json</span>())</span><br><span class="line"></span><br><span class="line">login.<span class="title function_">post</span>(<span class="string">&#x27;/user/login&#x27;</span>, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;login success!&quot;</span>);</span><br><span class="line">    res.<span class="title function_">json</span>(&#123;</span><br><span class="line">        <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="attr">username</span>: req.<span class="property">body</span>.<span class="property">username</span></span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="title function_">next</span>();</span><br><span class="line">&#125;, <span class="function">(<span class="params">req, res, next</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;这里是下一个中间件!&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将login接口暴露出去</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = login</span><br></pre></td></tr></table></figure><p><strong>终端输出：</strong></p><img src="/post/Express_1/3.png" class title="test"><h2 id="app-use"><a href="#app-use" class="headerlink" title="app.use( )"></a>app.use( )</h2><p>在 Express 中，一切都是中间件。在内部，Express 应用程序有一个中间件堆栈，调用 <code>use()</code> 会在堆栈中添加一个新层，比如我们前面就是使用了cors中间件等等。定义路由处理程序的函数，如 <code>get()</code> 和 <code>post()</code> 也会向堆栈添加层。之后Express会按照顺序执行中间件堆栈。</p><blockquote><p>2023-07-01</p><p>浅浅修改了一下之前创建的项目的目录结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;node</span><br><span class="line">&gt;├─ app.js</span><br><span class="line">&gt;├─ node_modules</span><br><span class="line">&gt;├─ package-lock.json</span><br><span class="line">&gt;├─ package.json</span><br><span class="line">&gt;└─ routes</span><br><span class="line">      ├─ homeRouter.js // 主页相关接口</span><br><span class="line">      └─ userRouter.js // 用户相关接口</span><br></pre></td></tr></table></figure></blockquote><h2 id="获取请求参数"><a href="#获取请求参数" class="headerlink" title="获取请求参数"></a>获取请求参数</h2><h3 id="获取get请求的参数"><a href="#获取get请求的参数" class="headerlink" title="获取get请求的参数"></a>获取get请求的参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">homeRouter.<span class="title function_">get</span>(<span class="string">&#x27;/&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(req.<span class="property">query</span>);      <span class="comment">// 获取get请求的参数</span></span><br><span class="line">    res.<span class="title function_">send</span>(<span class="string">&quot;Get the username!&quot;</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设url为http://localhost:3000/?username=xiaochou</span></span><br></pre></td></tr></table></figure><img src="/post/Express_1/4.png" class title="get"><h3 id="获取post请求的参数"><a href="#获取post请求的参数" class="headerlink" title="获取post请求的参数"></a>获取post请求的参数</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取post请求参数需要使用中间价，可在app.js引入各个模块路由前进行全局使用</span></span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">urlencoded</span>(&#123; <span class="attr">extended</span>: <span class="literal">false</span> &#125;))</span><br><span class="line">app.<span class="title function_">use</span>(express.<span class="title function_">json</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment">// userRouter.js</span></span><br><span class="line">userRouter.<span class="title function_">post</span>(<span class="string">&#x27;/login&#x27;</span>, <span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;login success!&quot;</span>)</span><br><span class="line">    res.<span class="title function_">json</span>(&#123;</span><br><span class="line">        <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">        <span class="attr">userEmail</span>: req.<span class="property">body</span>.<span class="property">email</span> <span class="comment">// 通过body获取整个参数对象</span></span><br><span class="line">    &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><img src="/post/Express_1/5.png" class title="get">]]></content>
      
      
      <categories>
          
          <category> 开发范畴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node </tag>
            
            <tag> express </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性回归(linear regression)</title>
      <link href="/post/linear_regression.html"/>
      <url>/post/linear_regression.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="算法介绍"><a href="#算法介绍" class="headerlink" title="算法介绍"></a>算法介绍</h3><p>在统计学中，线性回归（Linear Regression）是利用称为线性回归方程的最小平方函数对一个或多个自变量和因变量之间关系进行建模的一种回归分析。线性回归按自变量的个数分为2种：</p><ul><li>简单线性回归：只有一个自变量</li><li>多元线性回归：自变量的个数大于等于两个</li></ul><h3 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h3><p>在一般情况下，假设有$p$个自变量，$y$为因变量，设：<br>$$<br>y=\beta_0+\beta_1x_1+\cdots+\beta_px_p<br>$$<br>在模型构建过程中，利用 $y$ 与 $x_1, \cdots, x_p$ 的训练数据来估计$\beta_0$与$\beta_1, \cdots, \beta_p$得到：<br>$$<br>\hat{y}=\hat{\beta_0}+\hat{\beta_1}x_1+\cdots+\hat{\beta_p}x_p\<br>$$</p><p>$$<br>\hat{y}=\left[<br>\begin{matrix}<br>1 &amp; x_1 &amp; \cdots &amp; x_p\<br>\end{matrix}<br>\right]<br>\left[<br>\begin{matrix}<br>\hat{\beta_0} \<br>\vdots \<br>\hat{\beta_p}<br>\end{matrix}<br>\right]=X*W(W是列向量)<br>$$</p><h3 id="拟合方程"><a href="#拟合方程" class="headerlink" title="拟合方程"></a>拟合方程</h3><blockquote><p>线性回归的<strong>损失函数</strong>一般由最小二乘法求得</p></blockquote><h4 id="最小二乘法-ordinary-least-squares"><a href="#最小二乘法-ordinary-least-squares" class="headerlink" title="最小二乘法(ordinary least squares)"></a>最小二乘法(ordinary least squares)</h4><p>最小二乘法的主要思想是通过确定未知参数（通常是一个参数矩阵），来使得真实值和预测值的误差（也称残差）平方和最小，其计算公式为：<br>$$<br>E=\sum_{i=1}^n(y_i-\hat{y_i})^2<br>$$<br>其中$y_i$是真实值，$\hat{y_i}$是对应的预测值，图示如下：（橙色线即为误差）</p><img src="/post/linear_regression/1.png" class title="ordinary least squares"><h4 id="损失函数"><a href="#损失函数" class="headerlink" title="损失函数"></a>损失函数</h4><p>由最小二乘法可得线性回归得损失函数为：<br>$$<br>J(W)=\sum_{i=1}^n(y_i-\hat{y_i})^2=\sum_{i=1}^n(y_i-X_i*W)^2<br>$$</p><p>要使得损失函数最小，可以将损失函数作为多元函数处理，下面给出一维特征（自变量仅有一个的情况）的损失函数最小求解：（设线性回归方程为：$\hat{y}=\hat{\beta_0}+\hat{\beta_1}x$）<br>$$<br>\hat{\beta_0}=\frac{\sum_{i=1}^{m}\left(x^{(i)}\right)^{2} \sum_{i=1}^{m} y^{(i)}-\sum_{i=1}^{m} x^{(i)} \sum_{i=1}^{m} x^{(i)} y^{(i)}}{m \sum_{i=1}^{m}\left(x^{(i)}\right)^{2}-\left(\sum_{i=1}^{m} x^{(i)}\right)^{2}}<br>$$</p><p>$$<br>\hat{\beta_1}=\frac{m\sum\limits_{i=1}^{m}x^{(i)}y^{(i)}-\sum\limits_{i=1}^{m}x^{(i)}\sum\limits_{i=1}^{m}y^{(i)}}{m\sum\limits_{i=1}^{m}(x^{(i)})^2-(\sum\limits_{i=1}^{m}x^{(i)})^2}<br>$$</p><h3 id="拟合效果检验"><a href="#拟合效果检验" class="headerlink" title="拟合效果检验"></a>拟合效果检验</h3><p>线性回归一般利用可决系数$R^2$来反映直线的拟合程度，取值范围在[0,1]之间。$R^2\to1$说明回归方程拟合的越好，$R^2\to0$就代表回归方程拟合的越差，其计算公式如下：<br>$$<br>R^2=\frac{\Sigma(\hat y-\overline y)^2}{\Sigma(y-\overline y)^2}<br>$$</p><h3 id="模型练习"><a href="#模型练习" class="headerlink" title="模型练习"></a>模型练习</h3><p><a href="https://www.kaggle.com/code/toaurora/linear-regression/notebook">Linear Regression | Kaggle</a></p>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
            <tag> 回归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词袋模型 &amp;&amp; 余弦相似度</title>
      <link href="/post/BOW_model.html"/>
      <url>/post/BOW_model.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>自然语言处理面临的文本数据往往是非结构化杂乱无章的文本数据，而机器学习算法处理的数据往往是固定长度的输入和输出，因而机器学习并不能直接处理原始的文本数据，必须把文本数据转换成数字，比如向量，这个过程就叫做特征提取或者特征编码。一种流行并且简单的特征提取方法就是词袋模型。</p><h2 id="词袋模型（BOW）"><a href="#词袋模型（BOW）" class="headerlink" title="词袋模型（BOW）"></a>词袋模型（BOW）</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>词袋模型(Bag of Words)不考虑文本中词语的顺序，只考虑词表（vocabulary）或者语料库中的词语在这个文本中的出现次数，进而把一个文本转化为向量表示，是比较简单直白的一种特征提取方法。</p><h3 id="模型构建过程"><a href="#模型构建过程" class="headerlink" title="模型构建过程"></a>模型构建过程</h3><p><strong>1. 获取文本数据</strong>（这里以两个文本句子为例）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 目的：利用词袋模型得出下列句子的向量表示</span></span><br><span class="line">txts = [<span class="string">&#x27;朋友们喜欢吃饭、睡觉、打豆豆。&#x27;</span>, <span class="string">&#x27;我喜欢吃饭、睡觉。&#x27;</span>]</span><br></pre></td></tr></table></figure><p><strong>2. 文本分词并构建语料库</strong></p><p>NLP无法处理一整个句子，因此第一步工作往往是分词。中文文本的分词常用的是<strong>jieba分词</strong>，英文文本的分词可以使用NLTK中的<strong>word_tokenize函数</strong>。</p><p>分词后进行语料库的构建，对于语料库的构建要保证语料库里面没有重复的词语或者标点，因而可以使用<strong>set方法</strong>。另外构建语料库后要进行<strong>数字映射</strong>便于后续的向量表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 构建语料库并进行数字映射</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">construct_word_dict</span>(<span class="params">texts</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param texts: 文本列表</span></span><br><span class="line"><span class="string">    :return: 字典（词语及对应的数字映射）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    words = []</span><br><span class="line">    <span class="keyword">for</span> text <span class="keyword">in</span> texts:</span><br><span class="line">        <span class="comment"># jieba分词</span></span><br><span class="line">        words += jieba.lcut(text)</span><br><span class="line">    <span class="comment"># 去除重复的元素</span></span><br><span class="line">    words = <span class="built_in">set</span>(words)</span><br><span class="line">    <span class="comment"># 建立词与数字的映射</span></span><br><span class="line">    words = <span class="built_in">dict</span>(<span class="built_in">zip</span>(words, <span class="built_in">range</span>(<span class="built_in">len</span>(words))))</span><br><span class="line">    <span class="keyword">return</span> words</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>示例文本生成的语料库如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="string">&#x27;我&#x27;</span>: 0, <span class="string">&#x27;朋友&#x27;</span>: 1, <span class="string">&#x27;打&#x27;</span>: 2, <span class="string">&#x27;豆豆&#x27;</span>: 3, <span class="string">&#x27;吃饭&#x27;</span>: 4, <span class="string">&#x27;。&#x27;</span>: 5, <span class="string">&#x27;们&#x27;</span>: 6, <span class="string">&#x27;、&#x27;</span>: 7, <span class="string">&#x27;喜欢&#x27;</span>: 8, <span class="string">&#x27;睡觉&#x27;</span>: 9&#125;</span><br></pre></td></tr></table></figure><p><strong>3. 建立文本的向量表示</strong></p><p>在这里词袋模型的向量表示是把语料库中单词或标点的出现频数作为其对应的数字表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 建立文本的向量表示</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vector_rep</span>(<span class="params">text, corpus_dict</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param text: 文本</span></span><br><span class="line"><span class="string">    :param corpus_dict: 语料库</span></span><br><span class="line"><span class="string">    :return: 对应文本的向量表示</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    vec = []</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> corpus_dict.keys():</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> text:</span><br><span class="line">            vec.append((corpus_dict[key], text.count(key)))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            vec.append((corpus_dict[key], <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    vec = <span class="built_in">sorted</span>(vec, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vec</span><br></pre></td></tr></table></figure><p>示例文本对应的向量表示如下：（每一个元组里面第一个值是语料库某个词的数字映射，第二个值是其出现的频数）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># &#x27;朋友们喜欢吃饭、睡觉、打豆豆。&#x27;的向量表示</span></span><br><span class="line">[(0, 0), (1, 1), (2, 1), (3, 1), (4, 1), (5, 1), (6, 1), (7, 1), (8, 2), (9, 1)]</span><br><span class="line"><span class="comment"># &#x27;我喜欢吃饭、睡觉。&#x27;的向量表示</span></span><br><span class="line">[(0, 1), (1, 0), (2, 1), (3, 1), (4, 1), (5, 0), (6, 1), (7, 0), (8, 1), (9, 0)]</span><br></pre></td></tr></table></figure><h3 id="模型应用与缺点"><a href="#模型应用与缺点" class="headerlink" title="模型应用与缺点"></a>模型应用与缺点</h3><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>通过词袋模型得到的文本的向量表示可以利用<strong>余弦相似度</strong>的方法来判断句子相似度</p><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>没有考虑词序以及词之间的联系，容易丢失了重要信息；</li><li>随着语料库的增大，一个文本的向量表示可能是一个非常稀疏的高维向量，严重影响内存和计算资源；</li><li>词袋模型严重缺乏相似词之间的表达，比如对于 ‘ 我喜欢北京 ’ 和 ‘ 我不喜欢北京 ‘这两个句子的是不相似的，但依据词袋模型得到的向量表示利用余弦相似度的方法所求的相似度较高。</li></ol><h2 id="余弦相似度"><a href="#余弦相似度" class="headerlink" title="余弦相似度"></a>余弦相似度</h2><p>余弦相似度，也称为余弦距离，是用向量空间中两个向量夹角的余弦值作为衡量两个个体间差异的大小的度量，其计算公式及对应的python实现如下：</p><img src="/post/BOW_model/cos.png" class title="math"><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 余弦相似度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">similarity_with_2_txts</span>(<span class="params">vec1, vec2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param vec1: 文本1的向量表示（这里的向量形式是词袋模型所得到的向量表示形式）</span></span><br><span class="line"><span class="string">    :param vec2: 文本2的向量表示</span></span><br><span class="line"><span class="string">    :return: 两个文本的余弦相似度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    inner_product = <span class="number">0</span></span><br><span class="line">    square_length_vec1 = <span class="number">0</span></span><br><span class="line">    square_length_vec2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> tup1, tup2 <span class="keyword">in</span> <span class="built_in">zip</span>(vec1, vec2):</span><br><span class="line">        inner_product += tup1[<span class="number">1</span>] * tup2[<span class="number">1</span>]</span><br><span class="line">        square_length_vec1 += tup1[<span class="number">1</span>] ** <span class="number">2</span></span><br><span class="line">        square_length_vec2 += tup2[<span class="number">1</span>] ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner_product / sqrt(square_length_vec1 * square_length_vec2)</span><br></pre></td></tr></table></figure><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># @Time    : 2023/5/7 20:23</span></span><br><span class="line"><span class="comment"># @Author  : aurora</span></span><br><span class="line"><span class="comment"># @FileName: BOW_Model.py</span></span><br><span class="line"><span class="comment"># @Software: PyCharm</span></span><br><span class="line"><span class="comment"># @Blog    ：https://2aurora2.github.io/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> jieba</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"><span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line"></span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 构建语料库并进行数字映射</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">construct_word_dict</span>(<span class="params">texts</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param texts: 文本列表</span></span><br><span class="line"><span class="string">    :return: 字典（词语及对应的数字映射）</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    words = []</span><br><span class="line">    <span class="keyword">for</span> text <span class="keyword">in</span> texts:</span><br><span class="line">        <span class="comment"># jieba分词</span></span><br><span class="line">        words += jieba.lcut(text)</span><br><span class="line">    <span class="comment"># 去除重复的元素</span></span><br><span class="line">    words = <span class="built_in">set</span>(words)</span><br><span class="line">    <span class="comment"># 建立词与数字的映射</span></span><br><span class="line">    words = <span class="built_in">dict</span>(<span class="built_in">zip</span>(words, <span class="built_in">range</span>(<span class="built_in">len</span>(words))))</span><br><span class="line">    <span class="keyword">return</span> words</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立文本的向量表示</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">vector_rep</span>(<span class="params">text, corpus_dict</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param text: 文本</span></span><br><span class="line"><span class="string">    :param corpus_dict: 语料库</span></span><br><span class="line"><span class="string">    :return: 对应文本的向量表示</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    vec = []</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> corpus_dict.keys():</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> text:</span><br><span class="line">            vec.append((corpus_dict[key], text.count(key)))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            vec.append((corpus_dict[key], <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    vec = <span class="built_in">sorted</span>(vec, key=<span class="keyword">lambda</span> x: x[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> vec</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 余弦相似度</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">similarity_with_2_txts</span>(<span class="params">vec1, vec2</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    :param vec1: 文本1的向量表示</span></span><br><span class="line"><span class="string">    :param vec2: 文本2的向量表示</span></span><br><span class="line"><span class="string">    :return: 两个文本的余弦相似度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    inner_product = <span class="number">0</span></span><br><span class="line">    square_length_vec1 = <span class="number">0</span></span><br><span class="line">    square_length_vec2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> tup1, tup2 <span class="keyword">in</span> <span class="built_in">zip</span>(vec1, vec2):</span><br><span class="line">        inner_product += tup1[<span class="number">1</span>] * tup2[<span class="number">1</span>]</span><br><span class="line">        square_length_vec1 += tup1[<span class="number">1</span>] ** <span class="number">2</span></span><br><span class="line">        square_length_vec2 += tup2[<span class="number">1</span>] ** <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> inner_product / sqrt(square_length_vec1 * square_length_vec2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">txts = [<span class="string">&#x27;我喜欢北京&#x27;</span>, <span class="string">&#x27;我不喜欢北京&#x27;</span>]</span><br><span class="line"></span><br><span class="line">word_dict = &#123;&#125;</span><br><span class="line">text_vec = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 构建语料库</span></span><br><span class="line">    word_dict = construct_word_dict(txts)</span><br><span class="line">    <span class="comment"># 求出文本的向量表示</span></span><br><span class="line">    <span class="keyword">for</span> txt <span class="keyword">in</span> txts:</span><br><span class="line">        text_vec.append(vector_rep(txt, word_dict))</span><br><span class="line">    <span class="comment"># 利用余弦相似度判断文本相似度</span></span><br><span class="line">    <span class="built_in">print</span>(similarity_with_2_txts(text_vec[<span class="number">0</span>], text_vec[<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><blockquote><p>参考文章</p></blockquote><ol><li><p><a href="https://www.cnblogs.com/jclian91/p/9888381.html">NLP入门（一）词袋模型及句子相似度 - 山阴少年 - 博客园 (cnblogs.com)</a></p></li><li><p><a href="https://blog.csdn.net/Elenstone/article/details/105134863">词向量之词袋模型(BOW)详解_bow词袋模型_Elenstone的博客-CSDN博客</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 人工智能 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NLP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LaTex书写伪代码</title>
      <link href="/post/LaTexCode.html"/>
      <url>/post/LaTexCode.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于美赛和校赛两次数模需要用到伪代码算法的展示，笔者又不想每次通过word的表格去展示伪代码，奈何蒟蒻也不会LaTex，于是想着就用本篇博客来记录LaTex书写伪代码算法的模板以供后续直接在模板的基础上修改。话不多说，直接开搞！</p><h3 id="LaTex在线编辑器"><a href="#LaTex在线编辑器" class="headerlink" title="LaTex在线编辑器"></a>LaTex在线编辑器</h3><blockquote><p><a href="https://cn.overleaf.com/">https://cn.overleaf.com/</a></p></blockquote><h3 id="LaTex伪代码书写模板"><a href="#LaTex伪代码书写模板" class="headerlink" title="LaTex伪代码书写模板"></a>LaTex伪代码书写模板</h3><p>（具体见下方代码以及代码注释）</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">\def</span><span class="keyword">\SetClass</span>&#123;article&#125;</span><br><span class="line"><span class="keyword">\documentclass</span>&#123;<span class="keyword">\SetClass</span>&#125;</span><br><span class="line"><span class="comment">% algorithm2e生成伪代码的包：ruled(三线表样式)、linesnumbered(显示行号)</span></span><br><span class="line"><span class="keyword">\usepackage</span>[ruled,linesnumbered]&#123;algorithm2e&#125;</span><br><span class="line"><span class="comment">% xeCJK中文显示包（记得overleaf网页版在左上角Menu中Compiler改为‘XeLaTex’）</span></span><br><span class="line"><span class="keyword">\usepackage</span>&#123;xeCJK&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;document&#125;</span><br><span class="line"><span class="keyword">\begin</span>&#123;algorithm&#125;[H]</span><br><span class="line">  <span class="comment">% 显示end</span></span><br><span class="line">  <span class="keyword">\SetAlgoLined</span></span><br><span class="line">  <span class="comment">% 更改算法编号</span></span><br><span class="line">  <span class="keyword">\renewcommand</span>&#123;<span class="keyword">\thealgocf</span>&#125;&#123;3-1&#125;</span><br><span class="line">  <span class="comment">% 更改算法名字</span></span><br><span class="line">  <span class="keyword">\caption</span>&#123; Algorithm-name &#125;</span><br><span class="line">  <span class="comment">% 输入输出</span></span><br><span class="line">  <span class="keyword">\KwIn</span>&#123; 输入数据 &#125;</span><br><span class="line">  <span class="keyword">\KwOut</span>&#123; 输出数据 &#125;</span><br><span class="line">  <span class="comment">% 放一些数据初始化</span></span><br><span class="line">  Data-Initialization<span class="keyword">\;</span></span><br><span class="line">  <span class="comment">% \tcp:注释</span></span><br><span class="line">  <span class="keyword">\tcp</span>&#123;while语句&#125;</span><br><span class="line">  <span class="comment">% \while&#123;条件&#125;&#123;循环体&#125;</span></span><br><span class="line">  <span class="keyword">\While</span>&#123; word is not the end of the list &#125;&#123;</span><br><span class="line">    <span class="comment">% \;行末添加分号并自动换行</span></span><br><span class="line">    print(word) <span class="keyword">\;</span></span><br><span class="line">    <span class="comment">% \eIf&#123;条件&#125;&#123;肯定语句&#125;&#123;否定语句&#125;</span></span><br><span class="line">    <span class="keyword">\eIf</span>&#123; conditions &#125;&#123;</span><br><span class="line">      go to next section<span class="keyword">\;</span></span><br><span class="line">      current section becomes this one<span class="keyword">\;</span></span><br><span class="line">      &#125;&#123;</span><br><span class="line">      go back to the beginning of current section<span class="keyword">\;</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">% \If&#123;条件&#125;&#123;肯定语句&#125;</span></span><br><span class="line">    <span class="keyword">\If</span>&#123; word is equal to &quot;app&quot; &#125;&#123;</span><br><span class="line">      print(&quot;app is in this list!&quot;)<span class="keyword">\;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">% \For&#123;条件&#125;&#123;循环语句&#125;</span></span><br><span class="line">  <span class="keyword">\For</span>&#123; conditions &#125;&#123;</span><br><span class="line">    satisfy conditions behaviours<span class="keyword">\;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">% 返回值按照算法自行修改</span></span><br><span class="line">  return Summary<span class="keyword">\;</span></span><br><span class="line"><span class="keyword">\end</span>&#123;algorithm&#125;</span><br><span class="line"><span class="keyword">\end</span>&#123;document&#125;</span><br></pre></td></tr></table></figure><img src="/post/LaTexCode/1.png" class title="Final_Show">]]></content>
      
      
      <categories>
          
          <category> 数模学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flask操作Mysql数据库</title>
      <link href="/post/flask-pymysql.html"/>
      <url>/post/flask-pymysql.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在学习python的web框架Flask，在了解Flask操作数据库的时候，刚开始是想用Flask-SQLAlchemy这个扩展，但是一直由于版本等其他原因操作失败，今天查了以下pymysql这个库也可以用来操作MySql，浅浅试了一下貌似不错，所以就打算写下这篇博客来记录一下在Flask中如何使用pymysql操作数据库MySql</p><h2 id="PyMySql库"><a href="#PyMySql库" class="headerlink" title="PyMySql库"></a>PyMySql库</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>PyMySQL 是从 Python 连接到 MySQL 数据库服务器的接口，点击<a href="https://pymysql.readthedocs.io/en/latest/user/index.html">用户指南 — PyMySQL 0.7.2 文档</a>查看官方文档</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install pymysql</span><br></pre></td></tr></table></figure><h3 id="Flask框架中的使用"><a href="#Flask框架中的使用" class="headerlink" title="Flask框架中的使用"></a>Flask框架中的使用</h3><ol><li><p>文件config.py的配置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"></span><br><span class="line"><span class="comment"># 链接MySql数据库的配置</span></span><br><span class="line">DB_CONFIG = &#123;</span><br><span class="line">    <span class="string">&quot;host&quot;</span>: <span class="string">&quot;localhost&quot;</span>,</span><br><span class="line">    <span class="string">&quot;port&quot;</span>: <span class="number">3306</span>,</span><br><span class="line">    <span class="string">&quot;user&quot;</span>: <span class="string">&quot;root&quot;</span>,</span><br><span class="line">    <span class="string">&quot;passwd&quot;</span>: <span class="string">&quot;123456&quot;</span>,</span><br><span class="line">    <span class="string">&quot;db&quot;</span>: <span class="string">&quot;flask&quot;</span>,  <span class="comment"># 数据库要连接的数据库名称</span></span><br><span class="line">    <span class="string">&quot;charset&quot;</span>: <span class="string">&quot;utf8&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将对数据库的常用操作封装成一个类来使用</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SQLManager</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 初始化实例方法</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.conn = <span class="literal">None</span>  <span class="comment"># 初始化连接对象为空</span></span><br><span class="line">        self.cursor = <span class="literal">None</span>  <span class="comment"># 初始化游标对象为空</span></span><br><span class="line">        self.connect()  <span class="comment"># 调用自身连接数据库函数connect</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 连接数据库</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">connect</span>(<span class="params">self</span>):</span><br><span class="line">        self.conn = pymysql.connect(</span><br><span class="line">            host=DB_CONFIG[<span class="string">&quot;host&quot;</span>],</span><br><span class="line">            port=DB_CONFIG[<span class="string">&quot;port&quot;</span>],</span><br><span class="line">            user=DB_CONFIG[<span class="string">&quot;user&quot;</span>],</span><br><span class="line">            passwd=DB_CONFIG[<span class="string">&quot;passwd&quot;</span>],</span><br><span class="line">            db=DB_CONFIG[<span class="string">&quot;db&quot;</span>],</span><br><span class="line">            charset=DB_CONFIG[<span class="string">&quot;charset&quot;</span>]</span><br><span class="line">        )</span><br><span class="line">        self.cursor = self.conn.cursor()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 以下的sql参数均为MySql语句</span></span><br><span class="line">    <span class="comment"># fetchall()查询所有符合的数据</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_all</span>(<span class="params">self, sql, args=<span class="literal">None</span></span>):</span><br><span class="line">        self.cursor.execute(sql, args)</span><br><span class="line">        result = self.cursor.fetchall()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="comment"># fetchone()查询单条数据</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_one</span>(<span class="params">self, sql, args=<span class="literal">None</span></span>):</span><br><span class="line">        self.cursor.execute(sql, args)</span><br><span class="line">        result = self.cursor.fetchone()</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 执行单条SQL语句并commit提交（多次操作就要多次提交）</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">modify</span>(<span class="params">self, sql, args=<span class="literal">None</span></span>):</span><br><span class="line">        self.cursor.execute(sql, args)</span><br><span class="line">        self.conn.commit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 使用pymysql的executemany()可以执行多条SQL语句一次提交</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">multi_modify</span>(<span class="params">self, sql, args=<span class="literal">None</span></span>):</span><br><span class="line">        self.cursor.executemany(sql, args)</span><br><span class="line">        self.conn.commit()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 关闭数据库cursor和连接</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">close</span>(<span class="params">self</span>):</span><br><span class="line">        self.cursor.close()</span><br><span class="line">        self.conn.close()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 通过使用with语句可以实现缩进结束自动关闭文件句柄</span></span><br><span class="line">    <span class="comment"># 优化数据库连接类SQLManager类，使其支持with语句操作。</span></span><br><span class="line">    <span class="comment"># 进入with语句自动执行</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__enter__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 退出with语句块自动执行</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__exit__</span>(<span class="params">self, exc_type, exc_val, exc_tb</span>):</span><br><span class="line">        self.close()</span><br></pre></td></tr></table></figure></li><li><p>常用操作实例</p><ul><li><p>创建表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> flask <span class="keyword">import</span> Flask</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> config <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line">app.config.from_object(<span class="string">&#x27;config&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建实例</span></span><br><span class="line">db = SQLManager()</span><br><span class="line">db.modify(sql=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              CREATE TABLE IF NOT EXISTS `users`(</span></span><br><span class="line"><span class="string">              `id` INT UNSIGNED AUTO_INCREMENT NOT NULL ,</span></span><br><span class="line"><span class="string">              `nickName` VARCHAR(100) NOT NULL UNIQUE ,</span></span><br><span class="line"><span class="string">              `gender` INT UNSIGNED NOT NULL,</span></span><br><span class="line"><span class="string">              `telephone` VARCHAR(100) NOT NULL UNIQUE,</span></span><br><span class="line"><span class="string">              `email` VARCHAR(100) NOT NULL UNIQUE,</span></span><br><span class="line"><span class="string">              PRIMARY KEY ( `id` )</span></span><br><span class="line"><span class="string">              )ENGINE=InnoDB DEFAULT CHARSET=utf8mb4</span></span><br><span class="line"><span class="string">              &quot;&quot;&quot;</span>)</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure></li><li><p>插入操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.modify(sql=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">              INSERT INTO `users` </span></span><br><span class="line"><span class="string">              (id, nickName, gender, telephone, email)</span></span><br><span class="line"><span class="string">              VALUES</span></span><br><span class="line"><span class="string">              (0, &#x27;Aurora&#x27;, 1, &#x27;12345678910&#x27;, &#x27;1234567890@qq.com&#x27;)</span></span><br><span class="line"><span class="string">              &quot;&quot;&quot;</span>)</span><br><span class="line">db.close()</span><br></pre></td></tr></table></figure></li><li><p>查询操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询操作</span></span><br><span class="line">res = db.get_all(sql=<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">                    SELECT * FROM users;</span></span><br><span class="line"><span class="string">                    &quot;&quot;&quot;</span>)</span><br><span class="line">db.close()</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr><p>发现任何错误欢迎在评论区提出~</p><p>ps：可能由于评论系统的问题导致无法及时回应的话请谅解~</p>]]></content>
      
      
      <categories>
          
          <category> 开发范畴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Flask </tag>
            
            <tag> Mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一个微信小程序 —— PuppyHome</title>
      <link href="/post/PuppyHome.html"/>
      <url>/post/PuppyHome.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>最近一直忙着搞学校的icode比赛所以博客的更新就搁置了qwq，这个icode比赛我们是做一个小程序，而我是负责小程序的前端部分，这篇文章也是来记录一下第一次小程序的经历，技术性的东西估计不会讲太多，可能主要讲本项目如何使用腾讯云的COS对象存储以及一些开发中遇到的坑……</p><hr><h2 id="小程序介绍"><a href="#小程序介绍" class="headerlink" title="小程序介绍"></a>小程序介绍</h2><p>这个小程序是一个用来服务于修勾的平台，主要用户功能有发布、收藏、删除领养公告以及领养自己喜欢的修勾，以及本项目的一大亮点——“拍照识修勾”即用户拍照后平台进行分析得出相似度最高的修勾品种，当然这一困难part主要是后端方面的工作（想看后端介绍的友友可以去友链里面勋哥的博客看）,而我就负责前端的部分，具体小程序以及前端代码的github地址会在项目结束后会放在文章的最后……</p><img src="/post/PuppyHome/introduce.jpg" class title="Layout-Introduce"><h2 id="开发实记"><a href="#开发实记" class="headerlink" title="开发实记"></a>开发实记</h2><blockquote><p>var that = this的声明</p></blockquote><p>如若需要修改data里面的值并渲染到页面一般需要使用this.setData()，但是我们项目起初在调用wx.request()这个API时，在wx.request()里面使用this.setData()会报错，经过查询才知道要在wx.request()前面加上一下声明</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br></pre></td></tr></table></figure><p>而原因和this的作用域有关：</p><ul><li>在Page({})里面，this关键字指代Page({})整个对象，因此可以通过this关键字访问或者重新设置Page({})里data的变量，但是在wx.request()这个API后this的指向就发生改变就无法使用this来获取Page({})对象</li><li>而解决方法就是在wx.request()外面先把this存在某个变量中即上述声明，此时that指代Page({})整个对象，也就能在wx.request()中使用that来访问Page({})对象</li></ul><blockquote><p>腾讯云COS对象存储介绍</p></blockquote><p>在小程序中难免会碰到上传图片之类的操作，我们这个项目主要是在用户头像、公告发布、拍照识别等会用到图片上传，因为我们在数据库中图片是打算用一个字符串来存储（即图片链接），所以最后选择了腾讯云的COS对象存储，再将得到的图片链接传给后端，接下来就讲讲前期的准备工作</p><ol><li><p>进入腾讯云官网（<a href="https://cloud.tencent.com/">https://cloud.tencent.com</a> ），产品栏找到存储中的对象存储，进入之后点击“立即使用”登录，这里我用的是小程序公众号的方式登录，然后就进入对象存储的控制台界面</p><img src="/post/PuppyHome/enterCloud.png" class title="enterCloud"><img src="/post/PuppyHome/controlPage.png" class title="enterCloud"></li><li><p>创建存储桶</p><img src="/post/PuppyHome/step01.png" class title="Create"><img src="/post/PuppyHome/step02.png" class title="Create"><img src="/post/PuppyHome/step03.png" class title="Create"></li><li><p>进入具体的某个存储桶后可以进行文件的上传，也可以创建文件夹对上传的文件进行分类存放，上传后就可以可以得到对应图片的url链接</p></li><li><p>腾讯云对象存储除了提供多种 API 接口，还提供了丰富多样的 SDK 供开发者使用，这个项目用的就是其中的小程序SDK（<a href="https://cloud.tencent.com/document/product/436/31953">https://cloud.tencent.com/document/product/436/31953</a> ）</p></li></ol><blockquote><p>腾讯云COS对象存储的小程序SDK使用</p></blockquote><ol><li><p>首先是安装小程序SDK，我用的是官网中手动安装的方式（具体可查看官网），并将cos-wx-sdk-v5.js放在utils的目录下</p></li><li><p>小程序里请求 COS 需要登录到 <a href="https://mp.weixin.qq.com/">微信公众平台</a>，选择<strong>开发 &gt; 开发设置 &gt; 服务器域名</strong>，配置域名白名单。SDK 使用到了两个接口：</p><ul><li><p>cos.postObject 使用 wx.uploadFile 方法。</p></li><li><p>其他方法使用 wx. request 方法。</p></li></ul><p>需要在对应白名单里，配置 COS 域名，白名单域名格式有两种：</p><ul><li><p>如果是标准请求，可以配置存储桶域名作为白名单域名，例如：<code>https://examplebucket-1250000000.cos.ap-guangzhou.myqcloud.com</code>  （<strong>本项目使用这个</strong>）</p></li><li><p>如果小程序使用的存储桶多，可以选择后缀式请求 COS，只需要在 SDK 实例化时传入<code>ForcePathStyle: true</code>，这种方式需要配置地域域名作为白名单，例如：<code>cos.ap-guangzhou.myqcloud.com</code>。</p></li></ul><img src="/post/PuppyHome/settings.png" class title="settings"></li><li><p>初始化及其配置：官网介绍了四种方式，本项目使用的是比较简便的格式4，在需要使用上传图片的页面js中进行cos的初始化及其配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">COS</span> = <span class="built_in">require</span>(<span class="string">&#x27;../../../utils/cos-wx-sdk-v5.js&#x27;</span>); <span class="comment">//注意路径按照自己的更改</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 COS SDK 实例</span></span><br><span class="line"><span class="comment">// SECRETID 和 SECRETKEY 请登录 https://console.cloud.tencent.com/cam/capi 进行查看和管理</span></span><br><span class="line"><span class="keyword">var</span> cos = <span class="keyword">new</span> <span class="title function_">COS</span>(&#123;</span><br><span class="line">  <span class="title class_">SecretId</span>: <span class="string">&#x27;SECRETID&#x27;</span>,</span><br><span class="line">  <span class="title class_">SecretKey</span>: <span class="string">&#x27;SECRETKEY&#x27;</span>,</span><br><span class="line">  <span class="title class_">SimpleUploadMethod</span>: <span class="string">&#x27;putObject&#x27;</span>, <span class="comment">// 强烈建议，高级上传、批量上传内部对小文件做简单上传时使用putObject,sdk版本至少需要v1.3.0</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>上传函数实现</p><ul><li><p><strong>第一种：直接点击按钮上传</strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">UpLoadImg</span>()&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="comment">// 选择图片上传</span></span><br><span class="line">    wx.<span class="title function_">chooseMedia</span>(&#123; <span class="comment">//此API可以查看微信官方文档的具体参数信息</span></span><br><span class="line">      <span class="attr">count</span>: <span class="number">1</span>, <span class="comment">// 上传1张图片</span></span><br><span class="line">      <span class="attr">mediaType</span>: [<span class="string">&#x27;image&#x27;</span>], </span><br><span class="line">      <span class="attr">sourceType</span>: [<span class="string">&#x27;album&#x27;</span>,<span class="string">&#x27;camera&#x27;</span>], <span class="comment">// 拍摄图片或从相册选择图片</span></span><br><span class="line">      <span class="title function_">success</span>(<span class="params">res</span>)&#123;</span><br><span class="line">        <span class="comment">// 拿到本地的临时文件路径filePath，多张图片可以用for循环遍历上传</span></span><br><span class="line">        <span class="keyword">var</span> filePath = res.<span class="property">tempFiles</span>[<span class="number">0</span>].<span class="property">tempFilePath</span>;</span><br><span class="line">        <span class="comment">// 截取filePath最后一个斜杆的后面部分作为cloudPath</span></span><br><span class="line">        <span class="keyword">var</span> cloudPath = filePath.<span class="title function_">substr</span>(filePath.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>)</span><br><span class="line">        <span class="comment">// 使用腾讯云COS对象存储</span></span><br><span class="line">        cos.<span class="title function_">postObject</span>(&#123;</span><br><span class="line">          <span class="title class_">Bucket</span>: <span class="string">&#x27;Bucketname&#x27;</span>, <span class="comment">//对象储存桶的名称</span></span><br><span class="line">          <span class="title class_">Region</span>: <span class="string">&#x27;ap-guangzhou&#x27;</span>, <span class="comment">//所属地域</span></span><br><span class="line">          <span class="title class_">Key</span>: <span class="string">&#x27;dir/&#x27;</span> + cloudPath, <span class="comment">//存储在dir文件夹里面,如果没有区分文件夹就直接填cloudPath</span></span><br><span class="line">          <span class="title class_">FilePath</span>: filePath, <span class="comment">// 本地的临时文件路径</span></span><br><span class="line">          <span class="attr">onProgress</span>: <span class="keyword">function</span> (<span class="params">info</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进度条&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(info));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">          <span class="comment">// 这里用的是回调函数的形式，也可以用promise方式</span></span><br><span class="line">          <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;上传失败&#x27;</span>, err);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 上传成功赋值toIdentifyUrl</span></span><br><span class="line">            that.<span class="title function_">setData</span>(&#123;</span><br><span class="line">              <span class="comment">// 最终的图片地址toIdentifyUrl在data里面有声明</span></span><br><span class="line">              <span class="comment">// app.globalData.cdnHost是图片链接的公共前缀我放在app.js里面了</span></span><br><span class="line">              <span class="attr">toIdentifyUrl</span>: app.<span class="property">globalData</span>.<span class="property">cdnHost</span> + <span class="string">&#x27;dir/&#x27;</span> + cloudPath</span><br><span class="line">            &#125;)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>第二种：结合WeUI的mp-uploader组件进行上传</strong>（mp-uploader自带图片上传的相关参数）</p><p>WeUI的引入这里就不赘述了，首先是wxml的mp-uploader部分</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- photo是最终存放上传成功图片的列表，一般一开始是空的 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mp-uploader</span> <span class="attr">files</span>=<span class="string">&quot;&#123;&#123;photo&#125;&#125;&quot;</span> <span class="attr">max-count</span>=<span class="string">&quot;1&quot;</span> <span class="attr">max-size</span>=<span class="string">&quot;&#123;&#123;10 * 1024 * 1024&#125;&#125;&quot;</span> <span class="attr">title</span>=<span class="string">&quot;照片：&quot;</span> <span class="attr">tips</span>=<span class="string">&quot;最多上传一张图片&quot;</span> <span class="attr">size-type</span>=<span class="string">&quot;&#123;&#123;sizeType&#125;&#125;&quot;</span> <span class="attr">sourceType</span>=<span class="string">&quot;&#123;&#123;sourceType&#125;&#125;&quot;</span> <span class="attr">delete</span>=<span class="string">&quot;&#123;&#123;true&#125;&#125;&quot;</span> <span class="attr">select</span>=<span class="string">&quot;&#123;&#123;selectFile&#125;&#125;&quot;</span> <span class="attr">upload</span>=<span class="string">&quot;&#123;&#123;uplaodFile&#125;&#125;&quot;</span> <span class="attr">binddelete</span>=<span class="string">&quot;delimg&quot;</span> <span class="attr">bindfail</span>=<span class="string">&quot;uploadError&quot;</span> <span class="attr">bindsuccess</span>=<span class="string">&quot;uploadSuccess&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">mp-uploader</span>&gt;</span></span><br></pre></td></tr></table></figure><p>然后就是涉及到的上传图片的js代码，主要mp-uploader中5个函数的实现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="variable constant_">COS</span> = <span class="built_in">require</span>(<span class="string">&#x27;../../../utils/cos-wx-sdk-v5.js&#x27;</span>); <span class="comment">// 图片上传所需接口</span></span><br><span class="line"><span class="keyword">const</span> app = <span class="title function_">getApp</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个 COS SDK 实例</span></span><br><span class="line"><span class="comment">// SECRETID 和 SECRETKEY 请登录 https://console.cloud.tencent.com/cam/capi 进行查看和管理</span></span><br><span class="line"><span class="keyword">var</span> cos = <span class="keyword">new</span> <span class="title function_">COS</span>(&#123;</span><br><span class="line">  <span class="title class_">SecretId</span>: <span class="string">&#x27;SECRETID&#x27;</span>,</span><br><span class="line">  <span class="title class_">SecretKey</span>: <span class="string">&#x27;SECRETKEY&#x27;</span>,</span><br><span class="line">  <span class="title class_">SimpleUploadMethod</span>: <span class="string">&#x27;putObject&#x27;</span>, <span class="comment">// 强烈建议，高级上传、批量上传内部对小文件做简单上传时使用putObject,sdk版本至少需要v1.3.0</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="title class_">Page</span>(&#123;</span><br><span class="line">  <span class="attr">data</span>: &#123;</span><br><span class="line">    <span class="attr">photo</span>: [],</span><br><span class="line">    <span class="comment">//mp-uploader</span></span><br><span class="line">    <span class="attr">sizeType</span>: [<span class="string">&#x27;original&#x27;</span>], <span class="comment">//压缩上传,可以是[&#x27;original&#x27;, &#x27;compressed&#x27;]</span></span><br><span class="line">    <span class="attr">sourceType</span>: [<span class="string">&#x27;album&#x27;</span>, <span class="string">&#x27;camera&#x27;</span>], <span class="comment">//相册,或拍照</span></span><br><span class="line">    <span class="attr">maximgs</span>: <span class="number">1</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">onLoad</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="comment">//通过bind(this)将函数绑定到this上,以后函数内的this就是指全局页面</span></span><br><span class="line">      <span class="comment">//setdata以后,这两个函数就可以传递给mp-uploader了</span></span><br><span class="line">      <span class="attr">selectFile</span>: <span class="variable language_">this</span>.<span class="property">selectFile</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>),</span><br><span class="line">      <span class="attr">uplaodFile</span>: <span class="variable language_">this</span>.<span class="property">uplaodFile</span>.<span class="title function_">bind</span>(<span class="variable language_">this</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 图片上传相关函数</span></span><br><span class="line">  <span class="comment">// Func01：uplaodFile，必须返回Promise</span></span><br><span class="line">  <span class="title function_">uplaodFile</span>(<span class="params">files</span>) &#123;</span><br><span class="line">    <span class="comment">//Promise的callback里面必须resolve(&#123;urls&#125;)表示成功，否则表示失败</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> tempFilePaths = files.<span class="property">tempFilePaths</span>;</span><br><span class="line">      <span class="keyword">const</span> that = <span class="variable language_">this</span>;</span><br><span class="line">      <span class="keyword">let</span> finished = &#123;</span><br><span class="line">        <span class="attr">urls</span>: []</span><br><span class="line">      &#125; <span class="comment">//本次上次成功的URLs存入这个变量,被success方法的e.detail承接</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; tempFilePaths.<span class="property">length</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">let</span> filePath = tempFilePaths[i] <span class="comment">//原名</span></span><br><span class="line">        <span class="keyword">let</span> cloudPath = <span class="keyword">new</span> <span class="title class_">Date</span>().<span class="title function_">getTime</span>() + <span class="string">&#x27;-&#x27;</span> + filePath.<span class="title function_">substr</span>(filePath.<span class="title function_">lastIndexOf</span>(<span class="string">&#x27;/&#x27;</span>) + <span class="number">1</span>) <span class="comment">//云存储文件名</span></span><br><span class="line">        cos.<span class="title function_">postObject</span>(&#123;</span><br><span class="line">          <span class="title class_">Bucket</span>: <span class="string">&#x27;BucketName&#x27;</span>, <span class="comment">//对象储存桶的名称</span></span><br><span class="line">          <span class="title class_">Region</span>: <span class="string">&#x27;ap-guangzhou&#x27;</span>, <span class="comment">//所属地域</span></span><br><span class="line">          <span class="title class_">Key</span>: <span class="string">&#x27;dir/&#x27;</span> + cloudPath, <span class="comment">//存储在dir文件夹里面</span></span><br><span class="line">          <span class="title class_">FilePath</span>: filePath,</span><br><span class="line">          <span class="attr">onProgress</span>: <span class="keyword">function</span> (<span class="params">info</span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;进度条&#x27;</span>, <span class="title class_">JSON</span>.<span class="title function_">stringify</span>(info));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="keyword">function</span> (<span class="params">err, data</span>) &#123;</span><br><span class="line">          <span class="comment">// 这里用的是回调函数的形式，也可以用promise方式</span></span><br><span class="line">          <span class="keyword">if</span> (err) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;上传失败&#x27;</span>, err);</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            finished.<span class="property">urls</span>.<span class="title function_">push</span>(&#123;</span><br><span class="line">              <span class="attr">url</span>: app.<span class="property">globalData</span>.<span class="property">cdnHost</span> + <span class="string">&#x27;dogs/&#x27;</span> + cloudPath</span><br><span class="line">            &#125;) <span class="comment">//成功一个存一个到本次上传成功列表</span></span><br><span class="line">            <span class="comment">//如果本次上传的文件都完成 或全局已经存满1张,resolve退出</span></span><br><span class="line">            <span class="keyword">if</span> (finished.<span class="property">urls</span>.<span class="property">length</span> === tempFilePaths.<span class="property">length</span> || that.<span class="property">data</span>.<span class="property">files</span>.<span class="property">length</span> + finished.<span class="property">urls</span>.<span class="property">length</span> == <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">maximgs</span>) &#123;</span><br><span class="line">              <span class="title function_">resolve</span>(finished)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Func02：uploadSuccess，上传成功函数</span></span><br><span class="line">  <span class="title function_">uploadSuccess</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;upload success&#x27;</span>, e.<span class="property">detail</span>)</span><br><span class="line">    <span class="comment">// 将新上传的urls接到目前的photo上</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">photo</span> = <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">photo</span>.<span class="title function_">concat</span>(e.<span class="property">detail</span>.<span class="property">urls</span>)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setData</span>(&#123;</span><br><span class="line">      <span class="attr">photo</span>: <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">photo</span></span><br><span class="line">    &#125;)</span><br><span class="line">    wx.<span class="title function_">hideLoading</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Func03：delimg删除图片</span></span><br><span class="line">  <span class="comment">// detail为&#123;index, item&#125;，index表示删除的图片的下标，item为图片对象。</span></span><br><span class="line">  <span class="title function_">delimg</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">photo</span>.<span class="title function_">splice</span>(<span class="variable language_">this</span>.<span class="property">data</span>.<span class="property">photo</span>.<span class="title function_">findIndex</span>(<span class="function"><span class="params">item</span> =&gt;</span> item == e.<span class="property">detail</span>.<span class="property">item</span>), <span class="number">1</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Func04：uploadError，上传失败函数</span></span><br><span class="line">  <span class="title function_">uploadError</span>(<span class="params">e</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;upload error&#x27;</span>, e.<span class="property">detail</span>)</span><br><span class="line">    wx.<span class="title function_">hideLoading</span>()</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Func05：selectFile，mpuploader选择图片时的过滤函数，返回true表示图片有效</span></span><br><span class="line">  <span class="title function_">selectFile</span>(<span class="params">files</span>) &#123;</span><br><span class="line">    wx.<span class="title function_">showLoading</span>(&#123;</span><br><span class="line">      <span class="attr">title</span>: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="项目源码github地址"><a href="#项目源码github地址" class="headerlink" title="项目源码github地址"></a>项目源码github地址</h2><p>2023-3-21 13:55 项目基本完成，过段时间开源项目前端代码……<br>2023-4-23 8:31  </p><ol><li>前端项目代码github链接：<blockquote><p><a href="https://github.com/2aurora2/PuppyHome_WeChatApp">https://github.com/2aurora2/PuppyHome_WeChatApp</a></p></blockquote></li><li>B站演示视频链接：<blockquote><p><a href="https://www.bilibili.com/video/BV1Fv4y1J7va/?spm_id_from=333.999.0.0&amp;vd_source=4eacc3ec90d2d047330b4cb99502e3a4">https://www.bilibili.com/video/BV1Fv4y1J7va/?spm_id_from=333.999.0.0&amp;vd_source=4eacc3ec90d2d047330b4cb99502e3a4</a></p></blockquote></li></ol><h2 id="实用CSS工具"><a href="#实用CSS工具" class="headerlink" title="实用CSS工具"></a>实用CSS工具</h2><ol><li><a href="https://uiverse.io/all">All elements made with CSS and HTML (uiverse.io)</a></li><li><a href="https://yoksel.github.io/flex-cheatsheet/#section-declaring">Flex Cheatsheet (yoksel.github.io)</a></li><li><a href="https://neumorphism.io/#ffffff">Neumorphism/Soft UI CSS shadow generator</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 开发范畴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> WeChat Mini Program </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据分析图表的绘制</title>
      <link href="/post/data_analysis.html"/>
      <url>/post/data_analysis.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先祝大家元宵节快乐呀！这篇文章呢主要就是介绍如何绘制常见的数据分析图表，更多地是讲如何利用python的matplotlib库来绘制，也会提及一些现成的工具。</p><hr><p>2023.11.13 参加了几次数模后想着来更新一波内容（主要是美化一下，之前的有点小丑……</p><h2 id="Python"><a href="#Python" class="headerlink" title="Python"></a>Python</h2><p>Python绘制数据分析图表主要用到的是matplotlib这个库，使用前先安装这个库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install matplotlib</span><br></pre></td></tr></table></figure><p>然后导入子模块pyplot</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br></pre></td></tr></table></figure><p>对于图表中可能会出现中文显示不了的问题，一般要在开始前加上以下语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 解决中文显示问题 </span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br></pre></td></tr></table></figure><h3 id="折线图"><a href="#折线图" class="headerlink" title="折线图"></a>折线图</h3><p>折线图（Line Chart）是一种将数据点按照顺序连接起来的图形，也可以看作是将散点图按照X轴坐标顺序链接起来的图形。折线图的主要功能是查看因变量y随着自变量x改变的趋势，最适合用于显示随时间（根据常用比例设置）而改变的连续数据。同时，还可以看出数量的差异，python画折线图主要利用<strong>plot</strong>方法</p><p>实例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Times New Romen&#x27;</span>, <span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># x轴的数据</span></span><br><span class="line">seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># x对应的y值</span></span><br><span class="line">data1 = np.random.randint(<span class="number">50</span>, size=<span class="number">10</span>)</span><br><span class="line">data2 = np.random.randint(<span class="number">50</span>, size=<span class="number">10</span>)</span><br><span class="line">data3 = np.random.randint(<span class="number">50</span>, size=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot绘制折线图</span></span><br><span class="line"><span class="comment"># 1.前两个参数是对应x轴y轴数据，marker是数据点样式，linewidth是线宽，linestyle是线条样式，color是线条颜色</span></span><br><span class="line"><span class="comment"># 2.linestyle常用属性值：</span></span><br><span class="line"><span class="comment">#   &#x27;-&#x27; 实线   &#x27;--&#x27; 虚线   &#x27;-.&#x27; 虚点线   &#x27;:&#x27; 点线</span></span><br><span class="line"><span class="comment"># 3.color常用属性值缩写：（也可使用十六进制颜色表示法）</span></span><br><span class="line"><span class="comment">#   &#x27;b&#x27; 蓝色   &#x27;g&#x27; 绿色   &#x27;r&#x27; 红色   &#x27;c&#x27; 青色   &#x27;m&#x27; 品红   &#x27;y&#x27; 黄色   &#x27;k&#x27; 黑色   &#x27;w&#x27; 白色</span></span><br><span class="line"><span class="comment"># 4.mfc数据点的填充颜色</span></span><br><span class="line"><span class="comment"># 5.ms数据点的大小</span></span><br><span class="line">plt.plot(seq, data1, marker=<span class="string">&#x27;o&#x27;</span>, linewidth=<span class="number">1</span>, linestyle=<span class="string">&#x27;-&#x27;</span>, color=<span class="string">&#x27;#6562FF&#x27;</span>, label=<span class="string">&#x27;数据一&#x27;</span>, mfc=<span class="string">&#x27;white&#x27;</span>, ms=<span class="number">5</span>)</span><br><span class="line">plt.plot(seq, data2, marker=<span class="string">&#x27;o&#x27;</span>, linewidth=<span class="number">1</span>, linestyle=<span class="string">&#x27;-&#x27;</span>, color=<span class="string">&#x27;m&#x27;</span>, label=<span class="string">&#x27;数据二&#x27;</span>, mfc=<span class="string">&#x27;white&#x27;</span>, ms=<span class="number">5</span>)</span><br><span class="line">plt.plot(seq, data3, marker=<span class="string">&#x27;o&#x27;</span>, linewidth=<span class="number">1</span>, linestyle=<span class="string">&#x27;-&#x27;</span>, color=<span class="string">&#x27;g&#x27;</span>, label=<span class="string">&#x27;数据三&#x27;</span>, mfc=<span class="string">&#x27;white&#x27;</span>, ms=<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置标题及字体大小</span></span><br><span class="line"><span class="comment"># plt.title(label=&#x27;Test Chart&#x27;, fontsize=18)</span></span><br><span class="line">plt.xlabel(xlabel=<span class="string">&#x27;x轴&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line">plt.ylabel(ylabel=<span class="string">&#x27;y轴&#x27;</span>, fontsize=<span class="number">14</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> tick <span class="keyword">in</span> plt.gca().get_yticklabels():</span><br><span class="line">    plt.axhline(y=tick.get_position()[<span class="number">1</span>], color=<span class="string">&#x27;#b8bcbf&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>, linewidth=<span class="number">1</span>, zorder=-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置图例</span></span><br><span class="line"><span class="comment"># 参数loc可以设置图例在图表中的位置</span></span><br><span class="line"><span class="comment">#     &#x27;best&#x27;</span></span><br><span class="line"><span class="comment">#     &#x27;upper right&#x27;:右上角</span></span><br><span class="line"><span class="comment">#     &#x27;upper left&#x27;: 左上角</span></span><br><span class="line"><span class="comment">#     &#x27;lower left&#x27;: 左下角</span></span><br><span class="line"><span class="comment">#     &#x27;lower right&#x27;: 右下角</span></span><br><span class="line"><span class="comment">#     &#x27;center left&#x27;: 左侧中央</span></span><br><span class="line"><span class="comment">#     &#x27;center right&#x27;: 右侧中间</span></span><br><span class="line"><span class="comment">#     &#x27;lower center&#x27;: 底部正中</span></span><br><span class="line"><span class="comment">#     &#x27;upper center&#x27;: 顶部正中</span></span><br><span class="line"><span class="comment"># 将图例放在图表外loc设置为best，通过添加bbox_to_anchor属性设置锚点即图例位置：在图表内，左下角位置为(0,0)，右上角位置为(1,1)</span></span><br><span class="line">plt.legend(loc=<span class="string">&#x27;best&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 去掉上边框和有边框</span></span><br><span class="line">plt.gca().spines[<span class="string">&#x27;top&#x27;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line">plt.gca().spines[<span class="string">&#x27;right&#x27;</span>].set_visible(<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># savefig保存图片</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;test.jpg&#x27;</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)  <span class="comment"># bbox_inches=&#x27;tight&#x27;将图表的多余空间删除</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图：</p><img src="/post/data_analysis/1.jpg" class title="This is an example image"><h3 id="散点图"><a href="#散点图" class="headerlink" title="散点图"></a>散点图</h3><p>散点图（Scatter Diagram）又称为散点分布图，是以一个特征为横坐标，另一个特征为纵坐标，使用坐标点（散点）的分布形态反映特征间统计关系的一种图形。值时由点在图表中的位置表示，类别是由图表中的不同标记表示 ，通常用于比较跨类别的数据，python画散点图主要利用<strong>scatter</strong>方法</p><p>scatter方法主要参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.scatter(x,y,s=<span class="literal">None</span>,c=<span class="literal">None</span>,marker=<span class="literal">None</span>,alpha=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>scatter方法主要参数说明</p><img src="/post/data_analysis/1.png" class title="This is an example image"><p>实例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># label属性是设置图例名称</span></span><br><span class="line"><span class="comment"># # 绘制一组数据散点图</span></span><br><span class="line"><span class="comment"># x = np.arange(1, 30)</span></span><br><span class="line"><span class="comment"># y = np.sin(x)</span></span><br><span class="line"><span class="comment"># plt.scatter(x,y,c=&#x27;orange&#x27;,s=100,label=&#x27;orange&#x27;,marker=&#x27;o&#x27;,alpha=0.5)</span></span><br><span class="line"><span class="comment"># 绘制多组数据散点图</span></span><br><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]:</span><br><span class="line">    x, y = np.random.randn(<span class="number">2</span>, <span class="number">500</span>)</span><br><span class="line">    plt.scatter(x, y, c=color, label=color, alpha=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置标题和横纵坐标</span></span><br><span class="line">plt.title(<span class="string">&#x27;散点图&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图例</span></span><br><span class="line">plt.legend()</span><br><span class="line"></span><br><span class="line"><span class="comment"># savefig保存图片</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;test.jpg&#x27;</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)  <span class="comment"># bbox_inches=&#x27;tight&#x27;将图表的多余空间删除</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图</p><img src="/post/data_analysis/2.jpg" class title="This is an example image"><h3 id="饼图"><a href="#饼图" class="headerlink" title="饼图"></a>饼图</h3><p> 饼图（Pie Graph）用于表示不同分类的占比情况，通过弧度大小来对比各种分类，饼图可以比较清楚的反映出部分与部分、部分与整体之间的比例关系，易于显示每组数据相对于总数的大小，而且显现的方式直观。python画饼图主要利用<strong>pie</strong>方法</p><p>pie方法主要参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">matplotlib.pyplot.pie(x,explode = <span class="literal">None</span>,labels = <span class="literal">None</span>,color = <span class="literal">None</span>,autopct = <span class="literal">None</span>,</span><br><span class="line">pctdistance = <span class="number">0.6</span>,shadow=false,labeldistance=<span class="number">1.1</span>,startangle=<span class="literal">None</span>,radius=<span class="literal">None</span>,...)</span><br></pre></td></tr></table></figure><p>实例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># x：指定绘图的数据；</span></span><br><span class="line"><span class="comment"># explode：指定饼图某些部分的突出显示，即呈现爆炸式；</span></span><br><span class="line"><span class="comment"># labels：为饼图添加标签说明，类似于图例说明；</span></span><br><span class="line"><span class="comment"># colors：指定饼图的填充色；</span></span><br><span class="line"><span class="comment"># autopct：自动添加百分比显示，可以采用格式化的方法显示；</span></span><br><span class="line"><span class="comment"># pctdistance：设置百分比标签与圆心的距离；</span></span><br><span class="line"><span class="comment"># shadow：是否添加饼图的阴影效果；</span></span><br><span class="line"><span class="comment"># labeldistance：设置各扇形标签（图例）与圆心的距离；</span></span><br><span class="line"><span class="comment"># startangle：设置饼图的初始摆放角度；</span></span><br><span class="line"><span class="comment"># radius：设置饼图的半径大小；</span></span><br><span class="line"><span class="comment"># counterclock：是否让饼图按逆时针顺序呈现；</span></span><br><span class="line"><span class="comment"># wedgeprops：设置饼图内外边界的属性，如边界线的粗细、颜色等；</span></span><br><span class="line"><span class="comment"># textprops：设置饼图中文本的属性，如字体大小、颜色等；</span></span><br><span class="line"><span class="comment"># center：指定饼图的中心点位置，默认为原点</span></span><br><span class="line"><span class="comment"># frame：是否要显示饼图背后的图框，如果设置为True的话，需要同时控制图框x轴、y轴的范围和饼图的中心位置</span></span><br><span class="line">labels = [<span class="string">&#x27;30岁&#x27;</span>, <span class="string">&#x27;40岁&#x27;</span>, <span class="string">&#x27;50岁&#x27;</span>, <span class="string">&#x27;60岁&#x27;</span>]</span><br><span class="line">x = [<span class="number">15</span>, <span class="number">30</span>, <span class="number">45</span>, <span class="number">10</span>]  <span class="comment"># 各个标签的数量</span></span><br><span class="line">explode = (<span class="number">0.05</span>, <span class="number">0.05</span>, <span class="number">0.05</span>, <span class="number">0.05</span>)  <span class="comment"># 每个标签的扇形图距离圆心的距离</span></span><br><span class="line">plt.pie(x=x,</span><br><span class="line">        autopct=<span class="string">&#x27;%.2f%%&#x27;</span>,</span><br><span class="line">        colors=[<span class="string">&#x27;#eab4ad&#x27;</span>, <span class="string">&#x27;#afc6d2&#x27;</span>, <span class="string">&#x27;#b0d1bb&#x27;</span>, <span class="string">&#x27;#87cefa&#x27;</span>],</span><br><span class="line">        labels=labels,</span><br><span class="line">        pctdistance=<span class="number">0.6</span>,</span><br><span class="line">        labeldistance=<span class="number">1.1</span>,</span><br><span class="line">        explode=explode,</span><br><span class="line">        wedgeprops=&#123;<span class="string">&#x27;edgecolor&#x27;</span>: <span class="string">&#x27;r&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;linestyle&#x27;</span>: <span class="string">&#x27;--&#x27;</span>&#125;,</span><br><span class="line">        textprops=&#123;<span class="string">&quot;fontsize&quot;</span>: <span class="number">13</span>, <span class="string">&quot;color&quot;</span>: <span class="string">&quot;black&quot;</span>&#125;,</span><br><span class="line">        shadow=<span class="literal">True</span></span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置标题和横纵坐标</span></span><br><span class="line">plt.title(<span class="string">&#x27;饼状图&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># savefig保存图片</span></span><br><span class="line">plt.savefig(<span class="string">&#x27;test.jpg&#x27;</span>, bbox_inches=<span class="string">&#x27;tight&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图</p><img src="/post/data_analysis/3.jpg" class title="This is an example image"><h3 id="直方图"><a href="#直方图" class="headerlink" title="直方图"></a>直方图</h3><p>直方图（Histogram）又称质量分布图，是统计报告图的一种，由一系列高度不等的纵向条纹或线段表示数据分布的情况，一般用横轴表示数据所属类别，纵轴表示数量或者占比。用直方图可以比较直观地看出产品质量特性的分布状态，便于判断其总体质量分布情况。直方图可以发现分布表无法发现的数据模式、样本的频率分布和总体的分布。python画饼图主要利用<strong>bar</strong>方法</p><p>bar方法主要参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 参数说明</span></span><br><span class="line"><span class="comment"># x：传递数值序列，指定条形图中x轴上的刻度值。</span></span><br><span class="line"><span class="comment"># height：传递数值序列，指定条形图y轴上的高度。</span></span><br><span class="line"><span class="comment"># width：指定条形图的宽度，默认为0.8。 bottom：用于绘制堆叠条形图。</span></span><br><span class="line"><span class="comment"># color：指定条形图的填充色。</span></span><br><span class="line"><span class="comment"># edgecolor：指定条形图的边框色。</span></span><br><span class="line"><span class="comment"># linewidth：指定条形图边框的宽度，如果指定为0，表示不绘制边框。</span></span><br><span class="line"><span class="comment"># tick_label：指定条形图的刻度标签。</span></span><br><span class="line"><span class="comment"># xerr：如果参数不为None，表示在条形图的基础上添加误差棒。</span></span><br><span class="line"><span class="comment"># yerr：参数含义同xerr。</span></span><br><span class="line"><span class="comment"># label：指定条形图的标签，一般用以添加图例。</span></span><br><span class="line"><span class="comment"># ecolor：指定条形图误差棒的颜色。</span></span><br><span class="line"><span class="comment"># align：指定x轴刻度标签的对齐方式，默认为center，表示刻度标签居中对齐，如果设置为edge，则表示在每个条形的左下角呈现刻度标签。</span></span><br><span class="line"><span class="comment"># log：bool类型参数，是否对坐标轴进行log变换，默认为False。</span></span><br><span class="line"><span class="comment"># **kwargs：关键字参数，用于对条形图进行其他设置，如透明度等。</span></span><br><span class="line">bar(x, height, width=<span class="number">0.8</span>, bottom=<span class="literal">None</span>, color=<span class="literal">None</span>, edgecolor=<span class="literal">None</span>,</span><br><span class="line">   linewidth=<span class="literal">None</span>, tick_label=<span class="literal">None</span>, xerr=<span class="literal">None</span>, yerr=<span class="literal">None</span>,</span><br><span class="line">   label = <span class="literal">None</span>, ecolor=<span class="literal">None</span>, align, log=<span class="literal">False</span>, **kwargs)</span><br></pre></td></tr></table></figure><h4 id="水平交错条形图"><a href="#水平交错条形图" class="headerlink" title="水平交错条形图"></a>水平交错条形图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Microsoft YaHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"><span class="comment"># 设置绘图风格</span></span><br><span class="line">plt.style.use(<span class="string">&#x27;ggplot&#x27;</span>)</span><br><span class="line"><span class="comment"># 城市名称</span></span><br><span class="line">Cities = [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;香港&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>, <span class="string">&#x27;广州&#x27;</span>]</span><br><span class="line"><span class="comment"># 取出2016年各城市亿万资产家庭数</span></span><br><span class="line">Counts2016 = [<span class="number">15600</span>, <span class="number">12700</span>, <span class="number">11300</span>, <span class="number">4270</span>, <span class="number">3820</span>]</span><br><span class="line"><span class="comment"># 取出2017年各城市亿万资产家庭数</span></span><br><span class="line">Counts2017 = [<span class="number">17400</span>, <span class="number">14800</span>, <span class="number">12000</span>, <span class="number">5200</span>, <span class="number">4020</span>]</span><br><span class="line"><span class="comment"># 绘制水平交错条形图</span></span><br><span class="line">bar_width = <span class="number">0.4</span></span><br><span class="line">plt.bar(x=np.arange(<span class="built_in">len</span>(Cities)), height=Counts2016, label=<span class="string">&#x27;2016&#x27;</span>, color=<span class="string">&#x27;steelblue&#x27;</span>, width=bar_width)</span><br><span class="line">plt.bar(x=np.arange(<span class="built_in">len</span>(Cities)) + bar_width, height=Counts2017, label=<span class="string">&#x27;2017&#x27;</span>, color=<span class="string">&#x27;indianred&#x27;</span>, width=bar_width)</span><br><span class="line"><span class="comment"># 添加x轴刻度标签（向右偏移0.225）</span></span><br><span class="line">plt.xticks(np.arange(<span class="number">5</span>) + <span class="number">0.2</span>, Cities)</span><br><span class="line"><span class="comment"># 添加y轴标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;亿万资产家庭数&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加图形标题</span></span><br><span class="line">plt.title(<span class="string">&#x27;近两年5个城市亿万资产家庭数比较&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加图例</span></span><br><span class="line">plt.legend()</span><br><span class="line"><span class="comment"># 为每个条形图添加数值标签</span></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(Counts2016):</span><br><span class="line">    plt.text(x, y + <span class="number">200</span>, <span class="string">&quot;%s&quot;</span> % <span class="built_in">round</span>(y, <span class="number">1</span>), ha=<span class="string">&#x27;center&#x27;</span>)  <span class="comment"># round(y,1)是将y值四舍五入到一个小数位</span></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(Counts2017):</span><br><span class="line">    plt.text(x + bar_width, y + <span class="number">200</span>, <span class="string">&quot;%s&quot;</span> % <span class="built_in">round</span>(y, <span class="number">1</span>), ha=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"><span class="comment"># 保存图像</span></span><br><span class="line">plt.savefig(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图</p><img src="/post/data_analysis/4.jpg" class title="This is an example image"><h4 id="水平条形图"><a href="#水平条形图" class="headerlink" title="水平条形图"></a>水平条形图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置绘图风格</span></span><br><span class="line">plt.style.use(<span class="string">&#x27;ggplot&#x27;</span>)</span><br><span class="line"><span class="comment"># 处理中文乱码</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Microsoft YaHei&#x27;</span>]</span><br><span class="line"><span class="comment"># 水平条形图一般具有一定顺序</span></span><br><span class="line">Cities = [<span class="string">&#x27;广东&#x27;</span>, <span class="string">&#x27;江苏&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;重庆&#x27;</span>, <span class="string">&#x27;天津&#x27;</span>]</span><br><span class="line">GDP = [<span class="number">9</span>, <span class="number">8.6</span>, <span class="number">3</span>, <span class="number">2.8</span>, <span class="number">2</span>, <span class="number">1.9</span>]</span><br><span class="line"><span class="comment"># 绘制条形图</span></span><br><span class="line">plt.barh(y=<span class="built_in">range</span>(<span class="built_in">len</span>(Cities)),  <span class="comment"># 指定条形图y轴的刻度值</span></span><br><span class="line">         width=GDP,  <span class="comment"># 指定条形图x轴的数值</span></span><br><span class="line">         tick_label=Cities,  <span class="comment"># 指定条形图y轴的刻度标签</span></span><br><span class="line">         color=[<span class="string">&#x27;#da7d61&#x27;</span>, <span class="string">&#x27;#3f3f5c&#x27;</span>, <span class="string">&#x27;#86af9d&#x27;</span>, <span class="string">&#x27;#467b9d&#x27;</span>, <span class="string">&#x27;#f0c986&#x27;</span>]</span><br><span class="line">         )</span><br><span class="line"><span class="comment"># 添加x轴的标签</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;GDP(万亿)&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;2017年度6个省份GDP分布&#x27;</span>)</span><br><span class="line"><span class="comment"># 为每个条形图添加数值标签</span></span><br><span class="line"><span class="keyword">for</span> y, x <span class="keyword">in</span> <span class="built_in">enumerate</span>(GDP):</span><br><span class="line">    plt.text(x + <span class="number">0.1</span>, y, <span class="string">&quot;%s&quot;</span> % <span class="built_in">round</span>(x, <span class="number">1</span>), va=<span class="string">&#x27;center&#x27;</span>)  <span class="comment"># round(y,1)是将y值四舍五入到一个小数位</span></span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图</p><img src="/post/data_analysis/5.jpg" class title="This is an example image"><h4 id="垂直条形图"><a href="#垂直条形图" class="headerlink" title="垂直条形图"></a>垂直条形图</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置绘图风格</span></span><br><span class="line">plt.style.use(<span class="string">&#x27;ggplot&#x27;</span>)</span><br><span class="line"><span class="comment"># 处理中文乱码</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Microsoft YaHei&#x27;</span>]</span><br><span class="line">Cities = [<span class="string">&#x27;广东&#x27;</span>, <span class="string">&#x27;江苏&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;重庆&#x27;</span>, <span class="string">&#x27;天津&#x27;</span>]</span><br><span class="line">GDP = [<span class="number">9</span>, <span class="number">8.6</span>, <span class="number">3</span>, <span class="number">2.8</span>, <span class="number">2</span>, <span class="number">1.9</span>]</span><br><span class="line"><span class="comment"># 绘制条形图</span></span><br><span class="line">plt.bar(x=<span class="built_in">range</span>(<span class="built_in">len</span>(Cities)),  <span class="comment"># 指定条形图x轴的刻度值(有的是用left，有的要用x)</span></span><br><span class="line">        height=GDP,  <span class="comment"># 指定条形图y轴的数值（python3.7不能用y，而应该用height）</span></span><br><span class="line">        tick_label=Cities,  <span class="comment"># 指定条形图x轴的刻度标签</span></span><br><span class="line">        color=<span class="string">&#x27;steelblue&#x27;</span>,  <span class="comment"># 指定条形图的填充色</span></span><br><span class="line">        )</span><br><span class="line"><span class="comment"># 添加y轴的标签</span></span><br><span class="line">plt.ylabel(<span class="string">&#x27;GDP(万亿)&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加条形图的标题</span></span><br><span class="line">plt.title(<span class="string">&#x27;2017年度6个省份GDP分布&#x27;</span>)</span><br><span class="line"><span class="comment"># 为每个条形图添加数值标签</span></span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(GDP):</span><br><span class="line">    plt.text(x, y + <span class="number">0.1</span>, <span class="string">&quot;%s&quot;</span> % <span class="built_in">round</span>(y, <span class="number">1</span>), ha=<span class="string">&#x27;center&#x27;</span>)  <span class="comment"># round(y,1)是将y值四舍五入到一个小数位</span></span><br><span class="line"><span class="comment"># 保存图片</span></span><br><span class="line">plt.savefig(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图</p><img src="/post/data_analysis/6.jpg" class title="This is an example image"><h3 id="热力图"><a href="#热力图" class="headerlink" title="热力图"></a>热力图</h3><p>利用热力图可以看数据表里多个特征两两的相似度，在python种一般利用seaborn中的heatmap方法</p><p>heatmap方法常用参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">seaborn.heatmap(data, vmin=<span class="literal">None</span>, vmax=<span class="literal">None</span>,cmap=<span class="literal">None</span>, center=<span class="literal">None</span>, robust=<span class="literal">False</span>, annot=<span class="literal">None</span>, fmt=’<span class="number">.2</span>g’, annot_kws=<span class="literal">None</span>,linewidths=<span class="number">0</span>, linecolor=’white’, cbar=<span class="literal">True</span>, cbar_kws=<span class="literal">None</span>, cbar_ax=<span class="literal">None</span>,square=<span class="literal">False</span>, xticklabels=’auto’, yticklabels=’auto’, mask=<span class="literal">None</span>, ax=<span class="literal">None</span>,**kwargs)</span><br></pre></td></tr></table></figure><p>实例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Microsoft YaHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">data = np.random.rand(<span class="number">5</span>, <span class="number">5</span>)  <span class="comment"># 指定生成5x5的元素是0-1的二维数组</span></span><br><span class="line">df = pd.DataFrame(data, columns=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>], index=<span class="built_in">range</span>(<span class="number">1</span>, <span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">corr = df.corr()</span><br><span class="line">mask = np.zeros_like(corr)</span><br><span class="line">mask[np.triu_indices_from(mask)] = <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数解释：</span></span><br><span class="line"><span class="comment"># data:矩阵数据集，可以是numpy的数组（array），也可以是pandas的DataFrame。如果是DataFrame，则df的index/column信息会分别对应到heatmap的columns和rows，即df.index是热力图的行标，df.columns是热力图的列标</span></span><br><span class="line"><span class="comment"># vmax,vmin:分别是热力图的颜色取值最大和最小范围，默认是根据data数据表里的取值确定</span></span><br><span class="line"><span class="comment"># cmap:从数字到色彩空间的映射，取值是matplotlib包里的colormap名称或颜色对象，或者表示颜色的列表；一般有‘YlGnBu’和‘BuPu_r’</span></span><br><span class="line"><span class="comment"># center:数据表取值有差异时，设置热力图的色彩中心对齐值；通过设置center值，可以调整生成的图像颜色的整体深浅；设置center数据时，如果有数据溢出，则手动设置的vmax、vmin会自动改变</span></span><br><span class="line"><span class="comment"># robust:默认取值False；如果是False，且没设定vmin和vmax的值，热力图的颜色映射范围根据具有鲁棒性的分位数设定，而不是用极值设定</span></span><br><span class="line"><span class="comment"># annot(annotate的缩写):默认取值False；如果是True，在热力图每个方格写入数据；如果是矩阵，在热力图每个方格写入该矩阵对应位置数据</span></span><br><span class="line"><span class="comment"># fmt:字符串格式代码，矩阵上标识数字的数据格式，比如保留小数点后几位数字</span></span><br><span class="line"><span class="comment"># annot_kws:默认取值False；如果是True，设置热力图矩阵上数字的大小颜色字体，matplotlib包text类下的字体设置；</span></span><br><span class="line"><span class="comment"># linewidths:定义热力图里“表示两两特征关系的矩阵小块”之间的间隔大小</span></span><br><span class="line"><span class="comment"># linecolor:切分热力图上每个矩阵小块的线的颜色，默认值是’white’</span></span><br><span class="line"><span class="comment"># cbar:是否在热力图侧边绘制颜色刻度条，默认值是True</span></span><br><span class="line"><span class="comment"># cbar_kws:热力图侧边绘制颜色刻度条时，相关字体设置，默认值是None</span></span><br><span class="line"><span class="comment"># cbar_ax:热力图侧边绘制颜色刻度条时，刻度条位置设置，默认值是None</span></span><br><span class="line"><span class="comment"># xticklabels, yticklabels:xticklabels控制每列标签名的输出；yticklabels控制每行标签名的输出。默认值是auto:</span></span><br><span class="line"><span class="comment">#     如果是True，则以DataFrame的列名作为标签名。如果是False，则不添加行标签名。如果是列表，则标签名改为列表中给的内容。如果是整数K，则在图上每隔K个标签进行一次标注。</span></span><br><span class="line"><span class="comment">#     如果是auto，则自动选择标签的标注间距，将标签名不重叠的部分(或全部)输出</span></span><br><span class="line"><span class="comment"># mask:控制某个矩阵块是否显示出来。默认值是None。如果是布尔型的DataFrame，则将DataFrame里True的位置用白色覆盖掉</span></span><br><span class="line"><span class="comment"># ax:设置作图的坐标轴，一般画多个子图时需要修改不同的子图的该值</span></span><br><span class="line">sns.heatmap(corr, vmax=<span class="number">1</span>, vmin=<span class="number">0</span>, cmap=<span class="string">&#x27;RdBu_r&#x27;</span>, annot=<span class="literal">True</span>, fmt=<span class="string">&#x27;.3f&#x27;</span>,</span><br><span class="line">            annot_kws=&#123;<span class="string">&#x27;size&#x27;</span>: <span class="number">9</span>, <span class="string">&#x27;weight&#x27;</span>: <span class="string">&#x27;bold&#x27;</span>, <span class="string">&#x27;color&#x27;</span>: <span class="string">&#x27;white&#x27;</span>&#125;, cbar=<span class="literal">True</span>,</span><br><span class="line">            xticklabels=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>], yticklabels=[<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;d&#x27;</span>, <span class="string">&#x27;e&#x27;</span>], square=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># sns.heatmap(corr, vmax=1, vmin=0, cmap=&#x27;RdBu_r&#x27;, annot=True, fmt=&#x27;.3f&#x27;, mask=mask,</span></span><br><span class="line"><span class="comment">#             annot_kws=&#123;&#x27;size&#x27;: 9, &#x27;weight&#x27;: &#x27;bold&#x27;, &#x27;color&#x27;: &#x27;white&#x27;&#125;, cbar=True,</span></span><br><span class="line"><span class="comment">#             xticklabels=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;], yticklabels=[&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;], square=True)</span></span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>效果图</p><img src="/post/data_analysis/7.jpg" class title="This is an example image"><h3 id="subplot"><a href="#subplot" class="headerlink" title="subplot"></a>subplot</h3><p>有些时候, 我们希望把一组数据分析图表放在一起进行比较,这时候matplotlib 中提供的subplot就可以解决这个问题</p><h4 id="subplot函数的参数"><a href="#subplot函数的参数" class="headerlink" title="subplot函数的参数"></a>subplot函数的参数</h4><p>matplotlib下, 一个 Figure 对象可以包含多个子图(Axes), 可以使用 subplot() 快速绘制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">subplot(numRows,numCols,plotNum)</span><br><span class="line"><span class="comment"># 图表将整个绘图区域分成numRows行和numCols列</span></span><br><span class="line"><span class="comment"># 按从左到右，从上到下的顺序对每个子区域进行编号，左上的子区域编号为1</span></span><br><span class="line"><span class="comment"># plotNum参数指定创建的axes对象所在的区域</span></span><br></pre></td></tr></table></figure><p>实例代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line"></span><br><span class="line"><span class="comment"># 取消警告的输出</span></span><br><span class="line">warnings.filterwarnings(<span class="string">&quot;ignore&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;Microsoft YaHei&#x27;</span>]</span><br><span class="line">plt.rcParams[<span class="string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">plt.figure()  <span class="comment"># 创建一个Figure图表对象</span></span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, facecolor=<span class="string">&#x27;#B0C4DE&#x27;</span>)  <span class="comment"># facecolor设置背景颜色</span></span><br><span class="line">seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>]</span><br><span class="line">data = np.random.randint(<span class="number">50</span>, size=<span class="number">10</span>)</span><br><span class="line">plt.plot(seq, data, marker=<span class="string">&#x27;o&#x27;</span>, linewidth=<span class="number">1</span>, linestyle=<span class="string">&#x27;:&#x27;</span>, color=<span class="string">&#x27;#6562FF&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, facecolor=<span class="string">&#x27;#B0C4DE&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> [<span class="string">&#x27;red&#x27;</span>, <span class="string">&#x27;green&#x27;</span>, <span class="string">&#x27;blue&#x27;</span>]:</span><br><span class="line">    x, y = np.random.randn(<span class="number">2</span>, <span class="number">500</span>)</span><br><span class="line">    plt.scatter(x, y, c=color, label=color, alpha=<span class="number">0.3</span>)</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>, facecolor=<span class="string">&#x27;white&#x27;</span>)</span><br><span class="line">Cities = [<span class="string">&#x27;北京&#x27;</span>, <span class="string">&#x27;上海&#x27;</span>, <span class="string">&#x27;香港&#x27;</span>, <span class="string">&#x27;深圳&#x27;</span>, <span class="string">&#x27;广州&#x27;</span>]</span><br><span class="line">Counts2016 = [<span class="number">15600</span>, <span class="number">12700</span>, <span class="number">11300</span>, <span class="number">4270</span>, <span class="number">3820</span>]</span><br><span class="line">Counts2017 = [<span class="number">17400</span>, <span class="number">14800</span>, <span class="number">12000</span>, <span class="number">5200</span>, <span class="number">4020</span>]</span><br><span class="line">bar_width = <span class="number">0.4</span></span><br><span class="line">plt.bar(x=np.arange(<span class="built_in">len</span>(Cities)), height=Counts2016, label=<span class="string">&#x27;2016&#x27;</span>, color=<span class="string">&#x27;steelblue&#x27;</span>, width=bar_width)</span><br><span class="line">plt.bar(x=np.arange(<span class="built_in">len</span>(Cities)) + bar_width, height=Counts2017, label=<span class="string">&#x27;2017&#x27;</span>, color=<span class="string">&#x27;indianred&#x27;</span>, width=bar_width)</span><br><span class="line"><span class="comment"># 添加x轴刻度标签（向右偏移0.225）</span></span><br><span class="line">plt.xticks(np.arange(<span class="number">5</span>) + <span class="number">0.2</span>, Cities)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;亿万资产家庭数&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(Counts2016):</span><br><span class="line">    plt.text(x, y + <span class="number">200</span>, <span class="string">&quot;%s&quot;</span> % <span class="built_in">round</span>(y, <span class="number">1</span>), ha=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> x, y <span class="keyword">in</span> <span class="built_in">enumerate</span>(Counts2017):</span><br><span class="line">    plt.text(x + bar_width, y + <span class="number">200</span>, <span class="string">&quot;%s&quot;</span> % <span class="built_in">round</span>(y, <span class="number">1</span>), ha=<span class="string">&#x27;center&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.savefig(<span class="string">&quot;test.jpg&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="/post/data_analysis/11.jpg" class title="This is an example image"><h2 id="绘制图表网站"><a href="#绘制图表网站" class="headerlink" title="绘制图表网站"></a>绘制图表网站</h2><p>图表秀：<a href="http://www.tubiaoxiu.com/">http://www.tubiaoxiu.com/</a></p><blockquote><p>参考文章</p></blockquote><p><a href="https://www.jb51.net/article/252383.htm">https://www.jb51.net/article/252383.htm</a></p><p><a href="https://blog.csdn.net/weixin_48615832/article/details/108028198">https://blog.csdn.net/weixin_48615832/article/details/108028198</a></p><p><a href="https://blog.csdn.net/chumingqian/article/details/126063755">https://blog.csdn.net/chumingqian/article/details/126063755</a></p><p><a href="https://blog.csdn.net/weixin_39541558/article/details/79813936">https://blog.csdn.net/weixin_39541558/article/details/79813936</a></p>]]></content>
      
      
      <categories>
          
          <category> 数模学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分和前缀和</title>
      <link href="/post/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C.html"/>
      <url>/post/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>由于昨天学校OJ平台的一次训练赛中出现了一个前缀和差分的题目，本蒟蒻不太会T_T,所以打算系统学习一下前缀和差分的知识点。在文章的最后笔者也会放上那道题的题目以及AC代码。</p><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><hr><h3 id="一维前缀和"><a href="#一维前缀和" class="headerlink" title="一维前缀和"></a>一维前缀和</h3><p>前缀和可以简单的理解为某个数组中前n项的和，是一种重要的预处理方式，能大大降低查询的时间复杂度。而一维的前缀和比较简单就不做过多的赘述，直接通过一个例子来了解：</p><blockquote><p>给定一个n个元素的数组，要求计算出q次查询中给定的区间的元素的和</p></blockquote><p>对于这个例子可能刚开始最简单的想法就是遍历每次查询的区间求和，但是这种做法在数组元素、查询次数足够多的情况下其时间复杂度就会很高，因此就要用到前缀和的思想。</p><p>首先先定义一个数组sum[N]，sum[i]表示的是数组索引为0 - i的元素的和，然后假设查询的区间为[L , R]那么该区间和就为sum[R]-sum[L-1]（若L==0则区间和为sum[R]）</p><blockquote><p>sum[i]的值</p></blockquote><p>当i为0时，sum[i]=arr[0]；当i大于0时，sum[i]=sum[i-1]+arr[i]。</p><p>下面是演示代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> arr[N], sum[N], n, q, l, r;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">sum[<span class="number">0</span>] = arr[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + arr[i];</span><br><span class="line">cin &gt;&gt; q;</span><br><span class="line"><span class="keyword">while</span> (q--)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line"><span class="keyword">if</span> (l == <span class="number">0</span>) cout &lt;&lt; sum[r] &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span> cout &lt;&lt; sum[r] - sum[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><img src="/post/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/1.png" class title="This is an example image"><h3 id="二维前缀和"><a href="#二维前缀和" class="headerlink" title="二维前缀和"></a>二维前缀和</h3><p>对于二维前缀和，其实就是类似求存储在某个二维数组中某个矩阵方块内的数组元素的和，下面以一个二维数组的例子来讲解</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>同样先定义一个二维数组sum，sum[ i ] [ j ]的意义为以(0,0)为左上角，(i , j)为右下角构成的矩阵所包含的元素的和（以例子中的二维数组为例，sum[1] [2]就是元素1、5、6、9、6、7元素的和）；那么假设所要查询的矩阵是以(x<sub>1</sub>,y<sub>1</sub>)、(x<sub>2</sub>,y<sub>2</sub>)分别为左上角的点和右下角的点构成的，设查询的结果为sum{x<sub>1</sub>,y<sub>1</sub>}{x<sub>2</sub>,y<sub>2</sub>}，以下图为例来说，sum{x<sub>1</sub>,y<sub>1</sub>}{x<sub>2</sub>,y<sub>2</sub>}的结果就是sum[ x<sub>2</sub> ] [ y<sub>2</sub> ]的值减去蓝色框内的再减去红色框内的最后加上绿色框内的重合部分即可，用式子来表示即为（下面式子是所查询的矩阵不包含第一行和第一列的情况，若包含同样的利用方块相减的思路）：</p><p>sum[x<sub>2</sub>] [y<sub>2</sub>] - sum[x<sub>2</sub>] [y<sub>1</sub> - 1] - sum[x<sub>1</sub> - 1] [y<sub>2</sub>] + sum[x<sub>1</sub> - 1] [y<sub>1</sub> - 1]</p><img src="/post/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/2.png" class title="This is an example image"><blockquote><p>sum[ i ] [ j ]的值</p></blockquote><ul><li>当i==0且j==0时，sum[ i ] [ j ]=arr[0] [0]</li><li>当i==0且j != 0时，sum[ i ] [ j ]=sum[ i ] [ j-1 ] + arr[ i ] [ j ]</li><li>当i != 0且j==0时，sum[ i ] [ j ]=sum[ i-1 ] [ j ] + arr[ i ] [ j ]</li><li>当i != 0 且j != 0时，sum[ i ] [ j ]=sum[ i ] [ j-1 ]+sum[ i-1 ] [ j ]-sum[ i-1 ] [ j-1 ]+arr[ i ] [ j ]</li></ul><p>下面是演示代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">3</span>, m = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> arr[n][m] = &#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;,</span><br><span class="line">&#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> sum[n][m];</span><br><span class="line"><span class="comment">//sum二维数组的预处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sum[<span class="number">0</span>][<span class="number">0</span>] = arr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="comment">//处理第一列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) sum[i][<span class="number">0</span>] = sum[i - <span class="number">1</span>][<span class="number">0</span>] + arr[i][<span class="number">0</span>];</span><br><span class="line"><span class="comment">//处理第一行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) sum[<span class="number">0</span>][i] = sum[<span class="number">0</span>][i - <span class="number">1</span>] + arr[<span class="number">0</span>][i];</span><br><span class="line"><span class="comment">//处理非第一行且非第一列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; ++j)</span><br><span class="line">sum[i][j] = sum[i][j - <span class="number">1</span>] + sum[i - <span class="number">1</span>][j] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + arr[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//得到所查询矩阵的元素和</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">get_sum</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!x1 &amp;&amp; !y1) <span class="keyword">return</span> sum[x2][y2];</span><br><span class="line"><span class="keyword">if</span> (!x1) <span class="keyword">return</span> sum[x2][y2] - sum[x2][y1 - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (!y1) <span class="keyword">return</span> sum[x2][y2] - sum[x1 - <span class="number">1</span>][y2];</span><br><span class="line"><span class="keyword">return</span> sum[x2][y2] - sum[x2][y1 - <span class="number">1</span>] - sum[x1 - <span class="number">1</span>][y2] + sum[x1 - <span class="number">1</span>][y1 - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">pre_sum</span>();</span><br><span class="line"><span class="comment">//（1，1）和（2，2）构成的矩阵</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">get_sum</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>) &lt;&lt; endl;<span class="comment">//18</span></span><br><span class="line"><span class="comment">//（0，1）和（1，3）构成的矩阵</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">get_sum</span>(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>) &lt;&lt; endl;<span class="comment">//35</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><hr><h3 id="一维差分"><a href="#一维差分" class="headerlink" title="一维差分"></a>一维差分</h3><p>差分是一种和前缀和相对的策略，可以当作是求和的逆运算。它可以维护多次对序列的一个区间加上一个数，并在最后询问改变后的序列的数。下面以我们学校OJ平台的一道差分模板题来讲述：</p><img src="/post/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/3.png" class title="This is an example image"><p>对于这道题如果直接就是每次遍历区间再进行加数的处理，那时间复杂度是O(mn)看了一下m、n最大可以达到1e5，那最后的结果肯定会TLE（因为那时我刚开始就是那样做的hhh，那次也是第一次接触差分）</p><p>言归正传，用差分的方法来做这道题，首先定义一个数组arr[N]来存储原始数据，然后还要定义一个数组d[N]。对于数组d的元素，当i==0时，d[i]=arr[i]；当i&gt;=0时，d[i]=arr[i]-arr[i-1]；我们可以发现原数组arr其实是数组d的前缀和，这也是为什么说差分是一种和前缀和相对的策略；当想使区间[L,R]上的数都加上x时，只需要d[L]+=x,d[R+1]-=x即可。因为当d[L]+=x后，对于数组d的更新后的前缀和数组即arr来说，索引&gt;=L的元素都会加上x，而d[R+1]-=x的作用是使得arr数组中索引为&gt;=(R+1)的元素都减去x，那么最后的结果就是区间[L,R]的元素都加上x，这样执行区间修改操作的时间复杂度就只有O(m)</p><p>下面是题目的AC代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100005</span>;</span><br><span class="line">ll n, m, l, r, x, arr[N], d[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; arr[i];</span><br><span class="line">d[i] = arr[i] - arr[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (ll i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;</span><br><span class="line">d[l] += x;</span><br><span class="line">d[r + <span class="number">1</span>] -= x;<span class="comment">//一般会把数组开大一点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//更新后的arr数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">arr[i] = arr[i - <span class="number">1</span>] + d[i];</span><br><span class="line">cout &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二维差分"><a href="#二维差分" class="headerlink" title="二维差分"></a>二维差分</h3><p>对于二维差分同样使用二维前缀和的那个例子中的数组来讲述：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> arr[<span class="number">3</span>][<span class="number">4</span>]=&#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;,</span><br><span class="line">    &#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>&#125;,</span><br><span class="line">    &#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用二维差分对该数组某个以(x<sub>1</sub>,y<sub>1</sub>)、(x<sub>2</sub>,y<sub>2</sub>)分别为左上角的点和右下角的点构成的矩阵内的元素进行修改，首先定义二维的差分数组d来记录修改（d初始化为0），假设对以(x<sub>1</sub>,y<sub>1</sub>)、(x<sub>2</sub>,y<sub>2</sub>)分别为左上角的点和右下角的点构成的矩阵内的元素同时加上value，那么可以使d[x<sub>1</sub>] [y<sub>1</sub>]+=value，d[x<sub>2</sub>+1] [y<sub>1</sub>]-=value，d[x<sub>1</sub>] [y<sub>2</sub>+1]-=value，d[x<sub>2</sub>+1] [y<sub>2</sub>+1]+=value，然后对二维数组d进行二维前缀和的处理即可得到原数组对应位置元素的改变值，执行d[x<sub>2</sub>+1] [y<sub>2</sub>+1]+=value操作是因为进行前缀和处理时以(x<sub>2</sub>+1,y<sub>2</sub>+1)为左上角顶点的矩阵内的元素被多减去了一个value；结果如下图所示：</p><img src="/post/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/4.png" class title="This is an example image"><p>代码演示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> n = <span class="number">3</span>, m = <span class="number">4</span>;</span><br><span class="line"><span class="type">int</span> arr[n][m] = &#123;</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>&#125;,</span><br><span class="line">&#123;<span class="number">9</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">3</span>&#125;,</span><br><span class="line">&#123;<span class="number">5</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> d[<span class="number">5</span>][<span class="number">5</span>], sum[<span class="number">5</span>][<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">d[x1][y1] += val;</span><br><span class="line">d[x2 + <span class="number">1</span>][y1] -= val;</span><br><span class="line">d[x1][y2 + <span class="number">1</span>] -= val;</span><br><span class="line">d[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sum二维数组的预处理</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pre_sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sum[<span class="number">0</span>][<span class="number">0</span>] = d[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line"><span class="comment">//处理第一列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i) sum[i][<span class="number">0</span>] = sum[i - <span class="number">1</span>][<span class="number">0</span>] + d[i][<span class="number">0</span>];</span><br><span class="line"><span class="comment">//处理第一行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; m; ++i) sum[<span class="number">0</span>][i] = sum[<span class="number">0</span>][i - <span class="number">1</span>] + d[<span class="number">0</span>][i];</span><br><span class="line"><span class="comment">//处理非第一行且非第一列</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt; m; ++j)</span><br><span class="line">sum[i][j] = sum[i][j - <span class="number">1</span>] + sum[i - <span class="number">1</span>][j] - sum[i - <span class="number">1</span>][j - <span class="number">1</span>] + d[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将sum数组对应的改变映射会arr数组</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">arr[i][j] += sum[i][j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">add</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>);<span class="comment">//(0,0),(2,1)形成的矩阵内的元素加3</span></span><br><span class="line"><span class="built_in">add</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">-1</span>);<span class="comment">//(1,1),(2,2)形成的矩阵内的元素减1</span></span><br><span class="line"><span class="built_in">pre_sum</span>();</span><br><span class="line"><span class="built_in">result</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; m; ++j)</span><br><span class="line">cout &lt;&lt; arr[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="OJ例题"><a href="#OJ例题" class="headerlink" title="OJ例题"></a>OJ例题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><img src="/post/%E5%B7%AE%E5%88%86%E5%92%8C%E5%89%8D%E7%BC%80%E5%92%8C/5.png" class title="This is an example image"><h3 id="AC代码"><a href="#AC代码" class="headerlink" title="AC代码"></a>AC代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e4</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n, m, q, flag;</span><br><span class="line"><span class="type">int</span> d1[N], d2[N], d[N], sum[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; m; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line">cin &gt;&gt; flag &gt;&gt; l &gt;&gt; r;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line">d1[l] += <span class="number">1</span>;</span><br><span class="line">d1[r + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">d2[l] += <span class="number">1</span>;</span><br><span class="line">d2[r + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">d1[i] += d1[i - <span class="number">1</span>];</span><br><span class="line">d2[i] += d2[i - <span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span> (d2[i] &gt;= <span class="number">1</span>)</span><br><span class="line">d[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (d1[i] &gt;= <span class="number">1</span>)</span><br><span class="line">d[i] = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">d[i] = <span class="number">1</span>;</span><br><span class="line">sum[i] = sum[i - <span class="number">1</span>] + d[i];</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; q;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; q; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> l, r;</span><br><span class="line">cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">cout &lt;&lt; sum[r] - sum[l - <span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>对于前缀和和差分还有其他类型以后待更新……</p>]]></content>
      
      
      <categories>
          
          <category> 算法范畴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扩展欧几里得算法(exgcd)</title>
      <link href="/post/exgcd.html"/>
      <url>/post/exgcd.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前置知识-不涉及证明"><a href="#前置知识-不涉及证明" class="headerlink" title="前置知识(不涉及证明)"></a>前置知识(不涉及证明)</h2><hr><h3 id="欧几里得算法"><a href="#欧几里得算法" class="headerlink" title="欧几里得算法"></a>欧几里得算法</h3><p>欧几里得算法又称为辗转相除法，用于计算两个非负整数的最大公约数。对于非负整数a，b，当b不为0时，其最大公约数与非负整数b，a%b的最大公约数相同；当b为0时，a与b的最大公约数为a</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">gcd</span><span class="params">(ll a,ll b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="裴蜀定理-贝祖定理"><a href="#裴蜀定理-贝祖定理" class="headerlink" title="裴蜀定理/贝祖定理"></a>裴蜀定理/贝祖定理</h3><p>对于任意整数a、b和它们的最大公约数d，关于未知数x和y的线性不定方程（称为<strong>裴蜀等式</strong>）：若a，b是整数，且gcd(a,b)=d，那么对于任意的整数x，y而言ax+by都一定是d的倍数，特别地一定存在整数x，y使得ax+by=d成立</p><blockquote><p>重要推论：a，b互质的充分必要条件是存在整数x，y使得ax+by=1</p></blockquote><h2 id="扩展欧几里得算法（exgcd）"><a href="#扩展欧几里得算法（exgcd）" class="headerlink" title="扩展欧几里得算法（exgcd）"></a>扩展欧几里得算法（exgcd）</h2><hr><ul><li><p>扩展欧几里德算法是用来在已知a，b 求解一组x，y ，使它们满足裴蜀（贝祖）等式：ax + by = gcd ⁡(a , b) = d</p></li><li><p>证明过程：</p><ul><li>当b = 0时，ax + by = a因此x = 1，y = 0</li><li>当b != 0时，经过以下推导       </li></ul><img src="/post/exgcd/1.png" class title="This is an example image"></li></ul><p>​        因此可以利用递归算法每次先求出下一层的x’和y’然后利用上述公式回代</p><ul><li>递归方式模板</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">exgcd</span><span class="params">(ll a, ll b, ll &amp;x, ll &amp;y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!b) &#123;</span><br><span class="line">    x = <span class="number">1</span>;</span><br><span class="line">    y = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  ll d = <span class="built_in">exgcd</span>(b, a % b, x, y);</span><br><span class="line">  ll t = x;</span><br><span class="line">  x = y;</span><br><span class="line">  y = t - (a / b) * y;</span><br><span class="line">  <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><ol><li><p>用于求解ax + by = gcd(a , b)的解（即上述情况）</p></li><li><p>用于求解ax + by = c的解</p><ul><li><p>当c % gcd(a , b) != 0时，无解（依据裴蜀定理）</p></li><li><p>当c % gcd(a , b) = 0时，先利用exgcd求出ax + by = gcd(a , b)的解x<sub>0</sub>、y<sub>0</sub>，则可得到特解x’ = x<sub>0</sub> * c / gcd(a , b)，y’ = y<sub>0</sub> * c / gcd(a , b)，而通解 = 特解 + 齐次解（ax + by = 0的解），故通解为x = x’ + k * b / gcd(a , b)，y = y’ + k * a / gcd(a,b) (k为整数)</p></li></ul></li><li><p>求解一次同余方程:</p><img src="/post/exgcd/2.png" class title="This is an example image"><p>上述方程价于</p><img src="/post/exgcd/3.png" class title="This is an example image"><p>再利用应用2中的方法求解即可</p></li><li><p>求解ax + by = c的最小正整数解x模板</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LL <span class="title">exgcd</span><span class="params">(LL a,LL b,LL &amp;x,LL &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=<span class="number">1</span>;</span><br><span class="line">        y=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    LL ans=<span class="built_in">e_gcd</span>(b,a%b,x,y);</span><br><span class="line">    LL temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp-a/b*y;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">LL <span class="title">cal</span><span class="params">(LL a,LL b,LL c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LL x,y;</span><br><span class="line">    LL gcd=<span class="built_in">exgcd</span>(a,b,x,y);</span><br><span class="line">    <span class="keyword">if</span>(c%gcd!=<span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    x*=c/gcd;<span class="comment">//转化为a*x+b*y=c的解</span></span><br><span class="line">    b/=gcd;<span class="comment">//约去c后原来b就变为了b/gcd;</span></span><br><span class="line">    <span class="keyword">if</span>(b&lt;<span class="number">0</span>) b=-b;<span class="comment">//如果b为负数就去绝对值</span></span><br><span class="line">    LL ans=x%b;</span><br><span class="line">    <span class="keyword">if</span>(ans&lt;=<span class="number">0</span>) ans+=b;<span class="comment">//求最小正整数解</span></span><br><span class="line">    <span class="keyword">return</span> ans;<span class="comment">//返回的就是最小正整数解</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>参考文章</p><p><a href="http://t.csdn.cn/SAzQN">http://t.csdn.cn/SAzQN</a></p><p><a href="http://t.csdn.cn/ZhE6r">http://t.csdn.cn/ZhE6r</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 算法范畴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>【C++学习】STL基础</title>
      <link href="/post/C++%E4%B9%8BSTL.html"/>
      <url>/post/C++%E4%B9%8BSTL.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1.基本概念"></a>1.基本概念</h2><h3 id="1-1-简要介绍"><a href="#1-1-简要介绍" class="headerlink" title="1.1 简要介绍"></a>1.1 简要介绍</h3><p>STL（Standard Template Library，标准模板库）广义上分为三类：algorithm（算法）、container（容器）和iterator（迭代器），几乎所有的代码都采用了模板类和模板函数的方式，提供了更好的代码重用机会</p><h3 id="1-2-优点"><a href="#1-2-优点" class="headerlink" title="1.2 优点"></a>1.2 优点</h3><ul><li>高可重用性</li><li>高性能</li><li>高移植性</li><li>跨平台</li></ul><h2 id="2-容器"><a href="#2-容器" class="headerlink" title="2.容器"></a>2.容器</h2><h3 id="2-1-容器的分类"><a href="#2-1-容器的分类" class="headerlink" title="2.1 容器的分类"></a>2.1 容器的分类</h3><ol><li><strong>序列式容器</strong><ul><li>每个元素都有固定位置——取决于插入时机和地点，和元素值无关</li><li>vector、deque、list、stack、queue</li></ul></li><li><strong>关联式容器</strong><ul><li>元素位置取决于特定的排序准则，和插入顺序无关</li><li>set、multiset、map、multimap</li></ul></li></ol><h3 id="2-2-vector"><a href="#2-2-vector" class="headerlink" title="2.2 vector"></a>2.2 vector</h3><h4 id="2-2-1-vector容器简介"><a href="#2-2-1-vector容器简介" class="headerlink" title="2.2.1 vector容器简介"></a>2.2.1 vector容器简介</h4><ul><li>vector是将元素置于一个动态数组中加以管理的容器</li><li>vector可以随机存取元素</li><li>vector尾部添加或移出元素非常快速，但是在中部或者头部插入或移出元素比较费时</li></ul><h4 id="2-2-2-vector对象的默认构造"><a href="#2-2-2-vector对象的默认构造" class="headerlink" title="2.2.2 vector对象的默认构造"></a>2.2.2 vector对象的默认构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; VecInt;<span class="comment">//一个存放int类型数据的vector容器</span></span><br><span class="line">vector&lt;<span class="type">double</span>&gt; VecDou;<span class="comment">//一个存放double类型数据的vector容器</span></span><br><span class="line">vector&lt;string&gt; VecStr;<span class="comment">//一个存放string类型数据的vector容器</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CA</span>&#123;&#125;;</span><br><span class="line">vector&lt;CA*&gt; VecCA;<span class="comment">//一个存放CA对象指针的vector容器</span></span><br><span class="line">vector&lt;CA&gt; VecCA;<span class="comment">//一个存放CA对象的vector容器</span></span><br></pre></td></tr></table></figure><h4 id="2-2-3-vector对象的带参数构造"><a href="#2-2-3-vector对象的带参数构造" class="headerlink" title="2.2.3 vector对象的带参数构造"></a>2.2.3 vector对象的带参数构造</h4><ul><li>vector(beg,end);//构造函数将[beg,end)区间中的元素拷贝给本身（左闭右开区间）</li><li>vector(n,elem);//构造函数将n个elem拷贝给本身</li><li>vector(const vector &amp;vec);//拷贝构造函数</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v1</span><span class="params">(arr, arr + <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v2</span><span class="params">(<span class="number">10</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v3</span><span class="params">(v1)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">cout &lt;&lt; v3[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 2 3 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-4-vector对象的赋值"><a href="#2-2-4-vector对象的赋值" class="headerlink" title="2.2.4 vector对象的赋值"></a>2.2.4 vector对象的赋值</h4><ul><li>vector.assign(beg,end);//将[beg,end)区间中的数据拷贝赋值给本身（左闭右开区间）</li><li>vector.assign(n,elem);//将n个elem拷贝赋值给本身</li><li>vector&amp; operator=(const vector &amp;vec);//重载等号操作符</li><li>vector.swap(vec);//将vec与本身的元素互换</li></ul><blockquote><p>注：assign方法会将原来vector对象的元素清空再拷贝</p></blockquote><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1, v2, v3;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v1.<span class="built_in">assign</span>(arr, arr + <span class="number">5</span>);</span><br><span class="line">v2.<span class="built_in">assign</span>(<span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line">v3 = v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 2 3 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v2.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//10 10 10</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">swap</span>(v2);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//10 10 10</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v2.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v2[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 2 3 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-5-vector的大小"><a href="#2-2-5-vector的大小" class="headerlink" title="2.2.5 vector的大小"></a>2.2.5 vector的大小</h4><ul><li>vector.size();//返回容器中元素的个数</li><li>vector.empty();//判断vector对象是否为空</li><li>vector.resize(num);//重新制定容器的长度为num：若容器变长则以默认值0填充新位置；若容器变短则末尾超出容器长度的元素将被删除</li><li>vector.resize(num,elem);//重新制定容器的长度为num：若容器变长则以elem值填充新位置；若容器变短则末尾超出容器长度的元素将被删除</li></ul><h4 id="2-2-6-vector元素的访问方式"><a href="#2-2-6-vector元素的访问方式" class="headerlink" title="2.2.6 vector元素的访问方式"></a>2.2.6 vector元素的访问方式</h4><ul><li>vector[index]：返回索引index所指的数据（若下标越界<strong>可能</strong>会导致程序异常终止）</li><li>vector.at(index)：返回索引index所指的数据（若index越界则抛出out_of_range异常）</li></ul><h4 id="2-2-7-vector的插入删除"><a href="#2-2-7-vector的插入删除" class="headerlink" title="2.2.7 vector的插入删除"></a>2.2.7 vector的插入删除</h4><ul><li>vector.insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置</li><li>vector.insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值</li><li>vector.insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值</li><li>vector.push_back(elem);//在vector对象末尾插入元素elem</li><li>vector.pop_back();//把vector对象末尾元素删除</li><li>vector.clear();//清空vector容器中元素</li><li>vector.erase(pos);//删除在pos位置的元素，返回新数据的位置</li><li>vector.erase(beg,end);//删除[beg,end)区间内的元素</li></ul><blockquote><p>注：pos为vector::iterator</p></blockquote><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v1.<span class="built_in">assign</span>(arr, arr + <span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 2 3</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 2 3 10</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">pop_back</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 2 3</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 10 2 3</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>() + <span class="number">1</span>, <span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 10 10 10 10 2 3</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">insert</span>(v1.<span class="built_in">begin</span>() + <span class="number">1</span>, arr + <span class="number">3</span>, arr + <span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 4 5 10 10 10 10 2 3</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">erase</span>(v1.<span class="built_in">begin</span>() + <span class="number">3</span>, v1.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">v1.<span class="built_in">clear</span>();</span><br><span class="line">cout &lt;&lt; v1.<span class="built_in">size</span>() &lt;&lt; endl;<span class="comment">//0</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-8-vector容器的iterator类型"><a href="#2-2-8-vector容器的iterator类型" class="headerlink" title="2.2.8 vector容器的iterator类型"></a>2.2.8 vector容器的iterator类型</h4><ul><li>vector&lt; int &gt;::iterator iter;//变量名为iter，类型为正向迭代器，反向迭代器改为reverse_iterator</li><li>vector容器的迭代器属于随机访问迭代器：迭代器一次可以移动多个位置</li><li>成员函数：<ul><li>begin()：返回指向容器中第一个元素的正向迭代器</li><li>end()：返回指向容器中最后一个元素之后一个位置的正向迭代器</li><li>rbegin()：返回指向最后一个元素的反向迭代器</li><li>rend()：返回指向第一个元素前一个位置的反向迭代器</li><li>cbegin()：和begin()功能类似，只不过其返回的迭代器类型是常量正向迭代器，不能用于修改元素</li><li>cend()：和end()功能类似，只不过其返回的迭代器类型是常量正向迭代器，不能用于修改元素</li><li>crbegin()：和rbegin()功能类似，只不过其返回的迭代器类型是常量反向迭代器，不能用于修改元素</li><li>crend()：和rend()功能类似，只不过其返回的迭代器类型是常量反向迭代器，不能用于修改元素</li></ul></li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> arr[<span class="number">5</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">v1.<span class="built_in">push_back</span>(i);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator idx = v1.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">for</span> (; idx != v1.<span class="built_in">end</span>(); ++idx)</span><br><span class="line">cout &lt;&lt; *idx &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//5 6 7 8 9</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = v1.<span class="built_in">rbegin</span>(); it!= v1.<span class="built_in">rend</span>(); ++it)</span><br><span class="line"><span class="comment">//it依旧是递增</span></span><br><span class="line">cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//9 8 7 6 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-9-vector容器的迭代器失效"><a href="#2-2-9-vector容器的迭代器失效" class="headerlink" title="2.2.9 vector容器的迭代器失效"></a>2.2.9 vector容器的迭代器失效</h4><ol><li>插入元素导致迭代器失效</li></ol><blockquote><p>问题演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = v1.<span class="built_in">begin</span>() + <span class="number">3</span>;</span><br><span class="line">v1.<span class="built_in">insert</span>(it, <span class="number">8</span>);</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;<span class="comment">//在VS中运行无结果，返回错误代码，视不同编译器</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原因</p></blockquote><p>因为在insert时，vector可能需要扩容，而扩容的本质是new一块新的空间，再将数据迁移过去；而在插入后若vector扩容，则原有的数据被释放，指向原有数据的迭代器就成了野指针，所以迭代器失效了 </p><blockquote><p>解决</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">1</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">2</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">3</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">4</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it = v1.<span class="built_in">begin</span>() + <span class="number">3</span>;</span><br><span class="line">it = v1.<span class="built_in">insert</span>(it, <span class="number">8</span>);<span class="comment">//insert会返回一个新的有效的迭代器</span></span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;<span class="comment">//8</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>删除元素导致迭代器失效</li></ol><blockquote><p>问题演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = v1.<span class="built_in">begin</span>(); i != v1.<span class="built_in">end</span>(); ++i)</span><br><span class="line"><span class="keyword">if</span> (*i == <span class="number">3</span>)</span><br><span class="line">v1.<span class="built_in">erase</span>(i);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//VS编译器无输出，返回错误代码</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>原因</p></blockquote><p>对于序列式容器（如vector，deque），序列式容器就是数组式容器，删除当前元素的iterator会使得后面所有元素的iterator都失效。这是因为vector，deque使用了连续分配的内存，删除一个元素导致后面所有的元素会向前移动一个位置，所以不能使用erase(i++)的方式。</p><blockquote><p>解决</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span> (it = v1.<span class="built_in">begin</span>(); it != v1.<span class="built_in">end</span>();)</span><br><span class="line"><span class="keyword">if</span> (*it == <span class="number">3</span>)</span><br><span class="line">it = v1.<span class="built_in">erase</span>(it);<span class="comment">//erase返回删除后的一个有效的迭代器</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">it++;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; v1.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//1 2 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-deque"><a href="#2-3-deque" class="headerlink" title="2.3 deque"></a>2.3 deque</h3><h4 id="2-3-1-deque容器简介"><a href="#2-3-1-deque容器简介" class="headerlink" title="2.3.1 deque容器简介"></a>2.3.1 deque容器简介</h4><ul><li>deque是“double-ended queue”的缩写</li><li>deque是双端数组（可以向两端扩容）而vector是单端的</li><li>deque在接口上和vector非常相似，在许多操作的地方可以直接替换</li><li>deque可以随机存取元素（支持索引值直接存取，用[ ]操作符或at( )方法）</li><li>deque头部和尾部添加或移出元素都非常快速，但是在中部安插元素或移出元素比较费时</li><li>deque并非连续空间存储，它是分段连续的</li><li>使用需包含头文件&lt; deque &gt;</li></ul><h4 id="2-3-2-deque容器的操作"><a href="#2-3-2-deque容器的操作" class="headerlink" title="2.3.2 deque容器的操作"></a>2.3.2 deque容器的操作</h4><ul><li>deque与vector在操作上几乎一样，deque多两个函数：<ul><li>deque.push_front(elem);//在容器头部插入一个数据</li><li>deque.pop_front();//删除容器第一个数据</li></ul></li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">deque&lt;<span class="type">int</span>&gt; deq = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">deq.<span class="built_in">push_front</span>(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; deq.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; deq[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//10 1 2 3 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">deq.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; deq.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; deq[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 2 3 4 5</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-list"><a href="#2-4-list" class="headerlink" title="2.4 list"></a>2.4 list</h3><h4 id="2-4-1-list容器简介"><a href="#2-4-1-list容器简介" class="headerlink" title="2.4.1 list容器简介"></a>2.4.1 list容器简介</h4><ul><li>list是一个双向链表容器，可以高效进行插入删除元素</li><li>list不可以随机存取元素，所以不支持at(pos)函数与[]操作符</li><li>list的迭代器支持自增、自减运算符，但<strong>不支持一个迭代器加上某个数字</strong></li><li>使用需要包含头文件&lt; list &gt; </li></ul><h4 id="2-4-2-list对象的默认构造"><a href="#2-4-2-list对象的默认构造" class="headerlink" title="2.4.2 list对象的默认构造"></a>2.4.2 list对象的默认构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lstInt;<span class="comment">//定义一个存放int的list容器</span></span><br><span class="line">list&lt;string&gt; lstStr;<span class="comment">//定义一个存放string的list容器</span></span><br></pre></td></tr></table></figure><h4 id="2-4-3-list头尾的添加移除操作"><a href="#2-4-3-list头尾的添加移除操作" class="headerlink" title="2.4.3 list头尾的添加移除操作"></a>2.4.3 list头尾的添加移除操作</h4><ul><li>list.push_back(elem);//在容器尾部加入一个元素</li><li>list.pop_back();//删除容器中最后一个元素</li><li>list.push_front(elem);//在容器开头插入一个元素</li><li>list.pop_front();//从容器开头移除第一个元素</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lst;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt;= <span class="number">10</span>; ++i)</span><br><span class="line">lst.<span class="built_in">push_back</span>(i);</span><br><span class="line">lst.<span class="built_in">push_front</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//100 5 6 7 8 9 10</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">lst.<span class="built_in">pop_back</span>();</span><br><span class="line">lst.<span class="built_in">pop_front</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//5 6 7 8 9</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-4-list数据的存取"><a href="#2-4-4-list数据的存取" class="headerlink" title="2.4.4 list数据的存取"></a>2.4.4 list数据的存取</h4><ul><li>list.front();//返回list容器的第一个结点的值</li><li>list.back();//返回list容器的最后一个结点的值</li></ul><blockquote><p>注：可以通过list.front()=elem对第一个结点的值进行更改为elem；list.back()也同样可以</p></blockquote><h4 id="2-4-5-list与迭代器"><a href="#2-4-5-list与迭代器" class="headerlink" title="2.4.5 list与迭代器"></a>2.4.5 list与迭代器</h4><p>list容器的迭代器是“双向迭代器”：双向迭代器从两个方向读写容器，除了提供前向迭代器的全部操作之外，双向迭代器还提供前置和后置的自减运算</p><ul><li>list.begin();//返回容器中第一个元素的迭代器</li><li>list.end();//返回容器中最后一个元素之后的迭代器</li><li>list.rbegin();//返回容器中倒数第一个元素的迭代器</li><li>list.rend();//返回容器中倒数最后一个元素的后面的迭代器</li></ul><h4 id="2-4-6-list对象的带参数构造"><a href="#2-4-6-list对象的带参数构造" class="headerlink" title="2.4.6 list对象的带参数构造"></a>2.4.6 list对象的带参数构造</h4><ul><li>list(n,elem);//构造函数将n个elem拷贝给本身</li><li>list(beg,end);//构造函数将[beg,end)区间中的元素拷贝给本身</li><li>list(const list&amp; lst);//拷贝构造函数</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst1</span><span class="params">(vec.begin(),vec.begin()+<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst2</span><span class="params">(<span class="number">5</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst3</span><span class="params">(lst2)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst1.<span class="built_in">begin</span>(); i != lst1.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//1 2 3</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst2.<span class="built_in">begin</span>(); i != lst2.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//100 100 100 100 100</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst3.<span class="built_in">begin</span>(); i != lst3.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//100 100 100 100 100</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-7-list对象的赋值"><a href="#2-4-7-list对象的赋值" class="headerlink" title="2.4.7 list对象的赋值"></a>2.4.7 list对象的赋值</h4><ul><li>list.assign(beg,end);//将[beg,end)区间中的数据拷贝赋值给本身（左闭右开区间）</li><li>list.assign(n,elem);//将n个elem拷贝赋值给本身</li><li>list&amp; operator=(const vector &amp;vec);//重载等号操作符</li><li>list.swap(vec);//将vec与本身的元素互换</li></ul><h4 id="2-4-8-list对象的大小"><a href="#2-4-8-list对象的大小" class="headerlink" title="2.4.8 list对象的大小"></a>2.4.8 list对象的大小</h4><ul><li>list.size();//返回容器中元素的个数</li><li>list.empty();//判断vector对象是否为空</li><li>list.resize(num);//重新制定容器的长度为num：若容器变长则以默认值0填充新位置；若容器变短则末尾超出容器长度的元素将被删除</li><li>list.resize(num,elem);//重新制定容器的长度为num：若容器变长则以elem值填充新位置；若容器变短则末尾超出容器长度的元素将被删除</li></ul><h4 id="2-4-9-list容器的插入"><a href="#2-4-9-list容器的插入" class="headerlink" title="2.4.9 list容器的插入"></a>2.4.9 list容器的插入</h4><ul><li>list.insert(pos,elem);//在pos位置插入一个elem元素的拷贝，返回新数据的位置</li><li>list.insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值</li><li>list.insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值</li></ul><blockquote><p>注：list.insert不会使得迭代器失效，因为插入结点后原结点没有释放以及位置没有改变</p></blockquote><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; vec = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span> &#125;;</span><br><span class="line"><span class="function">list&lt;<span class="type">int</span>&gt; <span class="title">lst</span><span class="params">(<span class="number">5</span>,<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it = lst.<span class="built_in">begin</span>();</span><br><span class="line">++it;</span><br><span class="line">lst.<span class="built_in">insert</span>(it, <span class="number">50</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//100 50 100 100 100 100</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;</span><br><span class="line"><span class="comment">//100</span></span><br><span class="line">lst.<span class="built_in">insert</span>(it, <span class="number">3</span>, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//100 50 10 10 10 100 100 100 100</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-10-list容器的删除"><a href="#2-4-10-list容器的删除" class="headerlink" title="2.4.10 list容器的删除"></a>2.4.10 list容器的删除</h4><ul><li>list.clear();//移除容器中的所有元素</li><li>list.erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置</li><li>list.erase(pos);//删除pos位置的数据，返回下一个数据的位置</li><li>list.remove(elem);//删除容器中所有与elem值匹配的元素</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">list&lt;<span class="type">int</span>&gt; lst&#123;<span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span>,<span class="number">56</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">23</span>&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">lst.<span class="built_in">erase</span>(lst.<span class="built_in">begin</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//23 34 45 56 56 3 3 3 3 3 23</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">list&lt;<span class="type">int</span>&gt;::iterator it1, it2;</span><br><span class="line">it1 = it2 = lst.<span class="built_in">begin</span>();</span><br><span class="line">++it1;<span class="comment">//指向34</span></span><br><span class="line">++it2;</span><br><span class="line">++it2;</span><br><span class="line">++it2;<span class="comment">//指向56</span></span><br><span class="line"><span class="comment">//it1接受erase返回的位置</span></span><br><span class="line">it1 = lst.<span class="built_in">erase</span>(it1, it2);</span><br><span class="line">cout &lt;&lt; *it1 &lt;&lt; endl;<span class="comment">//56</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//23 56 56 3 3 3 3 3 23</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">lst.<span class="built_in">remove</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//23 56 56 23</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-11-list容器的反转"><a href="#2-4-11-list容器的反转" class="headerlink" title="2.4.11 list容器的反转"></a>2.4.11 list容器的反转</h4><ul><li>list.reserve();</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst&#123; <span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span> &#125;;</span><br><span class="line">lst.<span class="built_in">reverse</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//56 45 34 23 12</span></span><br></pre></td></tr></table></figure><h4 id="2-4-12-list容器的迭代器失效"><a href="#2-4-12-list容器的迭代器失效" class="headerlink" title="2.4.12 list容器的迭代器失效"></a>2.4.12 list容器的迭代器失效</h4><ul><li>删除结点导致迭代器失效</li></ul><blockquote><p>问题代码</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst&#123; <span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span> &#125;;</span><br><span class="line"><span class="comment">//报错：结点删除后，无法得到删除结点的next元素，重载后的++运算符无法进行</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>(); ++i)</span><br><span class="line"><span class="keyword">if</span> (*i == <span class="number">34</span>)</span><br><span class="line">lst.<span class="built_in">erase</span>(i);</span><br></pre></td></tr></table></figure><blockquote><p>问题解决</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt; lst&#123; <span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = lst.<span class="built_in">begin</span>(); i != lst.<span class="built_in">end</span>();)</span><br><span class="line"><span class="keyword">if</span> (*i == <span class="number">34</span>)</span><br><span class="line">i = lst.<span class="built_in">erase</span>(i);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">++i;</span><br></pre></td></tr></table></figure><h3 id="2-5-stack"><a href="#2-5-stack" class="headerlink" title="2.5 stack"></a>2.5 stack</h3><h4 id="2-5-1-stack容器简介"><a href="#2-5-1-stack容器简介" class="headerlink" title="2.5.1 stack容器简介"></a>2.5.1 stack容器简介</h4><ul><li>stack是堆栈容器，是一种“先进后出”的容器</li><li>stack没有迭代器，因为该数据结构不允许遍历</li><li>使用需包含头文件&lt; stack &gt;</li></ul><h4 id="2-5-2-stack对象的默认构造"><a href="#2-5-2-stack对象的默认构造" class="headerlink" title="2.5.2 stack对象的默认构造"></a>2.5.2 stack对象的默认构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; stkint;<span class="comment">//一个存放int的stack容器</span></span><br><span class="line">stack&lt;<span class="type">float</span>&gt; stkfloat;<span class="comment">//一个存放float的stack容器</span></span><br><span class="line">stack&lt;string&gt; stkstr;<span class="comment">//一个存放string的stack容器</span></span><br></pre></td></tr></table></figure><h4 id="2-5-3-stack插入删除相关接口"><a href="#2-5-3-stack插入删除相关接口" class="headerlink" title="2.5.3 stack插入删除相关接口"></a>2.5.3 stack插入删除相关接口</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stack.<span class="built_in">push</span>(elem);<span class="comment">//往栈顶添加元素</span></span><br><span class="line">stack.<span class="built_in">pop</span>();<span class="comment">//从栈顶移出第一个元素，不返回值</span></span><br><span class="line">stack.<span class="built_in">top</span>();<span class="comment">//访问栈顶元素并返回，可作为表达式的左值</span></span><br><span class="line">stack.<span class="built_in">empty</span>();<span class="comment">//判断stack容器是否为空</span></span><br></pre></td></tr></table></figure><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="type">int</span>&gt; stkint;</span><br><span class="line">stkint.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">stkint.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">stkint.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">stkint.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line"><span class="comment">//7 5 3 1</span></span><br><span class="line"><span class="keyword">while</span> (!stkint.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; stkint.<span class="built_in">top</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">stkint.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-4-stack拷贝构造与赋值"><a href="#2-5-4-stack拷贝构造与赋值" class="headerlink" title="2.5.4 stack拷贝构造与赋值"></a>2.5.4 stack拷贝构造与赋值</h4><ul><li>stack(const stack&amp; stk);//拷贝构造函数</li><li>stack&amp; operator=(const stack&amp; stk);//重载等号操作符</li></ul><h4 id="2-5-6-stack的大小"><a href="#2-5-6-stack的大小" class="headerlink" title="2.5.6 stack的大小"></a>2.5.6 stack的大小</h4><ul><li>stack.empty();//判断堆栈是否为空</li><li>stack.size();//返回堆栈的大小</li></ul><blockquote><p>注：stack没有提供resize方法</p></blockquote><h3 id="2-6-queue"><a href="#2-6-queue" class="headerlink" title="2.6 queue"></a>2.6 queue</h3><h4 id="2-6-1-queue容器简介"><a href="#2-6-1-queue容器简介" class="headerlink" title="2.6.1 queue容器简介"></a>2.6.1 queue容器简介</h4><ul><li>queue是队列容器，是一种“先进先出”的容器</li><li>queue没有迭代器</li><li>使用需包含&lt; queue &gt;头文件</li></ul><h4 id="2-6-2-queue对象的默认构造"><a href="#2-6-2-queue对象的默认构造" class="headerlink" title="2.6.2 queue对象的默认构造"></a>2.6.2 queue对象的默认构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; queint;<span class="comment">//一个存放int数据的queue容器</span></span><br><span class="line">queue&lt;string&gt; questr;<span class="comment">//一个存放string数据的queue容器</span></span><br></pre></td></tr></table></figure><h4 id="2-6-3-queue插入删除相关接口"><a href="#2-6-3-queue插入删除相关接口" class="headerlink" title="2.6.3 queue插入删除相关接口"></a>2.6.3 queue插入删除相关接口</h4><ul><li>queue.push(elem);//往队尾添加元素</li><li>queue.pop();//从队头移除第一个元素</li><li>queue.front();//返回队头元素，可作为表达式的左值</li><li>queue.back();//返回队尾元素，可作为表达式的左值</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q1;</span><br><span class="line">q1.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">q1.<span class="built_in">push</span>(<span class="number">3</span>);</span><br><span class="line">q1.<span class="built_in">push</span>(<span class="number">5</span>);</span><br><span class="line">q1.<span class="built_in">push</span>(<span class="number">7</span>);</span><br><span class="line"><span class="comment">//1 3 5 7</span></span><br><span class="line"><span class="keyword">while</span> (!q1.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; q1.<span class="built_in">front</span>() &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">q1.<span class="built_in">pop</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-4-queue拷贝构造与赋值"><a href="#2-6-4-queue拷贝构造与赋值" class="headerlink" title="2.6.4 queue拷贝构造与赋值"></a>2.6.4 queue拷贝构造与赋值</h4><ul><li>queue(const queue&amp; que);//拷贝构造函数</li><li>queue&amp; operator=(const queue&amp; que);//重载等号操作符</li></ul><h4 id="2-6-5-queue的大小"><a href="#2-6-5-queue的大小" class="headerlink" title="2.6.5 queue的大小"></a>2.6.5 queue的大小</h4><ul><li>queue.empty();//判断队列是否为空</li><li>queue.size();//返回队列中元素个数</li></ul><h3 id="2-7-set"><a href="#2-7-set" class="headerlink" title="2.7 set"></a>2.7 set</h3><h4 id="2-7-1-set-multiset容器简介"><a href="#2-7-1-set-multiset容器简介" class="headerlink" title="2.7.1 set/multiset容器简介"></a>2.7.1 set/multiset容器简介</h4><ul><li>set是一个集合容器，其中所包含的元素是<strong>唯一</strong>的（去重），<strong>集合中的元素按一定的顺序排列</strong>。元素插入过程是按排序规则插入，所以不能插入指定位置</li><li>set采用<strong>红黑树</strong>变体的数据结构，红黑树属于平衡二叉树，在插入和删除操作上比vector快</li><li>set不可以直接存取元素（不可以使用at.(pos)与[]操作符）</li><li>multiset与set的区别：set支持唯一键值，每个元素值只能出现一次；而multiset中同一个值可以出现多次</li><li>不可以直接修改set或multiset容器中的元素值，因为该类容器时自动排序的；如果希望修改一个元素值，必须先删除原有元素，再插入新的元素</li><li>使用需包含&lt; set &gt;头文件</li></ul><h4 id="2-7-2-set-multiset对象默认构造"><a href="#2-7-2-set-multiset对象默认构造" class="headerlink" title="2.7.2 set/multiset对象默认构造"></a>2.7.2 set/multiset对象默认构造</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; setint;<span class="comment">//一个存放int的set容器</span></span><br><span class="line">set&lt;string&gt; setstr;<span class="comment">//一个存放string的set容器</span></span><br><span class="line">multiset&lt;<span class="type">int</span>&gt; mulsetint;<span class="comment">//一个存放int的multiset容器</span></span><br></pre></td></tr></table></figure><h4 id="2-7-3-set容器的插入和迭代器"><a href="#2-7-3-set容器的插入和迭代器" class="headerlink" title="2.7.3 set容器的插入和迭代器"></a>2.7.3 set容器的插入和迭代器</h4><ul><li>set.insert(elem);//在容器中插入元素</li><li>set.insert(beg,end);//插入范围[beg,end)内的元素</li><li>set.begin();//返回容器中第一个数据的迭代器</li><li>set.end();//返回容器中最后一个数据之后的迭代器</li><li>set.rbegin();//返回容器中倒数第一个元素的迭代器</li><li>set.rend();//返回容器中倒数最后一个元素的后面的迭代器</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line"><span class="comment">//1 3 5 7</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = s1.<span class="built_in">begin</span>(); i != s1.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//7 5 3 1</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = s1.<span class="built_in">rbegin</span>(); i != s1.<span class="built_in">rend</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="2-7-4-set容器的拷贝构造和赋值"><a href="#2-7-4-set容器的拷贝构造和赋值" class="headerlink" title="2.7.4 set容器的拷贝构造和赋值"></a>2.7.4 set容器的拷贝构造和赋值</h4><ul><li>set(const set&amp; st);//拷贝构造函数</li><li>set&amp; operator=(const set&amp; st);</li><li>set.swap(st);//交换两个集合容器</li></ul><h4 id="2-7-5-set的大小"><a href="#2-7-5-set的大小" class="headerlink" title="2.7.5 set的大小"></a>2.7.5 set的大小</h4><ul><li>set.size();//返回容器中元素的个数</li><li>set.empty();//判断容器是否为空</li></ul><h4 id="2-7-6-set容器的删除"><a href="#2-7-6-set容器的删除" class="headerlink" title="2.7.6 set容器的删除"></a>2.7.6 set容器的删除</h4><ul><li>set.clear();//清楚所有元素</li><li>set.erase(pos);//删除迭代器pos（不可以为反向迭代器）所指的元素，返回下一个元素的迭代器</li><li>set.erase(beg,end);//删除区间[beg,end)的所有元素</li><li>set.erase(elem);//删除容器中值为elem的元素；元素存在返回true，否则返回false</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">3</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">5</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">s1.<span class="built_in">erase</span>(s1.<span class="built_in">begin</span>());</span><br><span class="line"><span class="comment">//3 5 7</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = s1.<span class="built_in">begin</span>(); i != s1.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">s1.<span class="built_in">erase</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//3 7</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = s1.<span class="built_in">begin</span>(); i != s1.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="2-7-8-set容器的元素排序"><a href="#2-7-8-set容器的元素排序" class="headerlink" title="2.7.8 set容器的元素排序"></a>2.7.8 set容器的元素排序</h4><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>,less&lt;<span class="type">int</span>&gt;&gt; setintA;<span class="comment">//该容器是按照升序方式排列元素</span></span><br><span class="line">set&lt;<span class="type">int</span>,greater&lt;<span class="type">int</span>&gt;&gt; setintB;<span class="comment">//该容器是按降序方式排列元素</span></span><br></pre></td></tr></table></figure><ul><li>默认情况是升序</li><li>less&lt; int &gt;与greater&lt; int &gt;中的int可以更改，要与set容纳的数据类型一致</li></ul><h4 id="2-7-9-set容器的查找"><a href="#2-7-9-set容器的查找" class="headerlink" title="2.7.9 set容器的查找"></a>2.7.9 set容器的查找</h4><ul><li>set.find(elem);//查找elem元素，返回指向elem元素的迭代器</li><li>set.count(elem);//返回容器中值为elem的元素个数：对set来说，要么是0，要么是1；对multiset来说，值可能大于1</li><li>set.lower_bound(elem);//返回第一个&gt;=elem元素的迭代器</li><li>set.upper_bound(elem);//返回第一个&gt;elem元素的迭代器</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">12</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">43</span>);</span><br><span class="line">set&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">if</span> (s1.<span class="built_in">find</span>(<span class="number">43</span>) != s1.<span class="built_in">end</span>())<span class="comment">//找不到返回set.end()</span></span><br><span class="line">&#123;</span><br><span class="line">it = s1.<span class="built_in">find</span>(<span class="number">43</span>);</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;<span class="comment">//43</span></span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; s1.<span class="built_in">count</span>(<span class="number">12</span>) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; s1.<span class="built_in">count</span>(<span class="number">100</span>);<span class="comment">//1 0</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; *s1.<span class="built_in">lower_bound</span>(<span class="number">12</span>) &lt;&lt; endl;<span class="comment">//12</span></span><br><span class="line">cout &lt;&lt; *s1.<span class="built_in">upper_bound</span>(<span class="number">12</span>) &lt;&lt; endl;<span class="comment">//43</span></span><br></pre></td></tr></table></figure><h4 id="2-7-10-set容器set-equal-range-elem"><a href="#2-7-10-set容器set-equal-range-elem" class="headerlink" title="2.7.10 set容器set.equal_range(elem)"></a>2.7.10 set容器set.equal_range(elem)</h4><ul><li>返回容器中与elem相等的上下限的两个迭代器，上限是闭区间，下限是开区间即[beg,end)；相当于返回set.lower_bound(elem)与set.upper_bound(elem)两个迭代器</li><li>函数返回的迭代器被封装到pair中<ul><li>pair是对组，可以将两个值视为一个单元</li><li>pair&lt;T1,T2&gt;存放的两个值的类型，可以不一样，亦可以为自定义类型</li><li>pair.first是pair里面的第一个值，为T1类型</li><li>pair.second是pair里面的第二个值，为T2类型</li></ul></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pair&lt;set&lt;<span class="type">int</span>&gt;::iterator,set&lt;<span class="type">int</span>&gt;::iterator&gt; pairIt=set.<span class="built_in">equal_range</span>(elem)</span><br></pre></td></tr></table></figure><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s1;</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">4</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">12</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">2</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">43</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">7</span>);</span><br><span class="line">s1.<span class="built_in">insert</span>(<span class="number">10</span>);</span><br><span class="line">pair&lt;set&lt;<span class="type">int</span>&gt;::iterator, set&lt;<span class="type">int</span>&gt;::iterator &gt; it;</span><br><span class="line">it = s1.<span class="built_in">equal_range</span>(<span class="number">7</span>);</span><br><span class="line"><span class="keyword">if</span> (it.first != s1.<span class="built_in">end</span>() &amp;&amp; it.second != s1.<span class="built_in">end</span>())</span><br><span class="line"><span class="comment">//上下限都存在的情况下</span></span><br><span class="line"><span class="comment">//7 10</span></span><br><span class="line">cout &lt;&lt; *(it.first) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *(it.second) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;no find&quot;</span> &lt;&lt; endl;</span><br><span class="line">it = s1.<span class="built_in">equal_range</span>(<span class="number">100</span>);</span><br><span class="line"><span class="keyword">if</span> (it.first != s1.<span class="built_in">end</span>() &amp;&amp; it.second != s1.<span class="built_in">end</span>())</span><br><span class="line"><span class="comment">//上下限都存在的情况下</span></span><br><span class="line">cout &lt;&lt; *(it.first) &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; *(it.second) &lt;&lt; endl;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="comment">//no find</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;no find&quot;</span> &lt;&lt; endl;</span><br></pre></td></tr></table></figure><h3 id="2-8-map"><a href="#2-8-map" class="headerlink" title="2.8 map"></a>2.8 map</h3><h4 id="2-8-1-map-multimap容器简介"><a href="#2-8-1-map-multimap容器简介" class="headerlink" title="2.8.1 map/multimap容器简介"></a>2.8.1 map/multimap容器简介</h4><ul><li><p>map的特性是，所有的元素会根据元素的键值自动排序</p></li><li><p>map的所有的元素都是pair：</p><ul><li>pair的第一元素被视为键值key，第二元素被视为实值value；</li><li>map不允许两个元素有相同的键值</li></ul></li><li><p>不能通过迭代器改变map的键值，但是可以任意修改实值</p></li><li><p>multimap键值可以重复</p></li><li><p>map和multimap都是以<strong>红黑树</strong>作为底层实现机制</p></li></ul><h4 id="2-8-2-map-multimap容器对象的默认构造"><a href="#2-8-2-map-multimap容器对象的默认构造" class="headerlink" title="2.8.2 map/multimap容器对象的默认构造"></a>2.8.2 map/multimap容器对象的默认构造</h4><ul><li>map/multimap采用模板类实现，默认构造形式：<ul><li>map&lt;T1,T2&gt; mapTT;</li><li>multimap&lt;T1,T2&gt; multimapTT;</li></ul></li><li>T1,T2还可以是各种指针类型或自定义类型</li></ul><h4 id="2-8-3-map容器的插入"><a href="#2-8-3-map容器的插入" class="headerlink" title="2.8.3 map容器的插入"></a>2.8.3 map容器的插入</h4><ul><li>通过pair的方式插入对象：map.insert(pair&lt;T1,T2&gt;(key,value));（推荐使用）</li><li>通过value_type的方式插入对象：map.insert(map&lt;T1,T2&gt;::value_type(key,value));（推荐使用）</li><li>通过数组的形式插入值：map[key]=value;//如果key不再map内会被放在map内先获得默认值</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">STU</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">STU</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">STU</span>(<span class="type">int</span> id, string name) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;ID = id;</span><br><span class="line"><span class="keyword">this</span>-&gt;Name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> ID;</span><br><span class="line">string Name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, STU&gt; students;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">STU <span class="title">s1</span><span class="params">(i, <span class="string">&quot;Lucy&quot;</span> + to_string(i))</span></span>;</span><br><span class="line">students.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,STU&gt;(i, s1));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = students.<span class="built_in">begin</span>(); i != students.<span class="built_in">end</span>(); ++i)</span><br><span class="line">&#123;</span><br><span class="line">pair&lt;<span class="type">int</span>, STU&gt; it = *i;</span><br><span class="line">cout &lt;&lt; it.first &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; it.second.Name &lt;&lt; endl;</span><br><span class="line">        <span class="comment">//不构建pair对组的方式：</span></span><br><span class="line">        <span class="comment">//cout &lt;&lt; i-&gt;first &lt;&lt; &quot;: &quot; &lt;&lt; i-&gt;second.Name &lt;&lt; endl;</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//0: Lucy0</span></span><br><span class="line"><span class="comment">//1: Lucy1</span></span><br><span class="line"><span class="comment">//2: Lucy2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：第三种方法存在一个性能问题：如果key存在的话就要执行修改，而修改是先删除该pair再添加新的pair</p></blockquote><blockquote><p>注：insert方法在key存在时不会覆盖原来的键值对，而数组的方式在key存在时会覆盖原来的键值对</p></blockquote><h4 id="2-8-4-map容器对象获取键对应的值"><a href="#2-8-4-map容器对象获取键对应的值" class="headerlink" title="2.8.4 map容器对象获取键对应的值"></a>2.8.4 map容器对象获取键对应的值</h4><ul><li>使用[]，但是当key不存在时会将其插入，value为默认值</li><li>使用find函数：成功返回对应的迭代器，失败返回map.end()（推荐使用）</li><li>使用at()函数，如果键值对不存在会抛出”out_of_range”异常</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">STU</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">STU</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">STU</span>(<span class="type">int</span> id, string name) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;ID = id;</span><br><span class="line"><span class="keyword">this</span>-&gt;Name = name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">int</span> ID;</span><br><span class="line">string Name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">map&lt;<span class="type">int</span>, STU&gt; students;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">STU <span class="title">s1</span><span class="params">(i, <span class="string">&quot;Lucy&quot;</span> + to_string(i))</span></span>;</span><br><span class="line">students.<span class="built_in">insert</span>(<span class="built_in">pair</span>&lt;<span class="type">int</span>,STU&gt;(i, s1));</span><br><span class="line">&#125;</span><br><span class="line">cout &lt;&lt; students[<span class="number">1</span>].Name &lt;&lt; endl;<span class="comment">//Lucy1</span></span><br><span class="line"><span class="keyword">if</span> (students.<span class="built_in">find</span>(<span class="number">2</span>) != students.<span class="built_in">end</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> it = students.<span class="built_in">find</span>(<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; it-&gt;second.Name &lt;&lt; endl;<span class="comment">//Lucy2</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No Find!!&quot;</span> &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; students.<span class="built_in">at</span>(<span class="number">3</span>).Name &lt;&lt; endl;<span class="comment">//报错</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-算法"><a href="#3-算法" class="headerlink" title="3.算法"></a>3.算法</h2><h3 id="3-1-函数对象"><a href="#3-1-函数对象" class="headerlink" title="3.1 函数对象"></a>3.1 函数对象</h3><p>重载函数调用操作符的类，其对象常称为函数对象(function object)，即它们是行为类似函数的对象，也叫仿函数(functor)，其实就是重载”()”运算符，使得类对象可以像函数那样调用</p><blockquote><p>注意</p></blockquote><ul><li>函数对象（仿函数）是一个类，不是一个函数</li><li>函数对象（仿函数）重载了”()”操作符，使得它可以像函数一样调用</li></ul><blockquote><p>分类</p></blockquote><ul><li>如果函数对象有一个参数叫：一元函数对象</li><li>如果函数对象有两个参数叫：二元函数对象</li><li>如果函数对象有三个参数叫：三元函数对象</li></ul><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Print</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line">Print op;<span class="comment">//op为一元函数对象</span></span><br><span class="line"><span class="built_in">op</span>(<span class="string">&quot;Hello world!&quot;</span>);<span class="comment">//Hello world!</span></span><br><span class="line"><span class="comment">//方式2</span></span><br><span class="line"><span class="built_in">Print</span>()(<span class="string">&quot;Hello world!&quot;</span>);<span class="comment">//Hello world!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="built_in">test</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>总结</p></blockquote><ul><li><p>函数对象通常不定义构造函数和析构函数，所以在构造和析构时不会发生任何问题，避免了函数调用的运行时问题</p></li><li><p>函数对象超出普通函数的概念，函数对象可以有自己的状态</p></li><li><p>函数对象可内联编译，性能好，用函数指针几乎不可能</p></li><li><p>模板函数对象使函数对象具有通用性</p></li></ul><h3 id="3-2-谓词"><a href="#3-2-谓词" class="headerlink" title="3.2 谓词"></a>3.2 谓词</h3><p>返回值为bool类型的普通函数或仿函数都叫谓词：</p><ul><li>如果谓词有一个参数叫：一元谓词</li><li>如果谓词有两个参数叫：二元谓词</li></ul><h4 id="3-2-1-一元谓词"><a href="#3-2-1-一元谓词" class="headerlink" title="3.2.1 一元谓词"></a>3.2.1 一元谓词</h4><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">greaterthan30</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &gt; <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greaterthan30</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> value &gt; <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">v1.<span class="built_in">push_back</span>(i * <span class="number">10</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line"><span class="comment">//find_if条件查找:find_if会将容器区间对应的“元素”传给第三个参数</span></span><br><span class="line"><span class="comment">//普通函数方式</span></span><br><span class="line"><span class="comment">/*it = find_if(v1.begin(), v1.end(), greaterthan30);*/</span></span><br><span class="line"><span class="comment">//仿函数方式</span></span><br><span class="line">it = <span class="built_in">find_if</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">Greaterthan30</span>());</span><br><span class="line"><span class="keyword">if</span> (it != v1.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;<span class="comment">//40</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-二元谓词"><a href="#3-2-2-二元谓词" class="headerlink" title="3.2.2 二元谓词"></a>3.2.2 二元谓词</h4><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Greater</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> v1, <span class="type">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">Greater</span>());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-内建函数对象"><a href="#3-3-内建函数对象" class="headerlink" title="3.3 内建函数对象"></a>3.3 内建函数对象</h3><p>STL内建了一些函数对象，分为以下三种：算术类函数对象、关系运算符类函数对象、逻辑运算符类函数对象。这些仿函数所产生的对象用法和一般函数完全相同，当然也可以产生无名的临时对象来履行函数功能</p><ul><li> 算术类函数对象，除了negate是一元运算，其他都是二元运算</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T plus&lt;T&gt;<span class="comment">//加法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T minus&lt;T&gt;<span class="comment">//减法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T multiplies&lt;T&gt;<span class="comment">//乘法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T divides&lt;T&gt;<span class="comment">//除法仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T modules&lt;T&gt;<span class="comment">//取模仿函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; T negate&lt;T&gt;<span class="comment">//取反仿函数</span></span><br></pre></td></tr></table></figure><ul><li>关系运算类函数对象，每一种都是二元运算</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">bool</span> equal_to&lt;T&gt;<span class="comment">//等于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">bool</span> not_equal_to&lt;T&gt;<span class="comment">//不等于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">bool</span> greater&lt;T&gt;<span class="comment">//大于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">bool</span> greater_equal&lt;T&gt;<span class="comment">//大于等于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">bool</span> less&lt;T&gt;<span class="comment">//小于</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">bool</span> less_equal&lt;T&gt;<span class="comment">//小于等于</span></span><br></pre></td></tr></table></figure><ul><li>逻辑运算类运算函数，not为一元运算，其余为二元运算</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">bool</span> logical_and&lt;T&gt;<span class="comment">//逻辑与</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">bool</span> logical_or&lt;T&gt;<span class="comment">//逻辑或</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;<span class="type">bool</span> logical_not&lt;T&gt;<span class="comment">//逻辑非</span></span><br></pre></td></tr></table></figure><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> i = v.<span class="built_in">begin</span>(); i != v.<span class="built_in">end</span>(); ++i)</span><br><span class="line">cout &lt;&lt; *i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//30 20 10 5</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-适配器"><a href="#3-4-适配器" class="headerlink" title="3.4 适配器"></a>3.4 适配器</h3><ul><li>适配器为算法提供接口</li><li>使用需包含头文件&lt; functional &gt;</li></ul><h4 id="3-4-1-函数对象适配器"><a href="#3-4-1-函数对象适配器" class="headerlink" title="3.4.1 函数对象适配器"></a>3.4.1 函数对象适配器</h4><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span><span class="comment">//提供适配器</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="comment">//第二步：公共继承binary_function参数萃取</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PrintInt</span>:<span class="keyword">public</span> binary_function&lt;<span class="type">int</span>,<span class="type">int</span>,<span class="type">void</span>&gt;<span class="comment">//形参类型+返回值类型</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//第三步：const修饰operator()</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> tmp)</span> <span class="type">const</span></span>&#123;</span><br><span class="line">cout &lt;&lt; val + tmp &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//第一步：bind2nd或bind1st绑定参数，因为for_each只有3个参数</span></span><br><span class="line"><span class="comment">//bind2nd和bind1st区别主要是将100这个实参绑定到哪个形参位置</span></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">PrintInt</span>(), <span class="number">100</span>));</span><br><span class="line">    <span class="comment">//120 110 130 105</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-2-函数指针适配器ptr-fun"><a href="#3-4-2-函数指针适配器ptr-fun" class="headerlink" title="3.4.2 函数指针适配器ptr_fun"></a>3.4.2 函数指针适配器ptr_fun</h4><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span><span class="comment">//提供适配器</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">myPrintInt</span><span class="params">(<span class="type">int</span> val, <span class="type">int</span> temp)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; val + temp &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">ptr_fun</span>(myPrintInt), <span class="number">100</span>));</span><br><span class="line">    <span class="comment">//120 110 130 105</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明</p></blockquote><ul><li>上述例子中for_each最后一个参数是需要传递函数入口地址，但是C++中函数名代表不了函数入口地址，在C++编译器里会通过函数名和形参类型共同决定函数入口地址，所以就要使用函数指针的宏<strong>ptr_fun</strong>让底层把ptr_fun(FunctionName)换成这个函数的入口地址</li><li>使用ptr_fun同样需包含头文件&lt; functional &gt;</li><li>ptr_fun将普通函数适配为一个仿函数</li></ul><h4 id="3-4-3-成员函数适配器mem-fun-ref"><a href="#3-4-3-成员函数适配器mem-fun-ref" class="headerlink" title="3.4.3 成员函数适配器mem_fun_ref"></a>3.4.3 成员函数适配器mem_fun_ref</h4><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span><span class="comment">//提供适配器</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Data</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">int</span> data;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Data</span>() &#123;&#125;;</span><br><span class="line"><span class="built_in">Data</span>(<span class="type">int</span> val) &#123; data = val; &#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintInt</span><span class="params">(<span class="type">int</span> tmp)</span> </span>&#123;</span><br><span class="line">cout &lt;&lt; data + tmp &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">vector&lt;Data&gt; v;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="built_in">Data</span>(<span class="number">10</span>));</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="built_in">Data</span>(<span class="number">20</span>));</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="built_in">Data</span>(<span class="number">30</span>));</span><br><span class="line">    <span class="comment">//成员函数必须是容器存放对象的成员函数</span></span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">mem_fun_ref</span>(&amp;Data::PrintInt), <span class="number">100</span>));</span><br><span class="line"><span class="comment">//110 120 130</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>说明</p></blockquote><ul><li><p>mem_fun_ref是一种适配器，该函数能将类的成员函数包装成仿函数使用，于是成员函数可以搭配各种泛型算法完成所谓的多态调用</p></li><li><p>使用需包含头文件&lt; functional &gt;</p></li><li><p>mem_fun_ref和mem_fun的作用和用法一样，唯一不同的就是当容器中存放的是对象实体时用mem_fun_ref，当容器中存放的时对象的指针时用mem_fun</p></li></ul><h4 id="3-4-4-取反适配器"><a href="#3-4-4-取反适配器" class="headerlink" title="3.4.4 取反适配器"></a>3.4.4 取反适配器</h4><ul><li>一元取反</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span><span class="comment">//提供适配器</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">it = <span class="built_in">find_if</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not1</span>(<span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">8</span>)));</span><br><span class="line"><span class="keyword">if</span> (it != v.<span class="built_in">end</span>())</span><br><span class="line">cout &lt;&lt; *it &lt;&lt; endl;<span class="comment">//5</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>二元取反</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span><span class="comment">//提供适配器</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [=](<span class="type">int</span> val) &#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//10 5 30 20</span></span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), <span class="built_in">not2</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;()));</span><br><span class="line">for_each(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>(), [=](<span class="type">int</span> val) &#123;</span><br><span class="line">cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//5 10 20 30</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>lambda表达式（C++11才支持）</p></blockquote><ul><li>[  ]：里面什么都不写，lambda不能识别外部数据</li><li>[=]：lambda能对外部数据进行读操作</li><li>[&amp;]：lambda能对外部数据进行读写操作</li></ul><h3 id="3-5-常用遍历算法"><a href="#3-5-常用遍历算法" class="headerlink" title="3.5 常用遍历算法"></a>3.5 常用遍历算法</h3><h4 id="3-5-1-for-each遍历算法"><a href="#3-5-1-for-each遍历算法" class="headerlink" title="3.5.1 for_each遍历算法"></a>3.5.1 for_each遍历算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">遍历算法 遍历容器元素</span></span><br><span class="line"><span class="comment">@param beg 开始迭代器</span></span><br><span class="line"><span class="comment">@param end 结束迭代器</span></span><br><span class="line"><span class="comment">@param _callback 函数回调或者函数对象</span></span><br><span class="line"><span class="comment">@return 函数对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">for_each(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure><h4 id="3-5-2-transform算法"><a href="#3-5-2-transform算法" class="headerlink" title="3.5.2 transform算法"></a>3.5.2 transform算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">transform算法 将指定容器区间元素搬运到另一容器中</span></span><br><span class="line"><span class="comment">注意： transform不会给目标容器分配内存，需要提前分配好内存</span></span><br><span class="line"><span class="comment">@param beg1 源容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end1 源容器结束迭代器</span></span><br><span class="line"><span class="comment">@param beg2 目标容器开始迭代器</span></span><br><span class="line"><span class="comment">@param _callback 函数回调或者函数对象</span></span><br><span class="line"><span class="comment">@return 返回目标容器迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">transform</span>(iterator beg1, iterator end1, iterator beg2, _callback);</span><br></pre></td></tr></table></figure><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">myTransform</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2;</span><br><span class="line">v2.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line"><span class="built_in">transform</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(),myTransform);</span><br><span class="line">for_each(v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), [=](<span class="type">int</span> v) &#123;</span><br><span class="line">cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//10 5 30 20</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6-常用查找算法"><a href="#3-6-常用查找算法" class="headerlink" title="3.6 常用查找算法"></a>3.6 常用查找算法</h3><h4 id="3-6-1-find算法"><a href="#3-6-1-find算法" class="headerlink" title="3.6.1 find算法"></a>3.6.1 find算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">find算法 查找元素</span></span><br><span class="line"><span class="comment">@prama beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@prama end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@prama value 查找的元素</span></span><br><span class="line"><span class="comment">@return 返回查找元素的位置</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">find</span>(iterator beg, iterator end, value);</span><br></pre></td></tr></table></figure><h4 id="3-6-2-find-if算法"><a href="#3-6-2-find-if算法" class="headerlink" title="3.6.2 find_if算法"></a>3.6.2 find_if算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">find_if算法 条件查找</span></span><br><span class="line"><span class="comment">@prama beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@prama end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@prama _callback 回调函数或谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">@return 返回指定位置迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">find_if</span>(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure><h4 id="3-6-3-adjacent-find算法"><a href="#3-6-3-adjacent-find算法" class="headerlink" title="3.6.3 adjacent_find算法"></a>3.6.3 adjacent_find算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">adjacent_find算法 查找相邻重复元素</span></span><br><span class="line"><span class="comment">@prama beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@prama end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@prama _callback 回调函数或谓词(返回bool类型的函数对象)一般没有就空着</span></span><br><span class="line"><span class="comment">@return 返回相邻元素的第一个位置的代码，无则返回end迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">adjacent_find</span>(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure><h4 id="3-6-4-binary-search算法"><a href="#3-6-4-binary-search算法" class="headerlink" title="3.6.4 binary_search算法"></a>3.6.4 binary_search算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">binary_search算法 二分查找法</span></span><br><span class="line"><span class="comment">注意：在无序序列中不可用</span></span><br><span class="line"><span class="comment">@prama beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@prama end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@prama value 查找的元素</span></span><br><span class="line"><span class="comment">@return bool 查找成功返回true否则false</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">binary_search</span><span class="params">(iterator beg, iterator end, value)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="3-6-5-count算法"><a href="#3-6-5-count算法" class="headerlink" title="3.6.5 count算法"></a>3.6.5 count算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">count算法 统计元素出现次数</span></span><br><span class="line"><span class="comment">@prama beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@prama end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@prama value 查找的元素</span></span><br><span class="line"><span class="comment">@return 元素出现的次数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">count</span>(iterator beg, iterator end, value);</span><br></pre></td></tr></table></figure><h4 id="3-6-6-count-if算法"><a href="#3-6-6-count-if算法" class="headerlink" title="3.6.6 count_if算法"></a>3.6.6 count_if算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">count_if算法 按条件统计元素出现次数</span></span><br><span class="line"><span class="comment">@prama beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@prama end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@prama _callback 回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">@return 元素出现的次数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">count_if</span>(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line">cout &lt;&lt; <span class="built_in">count_if</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">15</span>));<span class="comment">//2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-7-常用排序算法"><a href="#3-7-常用排序算法" class="headerlink" title="3.7 常用排序算法"></a>3.7 常用排序算法</h3><h4 id="3-7-1-merge算法"><a href="#3-7-1-merge算法" class="headerlink" title="3.7.1 merge算法"></a>3.7.1 merge算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">merge算法 容器元素合并，并存储到另一容器中</span></span><br><span class="line"><span class="comment">注意：</span></span><br><span class="line"><span class="comment">* 两个源容器必须是有序的</span></span><br><span class="line"><span class="comment">* 不会给目标容器分配内存，需要提前分配好内存</span></span><br><span class="line"><span class="comment">@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">@param dest 目标容器开始迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">merge</span>(iterator beg1, iterator end1,iterator beg2, iterator end2,iterator dest);</span><br></pre></td></tr></table></figure><h4 id="3-7-2-sort算法"><a href="#3-7-2-sort算法" class="headerlink" title="3.7.2 sort算法"></a>3.7.2 sort算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">sort算法 容器元素排序</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param _callback 回调函数或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">sort</span>(iterator beg, iterator end, _callback);</span><br></pre></td></tr></table></figure><h4 id="3-7-3-random-shuffle算法"><a href="#3-7-3-random-shuffle算法" class="headerlink" title="3.7.3 random_shuffle算法"></a>3.7.3 random_shuffle算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">random_shuffle算法 对指定范围内的元素随机调整次序</span></span><br><span class="line"><span class="comment">注意：可以使用随机数种子srand(time(NULL))保证每次随机不同</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">random_shuffle</span>(iterator beg, iterator end);</span><br></pre></td></tr></table></figure><h4 id="3-7-4-reverse算法"><a href="#3-7-4-reverse算法" class="headerlink" title="3.7.4 reverse算法"></a>3.7.4 reverse算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">reverse算法 反转指定范围的元素</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">reverse</span>(iterator beg,iterator end);</span><br></pre></td></tr></table></figure><h3 id="3-8-常用拷贝替换算法"><a href="#3-8-常用拷贝替换算法" class="headerlink" title="3.8 常用拷贝替换算法"></a>3.8 常用拷贝替换算法</h3><h4 id="3-8-1-copy算法"><a href="#3-8-1-copy算法" class="headerlink" title="3.8.1 copy算法"></a>3.8.1 copy算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">copy算法 将容器内指定范围的元素拷贝到另一容器中</span></span><br><span class="line"><span class="comment">注意： copy不会给目标容器分配内存，需要提前分配好内存</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param dest 目标起始迭代器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">copy</span>(iterator beg, iterator end, iterator dest);</span><br></pre></td></tr></table></figure><blockquote><p>实例演示（打印容器元素的新方法）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span><span class="comment">//提供终端迭代器</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">//10 5 30 20</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-8-2-replace算法"><a href="#3-8-2-replace算法" class="headerlink" title="3.8.2 replace算法"></a>3.8.2 replace算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">replace算法 将容器内指定范围内的旧元素修改为新元素</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param oldval 旧元素</span></span><br><span class="line"><span class="comment">@param newval 新元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">replace</span>(iterator beg, iterator end, oldval, newval);</span><br></pre></td></tr></table></figure><h4 id="3-8-3-replace-if算法"><a href="#3-8-3-replace-if算法" class="headerlink" title="3.8.3 replace_if算法"></a>3.8.3 replace_if算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">replace_if算法 将容器内指定范围内的满足条件的元素修改为新元素</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param _callback 函数回调或者谓词(返回bool类型的函数对象)</span></span><br><span class="line"><span class="comment">@param newval 新元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">replace_if</span>(iterator beg, iterator end, _callback, newval);</span><br></pre></td></tr></table></figure><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span><span class="comment">//提供终端迭代器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">LessThan15</span><span class="params">(<span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &lt;= <span class="number">15</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1;</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">30</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">5</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">10</span>);</span><br><span class="line">v1.<span class="built_in">push_back</span>(<span class="number">20</span>);</span><br><span class="line"><span class="built_in">replace_if</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), LessThan15, <span class="number">15</span>);</span><br><span class="line"><span class="built_in">replace_if</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">bind2nd</span>(<span class="built_in">greater</span>&lt;<span class="type">int</span>&gt;(), <span class="number">15</span>), <span class="number">100</span>);</span><br><span class="line"><span class="built_in">copy</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">//100 15 15 100</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-8-4-swap算法"><a href="#3-8-4-swap算法" class="headerlink" title="3.8.4 swap算法"></a>3.8.4 swap算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">swap算法 互换两个容器的元素</span></span><br><span class="line"><span class="comment">@param c1 容器1</span></span><br><span class="line"><span class="comment">@param c2 容器2</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">swap</span>(container c1,container c2);</span><br></pre></td></tr></table></figure><h3 id="3-9-常用算术生成算法"><a href="#3-9-常用算术生成算法" class="headerlink" title="3.9 常用算术生成算法"></a>3.9 常用算术生成算法</h3><h4 id="3-9-1-accumulate算法"><a href="#3-9-1-accumulate算法" class="headerlink" title="3.9.1 accumulate算法"></a>3.9.1 accumulate算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">accmulate算法 计算容器累计总和</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param value 累加值</span></span><br><span class="line"><span class="comment">@return 最终返回值是总和加上value</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">accmulate</span>(iterator beg,iterator end,value);</span><br></pre></td></tr></table></figure><h4 id="3-9-2-fill算法"><a href="#3-9-2-fill算法" class="headerlink" title="3.9.2 fill算法"></a>3.9.2 fill算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*fill算法 对容器某个区间进行填充</span></span><br><span class="line"><span class="comment">@param beg 容器开始迭代器</span></span><br><span class="line"><span class="comment">@param end 容器结束迭代器</span></span><br><span class="line"><span class="comment">@param value 填充值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">fill</span>(iterator beg,iterator end,value);</span><br></pre></td></tr></table></figure><h3 id="3-10-常用集合算法"><a href="#3-10-常用集合算法" class="headerlink" title="3.10 常用集合算法"></a>3.10 常用集合算法</h3><h4 id="3-10-1-set-intersection算法"><a href="#3-10-1-set-intersection算法" class="headerlink" title="3.10.1 set_intersection算法"></a>3.10.1 set_intersection算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">set_intersection算法 求两个集合的交集</span></span><br><span class="line"><span class="comment">注意：两个集合必须是有序序列</span></span><br><span class="line"><span class="comment">@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">@param dest 目标容器开始迭代器</span></span><br><span class="line"><span class="comment">@return 目标容器的最后一个元素之后的迭代器地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">set_intersection</span>(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);</span><br></pre></td></tr></table></figure><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span><span class="comment">//提供终端迭代器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123; <span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2&#123; <span class="number">23</span>,<span class="number">34</span>,<span class="number">78</span>,<span class="number">90</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;<span class="comment">//存交集</span></span><br><span class="line">v.<span class="built_in">resize</span>(<span class="built_in">min</span>(v1.<span class="built_in">size</span>(), v2.<span class="built_in">size</span>()));</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">it = <span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">copy</span>(v.<span class="built_in">begin</span>(), it, <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">//23 34</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-10-2-set-union算法"><a href="#3-10-2-set-union算法" class="headerlink" title="3.10.2  set_union算法"></a>3.10.2  set_union算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">set_union算法 求两个集合的并集</span></span><br><span class="line"><span class="comment">注意：两个集合必须是有序序列</span></span><br><span class="line"><span class="comment">@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">@param dest 目标容器开始迭代器</span></span><br><span class="line"><span class="comment">@return 目标容器的最后一个元素之后的迭代器地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">set_union</span>(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);</span><br></pre></td></tr></table></figure><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span><span class="comment">//提供终端迭代器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123; <span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2&#123; <span class="number">23</span>,<span class="number">34</span>,<span class="number">78</span>,<span class="number">90</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;<span class="comment">//存并集</span></span><br><span class="line">v.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>() + v2.<span class="built_in">size</span>());</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">it = <span class="built_in">set_union</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">copy</span>(v.<span class="built_in">begin</span>(), it, <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">//12 23 34 45 56 78 90</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-10-3-set-difference算法"><a href="#3-10-3-set-difference算法" class="headerlink" title="3.10.3 set_difference算法"></a>3.10.3 set_difference算法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">set_difference算法 求两个集合的差集(某个集合和交集相差的部分)</span></span><br><span class="line"><span class="comment">注意：两个集合必须是有序序列</span></span><br><span class="line"><span class="comment">@param beg1 容器1开始迭代器</span></span><br><span class="line"><span class="comment">@param end1 容器1结束迭代器</span></span><br><span class="line"><span class="comment">@param beg2 容器2开始迭代器</span></span><br><span class="line"><span class="comment">@param end2 容器2结束迭代器</span></span><br><span class="line"><span class="comment">@param dest 目标容器开始迭代器</span></span><br><span class="line"><span class="comment">@return 目标容器的最后一个元素之后的迭代器地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">set_difference</span>(iterator beg1,iterator end1,iterator beg2,iterator end2,iterator dest);</span><br></pre></td></tr></table></figure><blockquote><p>实例演示</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iterator&gt;</span><span class="comment">//提供终端迭代器</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v1&#123; <span class="number">12</span>,<span class="number">23</span>,<span class="number">34</span>,<span class="number">45</span>,<span class="number">56</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v2&#123; <span class="number">23</span>,<span class="number">34</span>,<span class="number">78</span>,<span class="number">90</span> &#125;;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; v;<span class="comment">//存v1对v2的差集</span></span><br><span class="line">v.<span class="built_in">resize</span>(v1.<span class="built_in">size</span>());</span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::iterator it;</span><br><span class="line">it = <span class="built_in">set_difference</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(), v.<span class="built_in">begin</span>());</span><br><span class="line"><span class="built_in">copy</span>(v.<span class="built_in">begin</span>(), it, <span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line"><span class="comment">//12 45 56</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 基础学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C/C++ </tag>
            
            <tag> STL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客介绍</title>
      <link href="/post/%E5%8D%9A%E5%AE%A2%E4%BB%8B%E7%BB%8D.html"/>
      <url>/post/%E5%8D%9A%E5%AE%A2%E4%BB%8B%E7%BB%8D.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="博客简介"><a href="#博客简介" class="headerlink" title="博客简介"></a>博客简介</h2><p>​    Hello，欢迎来到我的个人博客！这是我博客的第一篇文章，这里简要介绍一下我建立博客的初衷以及博客的技术栈吧！</p><h3 id="建立博客的初衷"><a href="#建立博客的初衷" class="headerlink" title="建立博客的初衷"></a>建立博客的初衷</h3><p>​    起初想的是有一个博客来发一些自己所学的一些东西或者记录自己学习遇到的一些问题方便自己查看，但是后面了解到前端、服务器等等这些东西后觉得做个人网站对目前的我来说太遥远了；后来多亏了伟大的大数据在B站给我推了Hexo个人博客框架部署在Github的视频，然后就一直在收藏夹吃灰T_T，刚好前段时间一个朋友给我看了他做的博客，于是心血来潮在这两天断断续续借助<strong>B站视频</strong>和Hexo的<strong>Butterfly主题文档</strong>逐步建立起这个博客。（以下是具体链接）</p><blockquote><p>B站视频：<a href="https://www.bilibili.com/video/BV1aV411p7Bc/?share_source=copy_web">https://www.bilibili.com/video/BV1aV411p7Bc/?share_source=copy_web</a></p><p>Butterfly主题文档：<a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p></blockquote><h2 id="个人简介"><a href="#个人简介" class="headerlink" title="个人简介"></a>个人简介</h2><p>​    emmm接下来就简单的一个自我介绍，本人是一名22级的大一计科专业的学生，接触过C/C++，html，css、js、vue（不过都只是学到一些皮毛），然后参加过CTF比赛、数模，不过目前所参加过比赛大多数都是本着了解的目的去的，然后就是说说未来在博客会写的一些内容：</p><ul><li>首先就是记录学习开发、算法、数模、CTF还有其他一些杂七杂八的东西</li><li>然后记录自己的一些学习成果（开发的东西之类的</li><li>最后就是可能也许偶尔会写点随笔</li></ul><hr><p>​    本人第一次做博客，可能有所不足，如果以后写的文章有什么错误或者问题可以通过以下联系方式告知（添加请注明来意噢）：</p><div style="width: 50%;margin: auto"><img src="/post/%E5%8D%9A%E5%AE%A2%E4%BB%8B%E7%BB%8D/wechat.jpg" class title="author" alt="s WeChat"></div>]]></content>
      
      
      <categories>
          
          <category> 其他范畴 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Blog </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
